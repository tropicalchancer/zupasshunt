"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@zk-kit";
exports.ids = ["vendor-chunks/@zk-kit"];
exports.modules = {

/***/ "(ssr)/./node_modules/@zk-kit/artifacts/dist/index.node.js":
/*!***********************************************************!*\
  !*** ./node_modules/@zk-kit/artifacts/dist/index.node.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Project: () => (/* binding */ Project),\n/* harmony export */   download: () => (/* binding */ download),\n/* harmony export */   maybeDownload: () => (/* binding */ maybeDownload),\n/* harmony export */   maybeGetSnarkArtifacts: () => (/* binding */ maybeGetSnarkArtifacts),\n/* harmony export */   projects: () => (/* binding */ projects)\n/* harmony export */ });\n/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:fs */ \"node:fs\");\n/* harmony import */ var node_fs_promises__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:fs/promises */ \"node:fs/promises\");\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:path */ \"node:path\");\n/* harmony import */ var node_os__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! node:os */ \"node:os\");\n/**\n * @module @zk-kit/artifacts\n * @version 1.8.0\n * @file Utilities for downloading snark artifacts\n * @copyright Ethereum Foundation 2024\n * @license MIT\n * @see [Github]{@link https://github.com/privacy-scaling-explorations/snark-artifacts/tree/main/packages/artifacts}\n*/\n\n\n\n\n\nasync function download(url, outputPath) {\n    const { body, ok, statusText } = await fetch(url);\n    if (!ok)\n        throw new Error(`Failed to fetch ${url}: ${statusText}`);\n    if (!body)\n        throw new Error('Failed to get response body');\n    const dir = (0,node_path__WEBPACK_IMPORTED_MODULE_2__.dirname)(outputPath);\n    await (0,node_fs_promises__WEBPACK_IMPORTED_MODULE_1__.mkdir)(dir, { recursive: true });\n    const fileStream = (0,node_fs__WEBPACK_IMPORTED_MODULE_0__.createWriteStream)(outputPath);\n    const reader = body.getReader();\n    try {\n        const pump = async () => {\n            const { done, value } = await reader.read();\n            if (done) {\n                fileStream.end();\n                return;\n            }\n            fileStream.write(Buffer.from(value));\n            await pump();\n        };\n        await pump();\n    }\n    catch (error) {\n        fileStream.close();\n        throw error;\n    }\n}\nasync function maybeDownload(url, outputPath) {\n    if (!(0,node_fs__WEBPACK_IMPORTED_MODULE_0__.existsSync)(outputPath))\n        await download(url, outputPath);\n    return outputPath;\n}\n\nvar Project;\n(function (Project) {\n    Project[\"SEMAPHORE_IDENTITY\"] = \"semaphore-identity\";\n    Project[\"POSEIDON\"] = \"poseidon\";\n    // RLN = 'rln',\n    Project[\"SEMAPHORE\"] = \"semaphore\";\n})(Project || (Project = {}));\nconst projects = Object.values(Project);\n\nconst BASE_URL = 'https://snark-artifacts.pse.dev';\nconst getBaseUrl = (project, version) => `${BASE_URL}/${project}/${version}/${project}`;\n\nasync function maybeGetSnarkArtifacts$1(project, options = {}) {\n    if (!projects.includes(project))\n        throw new Error(`Project '${project}' is not supported`);\n    options.version ??= 'latest';\n    const url = getBaseUrl(project, options.version);\n    const parameters = options.parameters\n        ? `-${options.parameters.join('-')}`\n        : '';\n    return {\n        wasm: `${url}${parameters}.wasm`,\n        zkey: `${url}${parameters}.zkey`,\n    };\n}\n\nconst extractEndPath = (url) => url.split('pse.dev/')[1];\n/**\n * Downloads SNARK artifacts (`wasm` and `zkey`) files if not already present in OS tmp folder.\n * @example\n * ```ts\n * {\n *   wasm: \"/tmp/@zk-kit/semaphore-artifacts@latest/semaphore-3.wasm\",\n *   zkey: \"/tmp/@zk-kit/semaphore-artifacts@latest/semaphore-3.zkey\" .\n * }\n * ```\n * @returns {@link SnarkArtifacts}\n */\nasync function maybeGetSnarkArtifacts(...pars) {\n    const urls = await maybeGetSnarkArtifacts$1(...pars);\n    const outputPath = `${(0,node_os__WEBPACK_IMPORTED_MODULE_3__.tmpdir)()}/snark-artifacts/${extractEndPath(urls.wasm)}`;\n    const [wasm, zkey] = await Promise.all([\n        maybeDownload(urls.wasm, outputPath),\n        maybeDownload(urls.zkey, outputPath.replace(/.wasm$/, '.zkey')),\n    ]);\n    return {\n        wasm,\n        zkey,\n    };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHprLWtpdC9hcnRpZmFjdHMvZGlzdC9pbmRleC5ub2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUN3RDtBQUNmO0FBQ0w7QUFDSDs7QUFFakM7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBLDJDQUEyQyxJQUFJLElBQUksV0FBVztBQUM5RDtBQUNBO0FBQ0EsZ0JBQWdCLGtEQUFPO0FBQ3ZCLFVBQVUsdURBQUssUUFBUSxpQkFBaUI7QUFDeEMsdUJBQXVCLDBEQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1EQUFVO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQjtBQUMzQjs7QUFFQTtBQUNBLDRDQUE0QyxTQUFTLEdBQUcsUUFBUSxHQUFHLFFBQVEsR0FBRyxRQUFROztBQUV0Riw2REFBNkQ7QUFDN0Q7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QjtBQUMzQztBQUNBO0FBQ0EsaUJBQWlCLElBQUksRUFBRSxXQUFXO0FBQ2xDLGlCQUFpQixJQUFJLEVBQUUsV0FBVztBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwrQ0FBTSxHQUFHLG1CQUFtQiwwQkFBMEI7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU4RSIsInNvdXJjZXMiOlsiL1VzZXJzL2NoYW5jZW1jYWxsaXN0ZXIvUHJvamVjdHMvenVwYXNzaHVudC9ub2RlX21vZHVsZXMvQHprLWtpdC9hcnRpZmFjdHMvZGlzdC9pbmRleC5ub2RlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBAemsta2l0L2FydGlmYWN0c1xuICogQHZlcnNpb24gMS44LjBcbiAqIEBmaWxlIFV0aWxpdGllcyBmb3IgZG93bmxvYWRpbmcgc25hcmsgYXJ0aWZhY3RzXG4gKiBAY29weXJpZ2h0IEV0aGVyZXVtIEZvdW5kYXRpb24gMjAyNFxuICogQGxpY2Vuc2UgTUlUXG4gKiBAc2VlIFtHaXRodWJde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9wcml2YWN5LXNjYWxpbmctZXhwbG9yYXRpb25zL3NuYXJrLWFydGlmYWN0cy90cmVlL21haW4vcGFja2FnZXMvYXJ0aWZhY3RzfVxuKi9cbmltcG9ydCB7IGNyZWF0ZVdyaXRlU3RyZWFtLCBleGlzdHNTeW5jIH0gZnJvbSAnbm9kZTpmcyc7XG5pbXBvcnQgeyBta2RpciB9IGZyb20gJ25vZGU6ZnMvcHJvbWlzZXMnO1xuaW1wb3J0IHsgZGlybmFtZSB9IGZyb20gJ25vZGU6cGF0aCc7XG5pbXBvcnQgeyB0bXBkaXIgfSBmcm9tICdub2RlOm9zJztcblxuYXN5bmMgZnVuY3Rpb24gZG93bmxvYWQodXJsLCBvdXRwdXRQYXRoKSB7XG4gICAgY29uc3QgeyBib2R5LCBvaywgc3RhdHVzVGV4dCB9ID0gYXdhaXQgZmV0Y2godXJsKTtcbiAgICBpZiAoIW9rKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCAke3VybH06ICR7c3RhdHVzVGV4dH1gKTtcbiAgICBpZiAoIWJvZHkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCByZXNwb25zZSBib2R5Jyk7XG4gICAgY29uc3QgZGlyID0gZGlybmFtZShvdXRwdXRQYXRoKTtcbiAgICBhd2FpdCBta2RpcihkaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgIGNvbnN0IGZpbGVTdHJlYW0gPSBjcmVhdGVXcml0ZVN0cmVhbShvdXRwdXRQYXRoKTtcbiAgICBjb25zdCByZWFkZXIgPSBib2R5LmdldFJlYWRlcigpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHB1bXAgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICBmaWxlU3RyZWFtLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbGVTdHJlYW0ud3JpdGUoQnVmZmVyLmZyb20odmFsdWUpKTtcbiAgICAgICAgICAgIGF3YWl0IHB1bXAoKTtcbiAgICAgICAgfTtcbiAgICAgICAgYXdhaXQgcHVtcCgpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZmlsZVN0cmVhbS5jbG9zZSgpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBtYXliZURvd25sb2FkKHVybCwgb3V0cHV0UGF0aCkge1xuICAgIGlmICghZXhpc3RzU3luYyhvdXRwdXRQYXRoKSlcbiAgICAgICAgYXdhaXQgZG93bmxvYWQodXJsLCBvdXRwdXRQYXRoKTtcbiAgICByZXR1cm4gb3V0cHV0UGF0aDtcbn1cblxudmFyIFByb2plY3Q7XG4oZnVuY3Rpb24gKFByb2plY3QpIHtcbiAgICBQcm9qZWN0W1wiU0VNQVBIT1JFX0lERU5USVRZXCJdID0gXCJzZW1hcGhvcmUtaWRlbnRpdHlcIjtcbiAgICBQcm9qZWN0W1wiUE9TRUlET05cIl0gPSBcInBvc2VpZG9uXCI7XG4gICAgLy8gUkxOID0gJ3JsbicsXG4gICAgUHJvamVjdFtcIlNFTUFQSE9SRVwiXSA9IFwic2VtYXBob3JlXCI7XG59KShQcm9qZWN0IHx8IChQcm9qZWN0ID0ge30pKTtcbmNvbnN0IHByb2plY3RzID0gT2JqZWN0LnZhbHVlcyhQcm9qZWN0KTtcblxuY29uc3QgQkFTRV9VUkwgPSAnaHR0cHM6Ly9zbmFyay1hcnRpZmFjdHMucHNlLmRldic7XG5jb25zdCBnZXRCYXNlVXJsID0gKHByb2plY3QsIHZlcnNpb24pID0+IGAke0JBU0VfVVJMfS8ke3Byb2plY3R9LyR7dmVyc2lvbn0vJHtwcm9qZWN0fWA7XG5cbmFzeW5jIGZ1bmN0aW9uIG1heWJlR2V0U25hcmtBcnRpZmFjdHMkMShwcm9qZWN0LCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIXByb2plY3RzLmluY2x1ZGVzKHByb2plY3QpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb2plY3QgJyR7cHJvamVjdH0nIGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgICBvcHRpb25zLnZlcnNpb24gPz89ICdsYXRlc3QnO1xuICAgIGNvbnN0IHVybCA9IGdldEJhc2VVcmwocHJvamVjdCwgb3B0aW9ucy52ZXJzaW9uKTtcbiAgICBjb25zdCBwYXJhbWV0ZXJzID0gb3B0aW9ucy5wYXJhbWV0ZXJzXG4gICAgICAgID8gYC0ke29wdGlvbnMucGFyYW1ldGVycy5qb2luKCctJyl9YFxuICAgICAgICA6ICcnO1xuICAgIHJldHVybiB7XG4gICAgICAgIHdhc206IGAke3VybH0ke3BhcmFtZXRlcnN9Lndhc21gLFxuICAgICAgICB6a2V5OiBgJHt1cmx9JHtwYXJhbWV0ZXJzfS56a2V5YCxcbiAgICB9O1xufVxuXG5jb25zdCBleHRyYWN0RW5kUGF0aCA9ICh1cmwpID0+IHVybC5zcGxpdCgncHNlLmRldi8nKVsxXTtcbi8qKlxuICogRG93bmxvYWRzIFNOQVJLIGFydGlmYWN0cyAoYHdhc21gIGFuZCBgemtleWApIGZpbGVzIGlmIG5vdCBhbHJlYWR5IHByZXNlbnQgaW4gT1MgdG1wIGZvbGRlci5cbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICoge1xuICogICB3YXNtOiBcIi90bXAvQHprLWtpdC9zZW1hcGhvcmUtYXJ0aWZhY3RzQGxhdGVzdC9zZW1hcGhvcmUtMy53YXNtXCIsXG4gKiAgIHprZXk6IFwiL3RtcC9Aemsta2l0L3NlbWFwaG9yZS1hcnRpZmFjdHNAbGF0ZXN0L3NlbWFwaG9yZS0zLnprZXlcIiAuXG4gKiB9XG4gKiBgYGBcbiAqIEByZXR1cm5zIHtAbGluayBTbmFya0FydGlmYWN0c31cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbWF5YmVHZXRTbmFya0FydGlmYWN0cyguLi5wYXJzKSB7XG4gICAgY29uc3QgdXJscyA9IGF3YWl0IG1heWJlR2V0U25hcmtBcnRpZmFjdHMkMSguLi5wYXJzKTtcbiAgICBjb25zdCBvdXRwdXRQYXRoID0gYCR7dG1wZGlyKCl9L3NuYXJrLWFydGlmYWN0cy8ke2V4dHJhY3RFbmRQYXRoKHVybHMud2FzbSl9YDtcbiAgICBjb25zdCBbd2FzbSwgemtleV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIG1heWJlRG93bmxvYWQodXJscy53YXNtLCBvdXRwdXRQYXRoKSxcbiAgICAgICAgbWF5YmVEb3dubG9hZCh1cmxzLnprZXksIG91dHB1dFBhdGgucmVwbGFjZSgvLndhc20kLywgJy56a2V5JykpLFxuICAgIF0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHdhc20sXG4gICAgICAgIHprZXksXG4gICAgfTtcbn1cblxuZXhwb3J0IHsgUHJvamVjdCwgZG93bmxvYWQsIG1heWJlRG93bmxvYWQsIG1heWJlR2V0U25hcmtBcnRpZmFjdHMsIHByb2plY3RzIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@zk-kit/artifacts/dist/index.node.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@zk-kit/baby-jubjub/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@zk-kit/baby-jubjub/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Base8: () => (/* binding */ Base8),\n/* harmony export */   Fr: () => (/* binding */ Fr),\n/* harmony export */   addPoint: () => (/* binding */ addPoint),\n/* harmony export */   inCurve: () => (/* binding */ inCurve),\n/* harmony export */   mulPointEscalar: () => (/* binding */ mulPointEscalar),\n/* harmony export */   order: () => (/* binding */ order),\n/* harmony export */   packPoint: () => (/* binding */ packPoint),\n/* harmony export */   r: () => (/* binding */ r),\n/* harmony export */   subOrder: () => (/* binding */ subOrder),\n/* harmony export */   unpackPoint: () => (/* binding */ unpackPoint)\n/* harmony export */ });\n/* harmony import */ var _zk_kit_utils_conversions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zk-kit/utils/conversions */ \"(ssr)/./node_modules/@zk-kit/baby-jubjub/node_modules/@zk-kit/utils/dist/lib.esm/conversions.js\");\n/* harmony import */ var _zk_kit_utils_f1_field__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zk-kit/utils/f1-field */ \"(ssr)/./node_modules/@zk-kit/baby-jubjub/node_modules/@zk-kit/utils/dist/lib.esm/f1-field.js\");\n/* harmony import */ var _zk_kit_utils_scalar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @zk-kit/utils/scalar */ \"(ssr)/./node_modules/@zk-kit/baby-jubjub/node_modules/@zk-kit/utils/dist/lib.esm/scalar.js\");\n/**\n * @module @zk-kit/baby-jubjub\n * @version 1.0.3\n * @file A JavaScript library for adding points to the curve.\n * @copyright Ethereum Foundation 2024\n * @license MIT\n * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/baby-jubjub}\n*/\n\n\n\n\n/**\n * The following is a sqrt function (i.e. tonelliShanks) with some pre-computed\n * constants and it only works with 'r'.\n * See {@link https://eprint.iacr.org/2012/685.pdf} and\n * {@link https://github.com/iden3/ffjavascript/blob/6f37a93fabddf45100bf221de6a1399599497e5d/src/fsqrt.js#L38}\n * for more.\n * @param n The number for which to calculate the square root.\n * @returns The square root.\n */\n// eslint-disable-next-line import/prefer-default-export\nfunction tonelliShanks(n, order) {\n    const Fr = new _zk_kit_utils_f1_field__WEBPACK_IMPORTED_MODULE_1__[\"default\"](order);\n    const sqrt_s = 28;\n    const sqrt_z = BigInt(\"5978345932401256595026418116861078668372907927053715034645334559810731495452\");\n    const sqrt_tm1d2 = BigInt(\"40770029410420498293352137776570907027550720424234931066070132305055\");\n    if (Fr.isZero(n))\n        return Fr.zero;\n    let w = Fr.pow(n, sqrt_tm1d2);\n    const a0 = Fr.pow(Fr.mul(Fr.square(w), n), BigInt(2 ** (sqrt_s - 1)));\n    if (Fr.eq(a0, Fr._negone)) {\n        return null;\n    }\n    let v = sqrt_s;\n    let x = Fr.mul(n, w);\n    let b = Fr.mul(x, w);\n    let z = sqrt_z;\n    while (!Fr.eq(b, Fr.one)) {\n        let b2k = Fr.square(b);\n        let k = 1;\n        while (!Fr.eq(b2k, Fr.one)) {\n            b2k = Fr.square(b2k);\n            k += 1;\n        }\n        w = z;\n        for (let i = 0; i < v - k - 1; i += 1) {\n            w = Fr.square(w);\n        }\n        z = Fr.square(w);\n        b = Fr.mul(b, z);\n        x = Fr.mul(x, w);\n        v = k;\n    }\n    return Fr.geq(x, Fr.zero) ? x : Fr.neg(x);\n}\n\n/**\n * Constants and curve parameters for BabyJubJub elliptic curve operations.\n * See: {@link https://eips.ethereum.org/EIPS/eip-2494}\n */\n// Prime order of the alt_bn128 curve.\nconst r = BigInt(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\");\n// Prime finite field 'F' with r elements (F_r).\nconst Fr = new _zk_kit_utils_f1_field__WEBPACK_IMPORTED_MODULE_1__[\"default\"](r);\n// Base point for generating other points on the Baby Jubjub curve.\nconst Base8 = [\n    Fr.e(BigInt(\"5299619240641551281634865583518297030282874472190772894086521144482721001553\")),\n    Fr.e(BigInt(\"16950150798460657717958625567821834550301663161624707787222815936182638968203\"))\n];\n// Curve parameters from the equation 'ax^2 + y^2 = 1 + dx^2y^2',\n// representing a Twisted Edwards Elliptic Curve E defined over 'F_r'.\nconst a = Fr.e(BigInt(\"168700\"));\nconst d = Fr.e(BigInt(\"168696\"));\n// The Baby JubJub curve 'E(F_r)' is equal to the subgroup of 'F_r'-rational points of 'E'.\nconst order = BigInt(\"21888242871839275222246405745257275088614511777268538073601725287587578984328\");\nconst subOrder = _zk_kit_utils_scalar__WEBPACK_IMPORTED_MODULE_2__.shiftRight(order, BigInt(3));\n/**\n * Performs point addition on the Baby Jubjub elliptic curve,\n * calculating a third point from two given points.\n * Let P1 = (x1, y1) and P2 = (x2, y2) be two arbitrary points of the curve.\n * Then P1 + P2 = (x3, y3) is calculated in the following way:\n * x3 = (x1*y2 + y1*x2)/(1 + d*x1*x2*y1*y2)\n * y3 = (y1*y2 - a*x1*x2)/(1 - d*x1*x2*y1*y2)\n * @param p1 First point on the curve.\n * @param p2 Second point on the curve.\n * @returns Resultant third point on the curve.\n */\nfunction addPoint(p1, p2) {\n    // beta = x1*y2\n    const beta = Fr.mul(p1[0], p2[1]);\n    // gamma = y1*x2\n    const gamma = Fr.mul(p1[1], p2[0]);\n    // delta = (y1-(a*x1))*(x2+y2)\n    const delta = Fr.mul(Fr.sub(p1[1], Fr.mul(a, p1[0])), Fr.add(p2[0], p2[1]));\n    // x1*x2*y1*y2\n    const tau = Fr.mul(beta, gamma);\n    // d*x1*x2*y1*y2\n    const dtau = Fr.mul(d, tau);\n    // x3 = (x1*y2 + y1*x2)/(1 + d*x1*x2*y1*y2)\n    const p3x = Fr.div(Fr.add(beta, gamma), Fr.add(Fr.one, dtau));\n    // y3 = (y1*y2 - a*x1*x2)/(1 - d*x1*x2*y1*y2)\n    const p3y = Fr.div(Fr.add(delta, Fr.sub(Fr.mul(a, beta), gamma)), Fr.sub(Fr.one, dtau));\n    return [p3x, p3y];\n}\n/**\n * Performs a scalar multiplication by starting from the 'base' point and 'adding'\n * it to itself 'e' times.\n * @param base The base point used as a starting point.\n * @param e A secret number representing the private key.\n * @returns The resulting point representing the public key.\n */\nfunction mulPointEscalar(base, e) {\n    let res = [Fr.e(BigInt(0)), Fr.e(BigInt(1))];\n    let rem = e;\n    let exp = base;\n    while (!_zk_kit_utils_scalar__WEBPACK_IMPORTED_MODULE_2__.isZero(rem)) {\n        if (_zk_kit_utils_scalar__WEBPACK_IMPORTED_MODULE_2__.isOdd(rem)) {\n            res = addPoint(res, exp);\n        }\n        exp = addPoint(exp, exp);\n        rem = _zk_kit_utils_scalar__WEBPACK_IMPORTED_MODULE_2__.shiftRight(rem, BigInt(1));\n    }\n    return res;\n}\n/**\n * Determines if a given point lies on the Baby Jubjub elliptic curve by verifying the curve equation.\n * This function checks if the point satisfies the curve equation `ax^2 + y^2 = 1 + dx^2y^2`.\n * @param p The point to check, represented as a pair of bigint values.\n * @returns True if the point is on the curve, otherwise false.\n */\nfunction inCurve(p) {\n    const x1 = BigInt(p[0]);\n    const y1 = BigInt(p[1]);\n    const x2 = Fr.square(x1);\n    const y2 = Fr.square(y1);\n    return Fr.eq(Fr.add(Fr.mul(a, x2), y2), Fr.add(Fr.one, Fr.mul(Fr.mul(x2, y2), d)));\n}\n/**\n * Packs a point on the Baby Jubjub elliptic curve into a bigint.\n * This process involves converting the y-coordinate to a buffer and conditionally modifying the last byte\n * to encode the sign of the x-coordinate, following a specific compact representation format.\n * @param unpackedPoint The point to be packed, consisting of x and y coordinates.\n * @returns The packed representation of the point as a bigint.\n */\nfunction packPoint(unpackedPoint) {\n    const buffer = (0,_zk_kit_utils_conversions__WEBPACK_IMPORTED_MODULE_0__.leBigIntToBuffer)(unpackedPoint[1], 32);\n    if (Fr.lt(unpackedPoint[0], Fr.zero)) {\n        buffer[31] |= 0x80;\n    }\n    return (0,_zk_kit_utils_conversions__WEBPACK_IMPORTED_MODULE_0__.leBufferToBigInt)(buffer);\n}\n/**\n * Unpacks a bigint back into a point on the Baby Jubjub elliptic curve, reversing the packing process.\n * This involves interpreting the bigint as the y-coordinate and extracting the sign of the x-coordinate\n * from the encoded format. The function then calculates the x-coordinate using the curve equation.\n * @param packedPoint The packed point as a bigint.\n * @returns The unpacked point as a pair of bigint values, or null if the point is invalid.\n */\nfunction unpackPoint(packedPoint) {\n    const buffer = (0,_zk_kit_utils_conversions__WEBPACK_IMPORTED_MODULE_0__.leBigIntToBuffer)(packedPoint);\n    const unpackedPoint = new Array(2);\n    let sign = false;\n    if (buffer[31] & 0x80) {\n        sign = true;\n        buffer[31] &= 0x7f;\n    }\n    unpackedPoint[1] = (0,_zk_kit_utils_conversions__WEBPACK_IMPORTED_MODULE_0__.leBufferToBigInt)(buffer);\n    if (_zk_kit_utils_scalar__WEBPACK_IMPORTED_MODULE_2__.gt(unpackedPoint[1], r)) {\n        return null;\n    }\n    const y2 = Fr.square(unpackedPoint[1]);\n    let x = tonelliShanks(Fr.div(Fr.sub(Fr.one, y2), Fr.sub(a, Fr.mul(d, y2))), r);\n    if (x == null) {\n        return null;\n    }\n    if (sign) {\n        x = Fr.neg(x);\n    }\n    unpackedPoint[0] = x;\n    return unpackedPoint;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHprLWtpdC9iYWJ5LWp1Ymp1Yi9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDK0U7QUFDbEM7QUFDRTs7QUFFL0M7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0Q0FBNEM7QUFDcEQsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4REFBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4REFBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDREQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdEQUFhO0FBQ3pCLFlBQVksdURBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsY0FBYyw0REFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJFQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQSxXQUFXLDJFQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkVBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwyRUFBZ0I7QUFDdkMsUUFBUSxvREFBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFcUciLCJzb3VyY2VzIjpbIi9Vc2Vycy9jaGFuY2VtY2FsbGlzdGVyL1Byb2plY3RzL3p1cGFzc2h1bnQvbm9kZV9tb2R1bGVzL0B6ay1raXQvYmFieS1qdWJqdWIvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgQHprLWtpdC9iYWJ5LWp1Ymp1YlxuICogQHZlcnNpb24gMS4wLjNcbiAqIEBmaWxlIEEgSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBhZGRpbmcgcG9pbnRzIHRvIHRoZSBjdXJ2ZS5cbiAqIEBjb3B5cmlnaHQgRXRoZXJldW0gRm91bmRhdGlvbiAyMDI0XG4gKiBAbGljZW5zZSBNSVRcbiAqIEBzZWUgW0dpdGh1Yl17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3ByaXZhY3ktc2NhbGluZy1leHBsb3JhdGlvbnMvemsta2l0L3RyZWUvbWFpbi9wYWNrYWdlcy9iYWJ5LWp1Ymp1Yn1cbiovXG5pbXBvcnQgeyBsZUJpZ0ludFRvQnVmZmVyLCBsZUJ1ZmZlclRvQmlnSW50IH0gZnJvbSAnQHprLWtpdC91dGlscy9jb252ZXJzaW9ucyc7XG5pbXBvcnQgRjFGaWVsZCBmcm9tICdAemsta2l0L3V0aWxzL2YxLWZpZWxkJztcbmltcG9ydCAqIGFzIHNjYWxhciBmcm9tICdAemsta2l0L3V0aWxzL3NjYWxhcic7XG5cbi8qKlxuICogVGhlIGZvbGxvd2luZyBpcyBhIHNxcnQgZnVuY3Rpb24gKGkuZS4gdG9uZWxsaVNoYW5rcykgd2l0aCBzb21lIHByZS1jb21wdXRlZFxuICogY29uc3RhbnRzIGFuZCBpdCBvbmx5IHdvcmtzIHdpdGggJ3InLlxuICogU2VlIHtAbGluayBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGZ9IGFuZFxuICoge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pZGVuMy9mZmphdmFzY3JpcHQvYmxvYi82ZjM3YTkzZmFiZGRmNDUxMDBiZjIyMWRlNmExMzk5NTk5NDk3ZTVkL3NyYy9mc3FydC5qcyNMMzh9XG4gKiBmb3IgbW9yZS5cbiAqIEBwYXJhbSBuIFRoZSBudW1iZXIgZm9yIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgc3F1YXJlIHJvb3QuXG4gKiBAcmV0dXJucyBUaGUgc3F1YXJlIHJvb3QuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvcHJlZmVyLWRlZmF1bHQtZXhwb3J0XG5mdW5jdGlvbiB0b25lbGxpU2hhbmtzKG4sIG9yZGVyKSB7XG4gICAgY29uc3QgRnIgPSBuZXcgRjFGaWVsZChvcmRlcik7XG4gICAgY29uc3Qgc3FydF9zID0gMjg7XG4gICAgY29uc3Qgc3FydF96ID0gQmlnSW50KFwiNTk3ODM0NTkzMjQwMTI1NjU5NTAyNjQxODExNjg2MTA3ODY2ODM3MjkwNzkyNzA1MzcxNTAzNDY0NTMzNDU1OTgxMDczMTQ5NTQ1MlwiKTtcbiAgICBjb25zdCBzcXJ0X3RtMWQyID0gQmlnSW50KFwiNDA3NzAwMjk0MTA0MjA0OTgyOTMzNTIxMzc3NzY1NzA5MDcwMjc1NTA3MjA0MjQyMzQ5MzEwNjYwNzAxMzIzMDUwNTVcIik7XG4gICAgaWYgKEZyLmlzWmVybyhuKSlcbiAgICAgICAgcmV0dXJuIEZyLnplcm87XG4gICAgbGV0IHcgPSBGci5wb3cobiwgc3FydF90bTFkMik7XG4gICAgY29uc3QgYTAgPSBGci5wb3coRnIubXVsKEZyLnNxdWFyZSh3KSwgbiksIEJpZ0ludCgyICoqIChzcXJ0X3MgLSAxKSkpO1xuICAgIGlmIChGci5lcShhMCwgRnIuX25lZ29uZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCB2ID0gc3FydF9zO1xuICAgIGxldCB4ID0gRnIubXVsKG4sIHcpO1xuICAgIGxldCBiID0gRnIubXVsKHgsIHcpO1xuICAgIGxldCB6ID0gc3FydF96O1xuICAgIHdoaWxlICghRnIuZXEoYiwgRnIub25lKSkge1xuICAgICAgICBsZXQgYjJrID0gRnIuc3F1YXJlKGIpO1xuICAgICAgICBsZXQgayA9IDE7XG4gICAgICAgIHdoaWxlICghRnIuZXEoYjJrLCBGci5vbmUpKSB7XG4gICAgICAgICAgICBiMmsgPSBGci5zcXVhcmUoYjJrKTtcbiAgICAgICAgICAgIGsgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICB3ID0gejtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2IC0gayAtIDE7IGkgKz0gMSkge1xuICAgICAgICAgICAgdyA9IEZyLnNxdWFyZSh3KTtcbiAgICAgICAgfVxuICAgICAgICB6ID0gRnIuc3F1YXJlKHcpO1xuICAgICAgICBiID0gRnIubXVsKGIsIHopO1xuICAgICAgICB4ID0gRnIubXVsKHgsIHcpO1xuICAgICAgICB2ID0gaztcbiAgICB9XG4gICAgcmV0dXJuIEZyLmdlcSh4LCBGci56ZXJvKSA/IHggOiBGci5uZWcoeCk7XG59XG5cbi8qKlxuICogQ29uc3RhbnRzIGFuZCBjdXJ2ZSBwYXJhbWV0ZXJzIGZvciBCYWJ5SnViSnViIGVsbGlwdGljIGN1cnZlIG9wZXJhdGlvbnMuXG4gKiBTZWU6IHtAbGluayBodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTI0OTR9XG4gKi9cbi8vIFByaW1lIG9yZGVyIG9mIHRoZSBhbHRfYm4xMjggY3VydmUuXG5jb25zdCByID0gQmlnSW50KFwiMjE4ODgyNDI4NzE4MzkyNzUyMjIyNDY0MDU3NDUyNTcyNzUwODg1NDgzNjQ0MDA0MTYwMzQzNDM2OTgyMDQxODY1NzU4MDg0OTU2MTdcIik7XG4vLyBQcmltZSBmaW5pdGUgZmllbGQgJ0YnIHdpdGggciBlbGVtZW50cyAoRl9yKS5cbmNvbnN0IEZyID0gbmV3IEYxRmllbGQocik7XG4vLyBCYXNlIHBvaW50IGZvciBnZW5lcmF0aW5nIG90aGVyIHBvaW50cyBvbiB0aGUgQmFieSBKdWJqdWIgY3VydmUuXG5jb25zdCBCYXNlOCA9IFtcbiAgICBGci5lKEJpZ0ludChcIjUyOTk2MTkyNDA2NDE1NTEyODE2MzQ4NjU1ODM1MTgyOTcwMzAyODI4NzQ0NzIxOTA3NzI4OTQwODY1MjExNDQ0ODI3MjEwMDE1NTNcIikpLFxuICAgIEZyLmUoQmlnSW50KFwiMTY5NTAxNTA3OTg0NjA2NTc3MTc5NTg2MjU1Njc4MjE4MzQ1NTAzMDE2NjMxNjE2MjQ3MDc3ODcyMjI4MTU5MzYxODI2Mzg5NjgyMDNcIikpXG5dO1xuLy8gQ3VydmUgcGFyYW1ldGVycyBmcm9tIHRoZSBlcXVhdGlvbiAnYXheMiArIHleMiA9IDEgKyBkeF4yeV4yJyxcbi8vIHJlcHJlc2VudGluZyBhIFR3aXN0ZWQgRWR3YXJkcyBFbGxpcHRpYyBDdXJ2ZSBFIGRlZmluZWQgb3ZlciAnRl9yJy5cbmNvbnN0IGEgPSBGci5lKEJpZ0ludChcIjE2ODcwMFwiKSk7XG5jb25zdCBkID0gRnIuZShCaWdJbnQoXCIxNjg2OTZcIikpO1xuLy8gVGhlIEJhYnkgSnViSnViIGN1cnZlICdFKEZfciknIGlzIGVxdWFsIHRvIHRoZSBzdWJncm91cCBvZiAnRl9yJy1yYXRpb25hbCBwb2ludHMgb2YgJ0UnLlxuY29uc3Qgb3JkZXIgPSBCaWdJbnQoXCIyMTg4ODI0Mjg3MTgzOTI3NTIyMjI0NjQwNTc0NTI1NzI3NTA4ODYxNDUxMTc3NzI2ODUzODA3MzYwMTcyNTI4NzU4NzU3ODk4NDMyOFwiKTtcbmNvbnN0IHN1Yk9yZGVyID0gc2NhbGFyLnNoaWZ0UmlnaHQob3JkZXIsIEJpZ0ludCgzKSk7XG4vKipcbiAqIFBlcmZvcm1zIHBvaW50IGFkZGl0aW9uIG9uIHRoZSBCYWJ5IEp1Ymp1YiBlbGxpcHRpYyBjdXJ2ZSxcbiAqIGNhbGN1bGF0aW5nIGEgdGhpcmQgcG9pbnQgZnJvbSB0d28gZ2l2ZW4gcG9pbnRzLlxuICogTGV0IFAxID0gKHgxLCB5MSkgYW5kIFAyID0gKHgyLCB5MikgYmUgdHdvIGFyYml0cmFyeSBwb2ludHMgb2YgdGhlIGN1cnZlLlxuICogVGhlbiBQMSArIFAyID0gKHgzLCB5MykgaXMgY2FsY3VsYXRlZCBpbiB0aGUgZm9sbG93aW5nIHdheTpcbiAqIHgzID0gKHgxKnkyICsgeTEqeDIpLygxICsgZCp4MSp4Mip5MSp5MilcbiAqIHkzID0gKHkxKnkyIC0gYSp4MSp4MikvKDEgLSBkKngxKngyKnkxKnkyKVxuICogQHBhcmFtIHAxIEZpcnN0IHBvaW50IG9uIHRoZSBjdXJ2ZS5cbiAqIEBwYXJhbSBwMiBTZWNvbmQgcG9pbnQgb24gdGhlIGN1cnZlLlxuICogQHJldHVybnMgUmVzdWx0YW50IHRoaXJkIHBvaW50IG9uIHRoZSBjdXJ2ZS5cbiAqL1xuZnVuY3Rpb24gYWRkUG9pbnQocDEsIHAyKSB7XG4gICAgLy8gYmV0YSA9IHgxKnkyXG4gICAgY29uc3QgYmV0YSA9IEZyLm11bChwMVswXSwgcDJbMV0pO1xuICAgIC8vIGdhbW1hID0geTEqeDJcbiAgICBjb25zdCBnYW1tYSA9IEZyLm11bChwMVsxXSwgcDJbMF0pO1xuICAgIC8vIGRlbHRhID0gKHkxLShhKngxKSkqKHgyK3kyKVxuICAgIGNvbnN0IGRlbHRhID0gRnIubXVsKEZyLnN1YihwMVsxXSwgRnIubXVsKGEsIHAxWzBdKSksIEZyLmFkZChwMlswXSwgcDJbMV0pKTtcbiAgICAvLyB4MSp4Mip5MSp5MlxuICAgIGNvbnN0IHRhdSA9IEZyLm11bChiZXRhLCBnYW1tYSk7XG4gICAgLy8gZCp4MSp4Mip5MSp5MlxuICAgIGNvbnN0IGR0YXUgPSBGci5tdWwoZCwgdGF1KTtcbiAgICAvLyB4MyA9ICh4MSp5MiArIHkxKngyKS8oMSArIGQqeDEqeDIqeTEqeTIpXG4gICAgY29uc3QgcDN4ID0gRnIuZGl2KEZyLmFkZChiZXRhLCBnYW1tYSksIEZyLmFkZChGci5vbmUsIGR0YXUpKTtcbiAgICAvLyB5MyA9ICh5MSp5MiAtIGEqeDEqeDIpLygxIC0gZCp4MSp4Mip5MSp5MilcbiAgICBjb25zdCBwM3kgPSBGci5kaXYoRnIuYWRkKGRlbHRhLCBGci5zdWIoRnIubXVsKGEsIGJldGEpLCBnYW1tYSkpLCBGci5zdWIoRnIub25lLCBkdGF1KSk7XG4gICAgcmV0dXJuIFtwM3gsIHAzeV07XG59XG4vKipcbiAqIFBlcmZvcm1zIGEgc2NhbGFyIG11bHRpcGxpY2F0aW9uIGJ5IHN0YXJ0aW5nIGZyb20gdGhlICdiYXNlJyBwb2ludCBhbmQgJ2FkZGluZydcbiAqIGl0IHRvIGl0c2VsZiAnZScgdGltZXMuXG4gKiBAcGFyYW0gYmFzZSBUaGUgYmFzZSBwb2ludCB1c2VkIGFzIGEgc3RhcnRpbmcgcG9pbnQuXG4gKiBAcGFyYW0gZSBBIHNlY3JldCBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBwcml2YXRlIGtleS5cbiAqIEByZXR1cm5zIFRoZSByZXN1bHRpbmcgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBwdWJsaWMga2V5LlxuICovXG5mdW5jdGlvbiBtdWxQb2ludEVzY2FsYXIoYmFzZSwgZSkge1xuICAgIGxldCByZXMgPSBbRnIuZShCaWdJbnQoMCkpLCBGci5lKEJpZ0ludCgxKSldO1xuICAgIGxldCByZW0gPSBlO1xuICAgIGxldCBleHAgPSBiYXNlO1xuICAgIHdoaWxlICghc2NhbGFyLmlzWmVybyhyZW0pKSB7XG4gICAgICAgIGlmIChzY2FsYXIuaXNPZGQocmVtKSkge1xuICAgICAgICAgICAgcmVzID0gYWRkUG9pbnQocmVzLCBleHApO1xuICAgICAgICB9XG4gICAgICAgIGV4cCA9IGFkZFBvaW50KGV4cCwgZXhwKTtcbiAgICAgICAgcmVtID0gc2NhbGFyLnNoaWZ0UmlnaHQocmVtLCBCaWdJbnQoMSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gcG9pbnQgbGllcyBvbiB0aGUgQmFieSBKdWJqdWIgZWxsaXB0aWMgY3VydmUgYnkgdmVyaWZ5aW5nIHRoZSBjdXJ2ZSBlcXVhdGlvbi5cbiAqIFRoaXMgZnVuY3Rpb24gY2hlY2tzIGlmIHRoZSBwb2ludCBzYXRpc2ZpZXMgdGhlIGN1cnZlIGVxdWF0aW9uIGBheF4yICsgeV4yID0gMSArIGR4XjJ5XjJgLlxuICogQHBhcmFtIHAgVGhlIHBvaW50IHRvIGNoZWNrLCByZXByZXNlbnRlZCBhcyBhIHBhaXIgb2YgYmlnaW50IHZhbHVlcy5cbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHBvaW50IGlzIG9uIHRoZSBjdXJ2ZSwgb3RoZXJ3aXNlIGZhbHNlLlxuICovXG5mdW5jdGlvbiBpbkN1cnZlKHApIHtcbiAgICBjb25zdCB4MSA9IEJpZ0ludChwWzBdKTtcbiAgICBjb25zdCB5MSA9IEJpZ0ludChwWzFdKTtcbiAgICBjb25zdCB4MiA9IEZyLnNxdWFyZSh4MSk7XG4gICAgY29uc3QgeTIgPSBGci5zcXVhcmUoeTEpO1xuICAgIHJldHVybiBGci5lcShGci5hZGQoRnIubXVsKGEsIHgyKSwgeTIpLCBGci5hZGQoRnIub25lLCBGci5tdWwoRnIubXVsKHgyLCB5MiksIGQpKSk7XG59XG4vKipcbiAqIFBhY2tzIGEgcG9pbnQgb24gdGhlIEJhYnkgSnVianViIGVsbGlwdGljIGN1cnZlIGludG8gYSBiaWdpbnQuXG4gKiBUaGlzIHByb2Nlc3MgaW52b2x2ZXMgY29udmVydGluZyB0aGUgeS1jb29yZGluYXRlIHRvIGEgYnVmZmVyIGFuZCBjb25kaXRpb25hbGx5IG1vZGlmeWluZyB0aGUgbGFzdCBieXRlXG4gKiB0byBlbmNvZGUgdGhlIHNpZ24gb2YgdGhlIHgtY29vcmRpbmF0ZSwgZm9sbG93aW5nIGEgc3BlY2lmaWMgY29tcGFjdCByZXByZXNlbnRhdGlvbiBmb3JtYXQuXG4gKiBAcGFyYW0gdW5wYWNrZWRQb2ludCBUaGUgcG9pbnQgdG8gYmUgcGFja2VkLCBjb25zaXN0aW5nIG9mIHggYW5kIHkgY29vcmRpbmF0ZXMuXG4gKiBAcmV0dXJucyBUaGUgcGFja2VkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2ludCBhcyBhIGJpZ2ludC5cbiAqL1xuZnVuY3Rpb24gcGFja1BvaW50KHVucGFja2VkUG9pbnQpIHtcbiAgICBjb25zdCBidWZmZXIgPSBsZUJpZ0ludFRvQnVmZmVyKHVucGFja2VkUG9pbnRbMV0sIDMyKTtcbiAgICBpZiAoRnIubHQodW5wYWNrZWRQb2ludFswXSwgRnIuemVybykpIHtcbiAgICAgICAgYnVmZmVyWzMxXSB8PSAweDgwO1xuICAgIH1cbiAgICByZXR1cm4gbGVCdWZmZXJUb0JpZ0ludChidWZmZXIpO1xufVxuLyoqXG4gKiBVbnBhY2tzIGEgYmlnaW50IGJhY2sgaW50byBhIHBvaW50IG9uIHRoZSBCYWJ5IEp1Ymp1YiBlbGxpcHRpYyBjdXJ2ZSwgcmV2ZXJzaW5nIHRoZSBwYWNraW5nIHByb2Nlc3MuXG4gKiBUaGlzIGludm9sdmVzIGludGVycHJldGluZyB0aGUgYmlnaW50IGFzIHRoZSB5LWNvb3JkaW5hdGUgYW5kIGV4dHJhY3RpbmcgdGhlIHNpZ24gb2YgdGhlIHgtY29vcmRpbmF0ZVxuICogZnJvbSB0aGUgZW5jb2RlZCBmb3JtYXQuIFRoZSBmdW5jdGlvbiB0aGVuIGNhbGN1bGF0ZXMgdGhlIHgtY29vcmRpbmF0ZSB1c2luZyB0aGUgY3VydmUgZXF1YXRpb24uXG4gKiBAcGFyYW0gcGFja2VkUG9pbnQgVGhlIHBhY2tlZCBwb2ludCBhcyBhIGJpZ2ludC5cbiAqIEByZXR1cm5zIFRoZSB1bnBhY2tlZCBwb2ludCBhcyBhIHBhaXIgb2YgYmlnaW50IHZhbHVlcywgb3IgbnVsbCBpZiB0aGUgcG9pbnQgaXMgaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gdW5wYWNrUG9pbnQocGFja2VkUG9pbnQpIHtcbiAgICBjb25zdCBidWZmZXIgPSBsZUJpZ0ludFRvQnVmZmVyKHBhY2tlZFBvaW50KTtcbiAgICBjb25zdCB1bnBhY2tlZFBvaW50ID0gbmV3IEFycmF5KDIpO1xuICAgIGxldCBzaWduID0gZmFsc2U7XG4gICAgaWYgKGJ1ZmZlclszMV0gJiAweDgwKSB7XG4gICAgICAgIHNpZ24gPSB0cnVlO1xuICAgICAgICBidWZmZXJbMzFdICY9IDB4N2Y7XG4gICAgfVxuICAgIHVucGFja2VkUG9pbnRbMV0gPSBsZUJ1ZmZlclRvQmlnSW50KGJ1ZmZlcik7XG4gICAgaWYgKHNjYWxhci5ndCh1bnBhY2tlZFBvaW50WzFdLCByKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgeTIgPSBGci5zcXVhcmUodW5wYWNrZWRQb2ludFsxXSk7XG4gICAgbGV0IHggPSB0b25lbGxpU2hhbmtzKEZyLmRpdihGci5zdWIoRnIub25lLCB5MiksIEZyLnN1YihhLCBGci5tdWwoZCwgeTIpKSksIHIpO1xuICAgIGlmICh4ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChzaWduKSB7XG4gICAgICAgIHggPSBGci5uZWcoeCk7XG4gICAgfVxuICAgIHVucGFja2VkUG9pbnRbMF0gPSB4O1xuICAgIHJldHVybiB1bnBhY2tlZFBvaW50O1xufVxuXG5leHBvcnQgeyBCYXNlOCwgRnIsIGFkZFBvaW50LCBpbkN1cnZlLCBtdWxQb2ludEVzY2FsYXIsIG9yZGVyLCBwYWNrUG9pbnQsIHIsIHN1Yk9yZGVyLCB1bnBhY2tQb2ludCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@zk-kit/baby-jubjub/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@zk-kit/baby-jubjub/node_modules/@zk-kit/utils/dist/lib.esm/conversions.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@zk-kit/baby-jubjub/node_modules/@zk-kit/utils/dist/lib.esm/conversions.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base64ToBuffer: () => (/* binding */ base64ToBuffer),\n/* harmony export */   base64ToText: () => (/* binding */ base64ToText),\n/* harmony export */   beBigIntToBuffer: () => (/* binding */ beBigIntToBuffer),\n/* harmony export */   beBufferToBigInt: () => (/* binding */ beBufferToBigInt),\n/* harmony export */   bigIntToBuffer: () => (/* binding */ bigIntToBuffer),\n/* harmony export */   bigIntToHexadecimal: () => (/* binding */ bigIntToHexadecimal),\n/* harmony export */   bigNumberishToBigInt: () => (/* binding */ bigNumberishToBigInt),\n/* harmony export */   bigNumberishToBuffer: () => (/* binding */ bigNumberishToBuffer),\n/* harmony export */   bufferToBase64: () => (/* binding */ bufferToBase64),\n/* harmony export */   bufferToBigInt: () => (/* binding */ bufferToBigInt),\n/* harmony export */   bufferToHexadecimal: () => (/* binding */ bufferToHexadecimal),\n/* harmony export */   hexadecimalToBigInt: () => (/* binding */ hexadecimalToBigInt),\n/* harmony export */   hexadecimalToBuffer: () => (/* binding */ hexadecimalToBuffer),\n/* harmony export */   leBigIntToBuffer: () => (/* binding */ leBigIntToBuffer),\n/* harmony export */   leBufferToBigInt: () => (/* binding */ leBufferToBigInt),\n/* harmony export */   textToBase64: () => (/* binding */ textToBase64)\n/* harmony export */ });\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var _error_handlers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./error-handlers.js */ \"(ssr)/./node_modules/@zk-kit/baby-jubjub/node_modules/@zk-kit/utils/dist/lib.esm/error-handlers.js\");\n/* harmony import */ var _type_checks_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./type-checks.js */ \"(ssr)/./node_modules/@zk-kit/baby-jubjub/node_modules/@zk-kit/utils/dist/lib.esm/type-checks.js\");\n/**\n * @module @zk-kit/utils\n * @version 1.2.1\n * @file Essential zero-knowledge utility library for JavaScript developers.\n * @copyright Ethereum Foundation 2024\n * @license MIT\n * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/utils}\n*/\n\n\n\n\n/**\n * @module Conversions\n * This module provides a collection of utility functions for converting\n * between different numerical formats, particularly focusing on\n * conversions involving bigints, hexadecimals and buffers.\n * The module is structured with clear function naming to indicate\n * the conversion direction (e.g., `bigIntToHexadecimal` for BigInt\n * to hexadecimal, `bufferToBigInt` for buffer to bigint) and employs\n * type checks to ensure the correct handling of various input types.\n * It also includes variations for both big-endian (`be`) and little-endian\n * (`le`) conversions. It is important to note that when there is no prefix,\n * the order of bytes is always big-endian.\n */\n/**\n * Converts a bigint to a hexadecimal string.\n * @param value The bigint value to convert.\n * @returns The hexadecimal representation of the bigint.\n */\nfunction bigIntToHexadecimal(value) {\n    (0,_error_handlers_js__WEBPACK_IMPORTED_MODULE_1__.requireBigInt)(value, \"value\");\n    let hex = value.toString(16);\n    // Ensure even length.\n    if (hex.length % 2 !== 0) {\n        hex = `0${hex}`;\n    }\n    return hex;\n}\n/**\n * Converts a hexadecimal string to a bigint. The input is interpreted as hexadecimal\n * with or without a '0x' prefix. It uses big-endian byte order.\n * @param value The hexadecimal string to convert.\n * @returns The bigint representation of the hexadecimal string.\n */\nfunction hexadecimalToBigInt(value) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_2__.isHexadecimal)(value) && !(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_2__.isHexadecimal)(value, false)) {\n        throw new TypeError(`Parameter 'value' is not a hexadecimal string`);\n    }\n    // Ensure the hex string starts with '0x'.\n    const formattedHexString = value.startsWith(\"0x\") ? value : `0x${value}`;\n    return BigInt(formattedHexString);\n}\n/**\n * Converts a buffer of bytes to a bigint using big-endian byte order.\n * It accepts 'Buffer' or 'Uint8Array'.\n * @param value The buffer to convert.\n * @returns The bigint representation of the buffer's contents.\n */\nfunction beBufferToBigInt(value) {\n    (0,_error_handlers_js__WEBPACK_IMPORTED_MODULE_1__.requireTypes)(value, \"value\", [\"Buffer\", \"Uint8Array\"]);\n    return BigInt(`0x${buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value).toString(\"hex\")}`);\n}\n/**\n * Converts a buffer to a bigint using little-endian byte order.\n * It accepts 'Buffer' or 'Uint8Array'.\n * @param value The buffer to convert.\n * @returns The bigint representation of the buffer's contents in little-endian.\n */\nfunction leBufferToBigInt(value) {\n    (0,_error_handlers_js__WEBPACK_IMPORTED_MODULE_1__.requireTypes)(value, \"value\", [\"Buffer\", \"Uint8Array\"]);\n    return BigInt(`0x${buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value).reverse().toString(\"hex\")}`);\n}\n/**\n * Converts a buffer to a bigint. Alias for beBufferToBigInt.\n * @param value The buffer to convert.\n * @returns The bigint representation of the buffer's contents.\n */\nfunction bufferToBigInt(value) {\n    return beBufferToBigInt(value);\n}\n/**\n * Converts a bigint to a buffer and fills with zeros if a valid\n * size (i.e. number of bytes) is specified. If the size is not defined,\n * it gets the size from the given bigint. If the specified size is smaller than\n * the size of the bigint (i.e. `minSize`), an error is thrown.\n * It uses big-endian byte order.\n * @param value The bigint to convert.\n * @param size The number of bytes of the buffer to return.\n * @returns The buffer representation of the bigint.\n */\nfunction beBigIntToBuffer(value, size) {\n    const hex = bigIntToHexadecimal(value);\n    // Calculate the minimum buffer size required to represent 'n' in bytes.\n    // Each hexadecimal character represents 4 bits, so 2 characters are 1 byte.\n    const minSize = Math.ceil(hex.length / 2);\n    if (!size) {\n        size = minSize;\n    }\n    else if (size < minSize) {\n        throw Error(`Size ${size} is too small, need at least ${minSize} bytes`);\n    }\n    // Allocate buffer of the desired size, filled with zeros.\n    const buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(size, 0);\n    const fromHex = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(hex, \"hex\");\n    fromHex.copy(buffer, size - fromHex.length);\n    return buffer;\n}\n/**\n * Converts a bigint to a buffer and fills with zeros if a valid\n * size (i.e. number of bytes) is specified. If the size is not defined,\n * it gets the size from the given bigint. If the specified size is smaller than\n * the size of the bigint (i.e. `minSize`), an error is thrown.\n * It uses little-endian byte order.\n * @param value The bigint to convert.\n * @param size The number of bytes of the buffer to return.\n * @returns The buffer representation of the bigint in little-endian.\n */\nfunction leBigIntToBuffer(value, size) {\n    const hex = bigIntToHexadecimal(value);\n    // Calculate the minimum buffer size required to represent 'n' in bytes.\n    // Each hexadecimal character represents 4 bits, so 2 characters are 1 byte.\n    const minSize = Math.ceil(hex.length / 2);\n    if (!size) {\n        size = minSize;\n    }\n    else if (size < minSize) {\n        throw Error(`Size ${size} is too small, need at least ${minSize} bytes`);\n    }\n    // Allocate buffer of the desired size, filled with zeros.\n    const buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(size, 0);\n    const fromHex = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(hex, \"hex\").reverse();\n    fromHex.copy(buffer, 0);\n    return buffer;\n}\n/**\n * Converts a bigint to a buffer. Alias for beBigIntToBuffer.\n * @param value The bigint to convert.\n * @returns The buffer representation of the bigint.\n */\nfunction bigIntToBuffer(value) {\n    return beBigIntToBuffer(value);\n}\n/**\n * Converts a BigNumberish type to a bigint. If the input is already a bigint,\n * the return value will be the bigint itself, otherwise it will be converted\n * to a bigint using big-endian byte order.\n * @param value The BigNumberish value to convert.\n * @returns The bigint representation of the BigNumberish value.\n */\nfunction bigNumberishToBigInt(value) {\n    (0,_error_handlers_js__WEBPACK_IMPORTED_MODULE_1__.requireBigNumberish)(value, \"value\");\n    if ((0,_type_checks_js__WEBPACK_IMPORTED_MODULE_2__.isBuffer)(value) || (0,_type_checks_js__WEBPACK_IMPORTED_MODULE_2__.isUint8Array)(value)) {\n        return bufferToBigInt(value);\n    }\n    return BigInt(value);\n}\n/**\n * Converts a BigNumberish type to a buffer. If the input is already a buffer,\n * the return value will be the buffer itself, otherwise it will be converted\n * to a buffer using big-endian byte order.\n * @param value The BigNumberish value to convert.\n * @returns The buffer representation of the BigNumberish value.\n */\nfunction bigNumberishToBuffer(value) {\n    (0,_error_handlers_js__WEBPACK_IMPORTED_MODULE_1__.requireBigNumberish)(value, \"value\");\n    if ((0,_type_checks_js__WEBPACK_IMPORTED_MODULE_2__.isBuffer)(value) || (0,_type_checks_js__WEBPACK_IMPORTED_MODULE_2__.isUint8Array)(value)) {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value);\n    }\n    return bigIntToBuffer(bigNumberishToBigInt(value));\n}\n/**\n * Converts an hexadecimal string to a buffer. The hexadecimal string\n * should not start with '0x' or '0X'. It keeps the bytes in the same order.\n * @param value The hexadecimal string to convert.\n * @returns The buffer representation of the hexadecimal string.\n */\nfunction hexadecimalToBuffer(value) {\n    (0,_error_handlers_js__WEBPACK_IMPORTED_MODULE_1__.requireHexadecimal)(value, \"value\", false);\n    // Ensure even length before converting to buffer.\n    if (value.length % 2 !== 0) {\n        value = `0${value}`;\n    }\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value, \"hex\");\n}\n/**\n * Converts a buffer to a hexadecimal string. It accepts 'Buffer' or 'Uint8Array'.\n * The hexadecimal string will not start with '0x' or '0X'. It keeps the bytes in the same order.\n * @param value The buffer to convert.\n * @returns The converted hexadecimal string.\n */\nfunction bufferToHexadecimal(value) {\n    (0,_error_handlers_js__WEBPACK_IMPORTED_MODULE_1__.requireTypes)(value, \"value\", [\"Buffer\", \"Uint8Array\"]);\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value).toString(\"hex\");\n}\n/**\n * Converts bytes to a base64 string. It accepts 'Buffer' or 'Uint8Array'.\n * @param value The bytes to convert.\n * @returns The converted base64 string.\n */\nfunction bufferToBase64(value) {\n    (0,_error_handlers_js__WEBPACK_IMPORTED_MODULE_1__.requireTypes)(value, \"value\", [\"Buffer\", \"Uint8Array\"]);\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value).toString(\"base64\");\n}\n/**\n * Converts a base64 string to bytes (i.e. a buffer). This function does not check\n * if the input value is a valid base64 string. If there are unsupported characters\n * they will be ignored.\n * @param value The base64 string to convert.\n * @returns The converted buffer.\n */\nfunction base64ToBuffer(value) {\n    (0,_error_handlers_js__WEBPACK_IMPORTED_MODULE_1__.requireString)(value, \"value\");\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value, \"base64\");\n}\n/**\n * Converts text (utf8) to a base64 string.\n * @param value The text to convert.\n * @returns The converted base64 string.\n */\nfunction textToBase64(value) {\n    (0,_error_handlers_js__WEBPACK_IMPORTED_MODULE_1__.requireString)(value, \"value\");\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value, \"utf8\").toString(\"base64\");\n}\n/**\n * Converts a base64 string to text (utf8). This function does not check\n * if the input value is a valid base64 string. If there are unsupported characters\n * they could be ignored and the result may be unexpected.\n * @param value The base64 string to convert.\n * @returns The converted text.\n */\nfunction base64ToText(value) {\n    (0,_error_handlers_js__WEBPACK_IMPORTED_MODULE_1__.requireString)(value, \"value\");\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value, \"base64\").toString(\"utf8\");\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHprLWtpdC9iYWJ5LWp1Ymp1Yi9ub2RlX21vZHVsZXMvQHprLWtpdC91dGlscy9kaXN0L2xpYi5lc20vY29udmVyc2lvbnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNnQztBQUMwRjtBQUNqRDs7QUFFekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlFQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixJQUFJO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4REFBYSxZQUFZLDhEQUFhO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxNQUFNO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0VBQVk7QUFDaEIsdUJBQXVCLDBDQUFNLDZCQUE2QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnRUFBWTtBQUNoQix1QkFBdUIsMENBQU0sdUNBQXVDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU0sOEJBQThCLFNBQVM7QUFDekU7QUFDQTtBQUNBLG1CQUFtQiwwQ0FBTTtBQUN6QixvQkFBb0IsMENBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTSw4QkFBOEIsU0FBUztBQUN6RTtBQUNBO0FBQ0EsbUJBQW1CLDBDQUFNO0FBQ3pCLG9CQUFvQiwwQ0FBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksdUVBQW1CO0FBQ3ZCLFFBQVEseURBQVEsV0FBVyw2REFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVFQUFtQjtBQUN2QixRQUFRLHlEQUFRLFdBQVcsNkRBQVk7QUFDdkMsZUFBZSwwQ0FBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksc0VBQWtCO0FBQ3RCO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBLFdBQVcsMENBQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0VBQVk7QUFDaEIsV0FBVywwQ0FBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0VBQVk7QUFDaEIsV0FBVywwQ0FBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlFQUFhO0FBQ2pCLFdBQVcsMENBQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlFQUFhO0FBQ2pCLFdBQVcsMENBQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpRUFBYTtBQUNqQixXQUFXLDBDQUFNO0FBQ2pCOztBQUU4UyIsInNvdXJjZXMiOlsiL1VzZXJzL2NoYW5jZW1jYWxsaXN0ZXIvUHJvamVjdHMvenVwYXNzaHVudC9ub2RlX21vZHVsZXMvQHprLWtpdC9iYWJ5LWp1Ymp1Yi9ub2RlX21vZHVsZXMvQHprLWtpdC91dGlscy9kaXN0L2xpYi5lc20vY29udmVyc2lvbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIEB6ay1raXQvdXRpbHNcbiAqIEB2ZXJzaW9uIDEuMi4xXG4gKiBAZmlsZSBFc3NlbnRpYWwgemVyby1rbm93bGVkZ2UgdXRpbGl0eSBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0IGRldmVsb3BlcnMuXG4gKiBAY29weXJpZ2h0IEV0aGVyZXVtIEZvdW5kYXRpb24gMjAyNFxuICogQGxpY2Vuc2UgTUlUXG4gKiBAc2VlIFtHaXRodWJde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9wcml2YWN5LXNjYWxpbmctZXhwbG9yYXRpb25zL3prLWtpdC90cmVlL21haW4vcGFja2FnZXMvdXRpbHN9XG4qL1xuaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnYnVmZmVyJztcbmltcG9ydCB7IHJlcXVpcmVCaWdJbnQsIHJlcXVpcmVUeXBlcywgcmVxdWlyZUJpZ051bWJlcmlzaCwgcmVxdWlyZUhleGFkZWNpbWFsLCByZXF1aXJlU3RyaW5nIH0gZnJvbSAnLi9lcnJvci1oYW5kbGVycy5qcyc7XG5pbXBvcnQgeyBpc0hleGFkZWNpbWFsLCBpc0J1ZmZlciwgaXNVaW50OEFycmF5IH0gZnJvbSAnLi90eXBlLWNoZWNrcy5qcyc7XG5cbi8qKlxuICogQG1vZHVsZSBDb252ZXJzaW9uc1xuICogVGhpcyBtb2R1bGUgcHJvdmlkZXMgYSBjb2xsZWN0aW9uIG9mIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBjb252ZXJ0aW5nXG4gKiBiZXR3ZWVuIGRpZmZlcmVudCBudW1lcmljYWwgZm9ybWF0cywgcGFydGljdWxhcmx5IGZvY3VzaW5nIG9uXG4gKiBjb252ZXJzaW9ucyBpbnZvbHZpbmcgYmlnaW50cywgaGV4YWRlY2ltYWxzIGFuZCBidWZmZXJzLlxuICogVGhlIG1vZHVsZSBpcyBzdHJ1Y3R1cmVkIHdpdGggY2xlYXIgZnVuY3Rpb24gbmFtaW5nIHRvIGluZGljYXRlXG4gKiB0aGUgY29udmVyc2lvbiBkaXJlY3Rpb24gKGUuZy4sIGBiaWdJbnRUb0hleGFkZWNpbWFsYCBmb3IgQmlnSW50XG4gKiB0byBoZXhhZGVjaW1hbCwgYGJ1ZmZlclRvQmlnSW50YCBmb3IgYnVmZmVyIHRvIGJpZ2ludCkgYW5kIGVtcGxveXNcbiAqIHR5cGUgY2hlY2tzIHRvIGVuc3VyZSB0aGUgY29ycmVjdCBoYW5kbGluZyBvZiB2YXJpb3VzIGlucHV0IHR5cGVzLlxuICogSXQgYWxzbyBpbmNsdWRlcyB2YXJpYXRpb25zIGZvciBib3RoIGJpZy1lbmRpYW4gKGBiZWApIGFuZCBsaXR0bGUtZW5kaWFuXG4gKiAoYGxlYCkgY29udmVyc2lvbnMuIEl0IGlzIGltcG9ydGFudCB0byBub3RlIHRoYXQgd2hlbiB0aGVyZSBpcyBubyBwcmVmaXgsXG4gKiB0aGUgb3JkZXIgb2YgYnl0ZXMgaXMgYWx3YXlzIGJpZy1lbmRpYW4uXG4gKi9cbi8qKlxuICogQ29udmVydHMgYSBiaWdpbnQgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIGJpZ2ludCB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGhleGFkZWNpbWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBiaWdpbnQuXG4gKi9cbmZ1bmN0aW9uIGJpZ0ludFRvSGV4YWRlY2ltYWwodmFsdWUpIHtcbiAgICByZXF1aXJlQmlnSW50KHZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGxldCBoZXggPSB2YWx1ZS50b1N0cmluZygxNik7XG4gICAgLy8gRW5zdXJlIGV2ZW4gbGVuZ3RoLlxuICAgIGlmIChoZXgubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICBoZXggPSBgMCR7aGV4fWA7XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGEgYmlnaW50LiBUaGUgaW5wdXQgaXMgaW50ZXJwcmV0ZWQgYXMgaGV4YWRlY2ltYWxcbiAqIHdpdGggb3Igd2l0aG91dCBhICcweCcgcHJlZml4LiBJdCB1c2VzIGJpZy1lbmRpYW4gYnl0ZSBvcmRlci5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgYmlnaW50IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGhleGFkZWNpbWFsVG9CaWdJbnQodmFsdWUpIHtcbiAgICBpZiAoIWlzSGV4YWRlY2ltYWwodmFsdWUpICYmICFpc0hleGFkZWNpbWFsKHZhbHVlLCBmYWxzZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGFyYW1ldGVyICd2YWx1ZScgaXMgbm90IGEgaGV4YWRlY2ltYWwgc3RyaW5nYCk7XG4gICAgfVxuICAgIC8vIEVuc3VyZSB0aGUgaGV4IHN0cmluZyBzdGFydHMgd2l0aCAnMHgnLlxuICAgIGNvbnN0IGZvcm1hdHRlZEhleFN0cmluZyA9IHZhbHVlLnN0YXJ0c1dpdGgoXCIweFwiKSA/IHZhbHVlIDogYDB4JHt2YWx1ZX1gO1xuICAgIHJldHVybiBCaWdJbnQoZm9ybWF0dGVkSGV4U3RyaW5nKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBidWZmZXIgb2YgYnl0ZXMgdG8gYSBiaWdpbnQgdXNpbmcgYmlnLWVuZGlhbiBieXRlIG9yZGVyLlxuICogSXQgYWNjZXB0cyAnQnVmZmVyJyBvciAnVWludDhBcnJheScuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIGJ1ZmZlciB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGJpZ2ludCByZXByZXNlbnRhdGlvbiBvZiB0aGUgYnVmZmVyJ3MgY29udGVudHMuXG4gKi9cbmZ1bmN0aW9uIGJlQnVmZmVyVG9CaWdJbnQodmFsdWUpIHtcbiAgICByZXF1aXJlVHlwZXModmFsdWUsIFwidmFsdWVcIiwgW1wiQnVmZmVyXCIsIFwiVWludDhBcnJheVwiXSk7XG4gICAgcmV0dXJuIEJpZ0ludChgMHgke0J1ZmZlci5mcm9tKHZhbHVlKS50b1N0cmluZyhcImhleFwiKX1gKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBidWZmZXIgdG8gYSBiaWdpbnQgdXNpbmcgbGl0dGxlLWVuZGlhbiBieXRlIG9yZGVyLlxuICogSXQgYWNjZXB0cyAnQnVmZmVyJyBvciAnVWludDhBcnJheScuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIGJ1ZmZlciB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGJpZ2ludCByZXByZXNlbnRhdGlvbiBvZiB0aGUgYnVmZmVyJ3MgY29udGVudHMgaW4gbGl0dGxlLWVuZGlhbi5cbiAqL1xuZnVuY3Rpb24gbGVCdWZmZXJUb0JpZ0ludCh2YWx1ZSkge1xuICAgIHJlcXVpcmVUeXBlcyh2YWx1ZSwgXCJ2YWx1ZVwiLCBbXCJCdWZmZXJcIiwgXCJVaW50OEFycmF5XCJdKTtcbiAgICByZXR1cm4gQmlnSW50KGAweCR7QnVmZmVyLmZyb20odmFsdWUpLnJldmVyc2UoKS50b1N0cmluZyhcImhleFwiKX1gKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBidWZmZXIgdG8gYSBiaWdpbnQuIEFsaWFzIGZvciBiZUJ1ZmZlclRvQmlnSW50LlxuICogQHBhcmFtIHZhbHVlIFRoZSBidWZmZXIgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBiaWdpbnQgcmVwcmVzZW50YXRpb24gb2YgdGhlIGJ1ZmZlcidzIGNvbnRlbnRzLlxuICovXG5mdW5jdGlvbiBidWZmZXJUb0JpZ0ludCh2YWx1ZSkge1xuICAgIHJldHVybiBiZUJ1ZmZlclRvQmlnSW50KHZhbHVlKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBiaWdpbnQgdG8gYSBidWZmZXIgYW5kIGZpbGxzIHdpdGggemVyb3MgaWYgYSB2YWxpZFxuICogc2l6ZSAoaS5lLiBudW1iZXIgb2YgYnl0ZXMpIGlzIHNwZWNpZmllZC4gSWYgdGhlIHNpemUgaXMgbm90IGRlZmluZWQsXG4gKiBpdCBnZXRzIHRoZSBzaXplIGZyb20gdGhlIGdpdmVuIGJpZ2ludC4gSWYgdGhlIHNwZWNpZmllZCBzaXplIGlzIHNtYWxsZXIgdGhhblxuICogdGhlIHNpemUgb2YgdGhlIGJpZ2ludCAoaS5lLiBgbWluU2l6ZWApLCBhbiBlcnJvciBpcyB0aHJvd24uXG4gKiBJdCB1c2VzIGJpZy1lbmRpYW4gYnl0ZSBvcmRlci5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgYmlnaW50IHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gc2l6ZSBUaGUgbnVtYmVyIG9mIGJ5dGVzIG9mIHRoZSBidWZmZXIgdG8gcmV0dXJuLlxuICogQHJldHVybnMgVGhlIGJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiB0aGUgYmlnaW50LlxuICovXG5mdW5jdGlvbiBiZUJpZ0ludFRvQnVmZmVyKHZhbHVlLCBzaXplKSB7XG4gICAgY29uc3QgaGV4ID0gYmlnSW50VG9IZXhhZGVjaW1hbCh2YWx1ZSk7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBtaW5pbXVtIGJ1ZmZlciBzaXplIHJlcXVpcmVkIHRvIHJlcHJlc2VudCAnbicgaW4gYnl0ZXMuXG4gICAgLy8gRWFjaCBoZXhhZGVjaW1hbCBjaGFyYWN0ZXIgcmVwcmVzZW50cyA0IGJpdHMsIHNvIDIgY2hhcmFjdGVycyBhcmUgMSBieXRlLlxuICAgIGNvbnN0IG1pblNpemUgPSBNYXRoLmNlaWwoaGV4Lmxlbmd0aCAvIDIpO1xuICAgIGlmICghc2l6ZSkge1xuICAgICAgICBzaXplID0gbWluU2l6ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2l6ZSA8IG1pblNpemUpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYFNpemUgJHtzaXplfSBpcyB0b28gc21hbGwsIG5lZWQgYXQgbGVhc3QgJHttaW5TaXplfSBieXRlc2ApO1xuICAgIH1cbiAgICAvLyBBbGxvY2F0ZSBidWZmZXIgb2YgdGhlIGRlc2lyZWQgc2l6ZSwgZmlsbGVkIHdpdGggemVyb3MuXG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jKHNpemUsIDApO1xuICAgIGNvbnN0IGZyb21IZXggPSBCdWZmZXIuZnJvbShoZXgsIFwiaGV4XCIpO1xuICAgIGZyb21IZXguY29weShidWZmZXIsIHNpemUgLSBmcm9tSGV4Lmxlbmd0aCk7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cbi8qKlxuICogQ29udmVydHMgYSBiaWdpbnQgdG8gYSBidWZmZXIgYW5kIGZpbGxzIHdpdGggemVyb3MgaWYgYSB2YWxpZFxuICogc2l6ZSAoaS5lLiBudW1iZXIgb2YgYnl0ZXMpIGlzIHNwZWNpZmllZC4gSWYgdGhlIHNpemUgaXMgbm90IGRlZmluZWQsXG4gKiBpdCBnZXRzIHRoZSBzaXplIGZyb20gdGhlIGdpdmVuIGJpZ2ludC4gSWYgdGhlIHNwZWNpZmllZCBzaXplIGlzIHNtYWxsZXIgdGhhblxuICogdGhlIHNpemUgb2YgdGhlIGJpZ2ludCAoaS5lLiBgbWluU2l6ZWApLCBhbiBlcnJvciBpcyB0aHJvd24uXG4gKiBJdCB1c2VzIGxpdHRsZS1lbmRpYW4gYnl0ZSBvcmRlci5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgYmlnaW50IHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gc2l6ZSBUaGUgbnVtYmVyIG9mIGJ5dGVzIG9mIHRoZSBidWZmZXIgdG8gcmV0dXJuLlxuICogQHJldHVybnMgVGhlIGJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiB0aGUgYmlnaW50IGluIGxpdHRsZS1lbmRpYW4uXG4gKi9cbmZ1bmN0aW9uIGxlQmlnSW50VG9CdWZmZXIodmFsdWUsIHNpemUpIHtcbiAgICBjb25zdCBoZXggPSBiaWdJbnRUb0hleGFkZWNpbWFsKHZhbHVlKTtcbiAgICAvLyBDYWxjdWxhdGUgdGhlIG1pbmltdW0gYnVmZmVyIHNpemUgcmVxdWlyZWQgdG8gcmVwcmVzZW50ICduJyBpbiBieXRlcy5cbiAgICAvLyBFYWNoIGhleGFkZWNpbWFsIGNoYXJhY3RlciByZXByZXNlbnRzIDQgYml0cywgc28gMiBjaGFyYWN0ZXJzIGFyZSAxIGJ5dGUuXG4gICAgY29uc3QgbWluU2l6ZSA9IE1hdGguY2VpbChoZXgubGVuZ3RoIC8gMik7XG4gICAgaWYgKCFzaXplKSB7XG4gICAgICAgIHNpemUgPSBtaW5TaXplO1xuICAgIH1cbiAgICBlbHNlIGlmIChzaXplIDwgbWluU2l6ZSkge1xuICAgICAgICB0aHJvdyBFcnJvcihgU2l6ZSAke3NpemV9IGlzIHRvbyBzbWFsbCwgbmVlZCBhdCBsZWFzdCAke21pblNpemV9IGJ5dGVzYCk7XG4gICAgfVxuICAgIC8vIEFsbG9jYXRlIGJ1ZmZlciBvZiB0aGUgZGVzaXJlZCBzaXplLCBmaWxsZWQgd2l0aCB6ZXJvcy5cbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2Moc2l6ZSwgMCk7XG4gICAgY29uc3QgZnJvbUhleCA9IEJ1ZmZlci5mcm9tKGhleCwgXCJoZXhcIikucmV2ZXJzZSgpO1xuICAgIGZyb21IZXguY29weShidWZmZXIsIDApO1xuICAgIHJldHVybiBidWZmZXI7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgYmlnaW50IHRvIGEgYnVmZmVyLiBBbGlhcyBmb3IgYmVCaWdJbnRUb0J1ZmZlci5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgYmlnaW50IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgYnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBiaWdpbnQuXG4gKi9cbmZ1bmN0aW9uIGJpZ0ludFRvQnVmZmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIGJlQmlnSW50VG9CdWZmZXIodmFsdWUpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIEJpZ051bWJlcmlzaCB0eXBlIHRvIGEgYmlnaW50LiBJZiB0aGUgaW5wdXQgaXMgYWxyZWFkeSBhIGJpZ2ludCxcbiAqIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSB0aGUgYmlnaW50IGl0c2VsZiwgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgY29udmVydGVkXG4gKiB0byBhIGJpZ2ludCB1c2luZyBiaWctZW5kaWFuIGJ5dGUgb3JkZXIuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIEJpZ051bWJlcmlzaCB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGJpZ2ludCByZXByZXNlbnRhdGlvbiBvZiB0aGUgQmlnTnVtYmVyaXNoIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiaWdOdW1iZXJpc2hUb0JpZ0ludCh2YWx1ZSkge1xuICAgIHJlcXVpcmVCaWdOdW1iZXJpc2godmFsdWUsIFwidmFsdWVcIik7XG4gICAgaWYgKGlzQnVmZmVyKHZhbHVlKSB8fCBpc1VpbnQ4QXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBidWZmZXJUb0JpZ0ludCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBCaWdJbnQodmFsdWUpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIEJpZ051bWJlcmlzaCB0eXBlIHRvIGEgYnVmZmVyLiBJZiB0aGUgaW5wdXQgaXMgYWxyZWFkeSBhIGJ1ZmZlcixcbiAqIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSB0aGUgYnVmZmVyIGl0c2VsZiwgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgY29udmVydGVkXG4gKiB0byBhIGJ1ZmZlciB1c2luZyBiaWctZW5kaWFuIGJ5dGUgb3JkZXIuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIEJpZ051bWJlcmlzaCB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiB0aGUgQmlnTnVtYmVyaXNoIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiaWdOdW1iZXJpc2hUb0J1ZmZlcih2YWx1ZSkge1xuICAgIHJlcXVpcmVCaWdOdW1iZXJpc2godmFsdWUsIFwidmFsdWVcIik7XG4gICAgaWYgKGlzQnVmZmVyKHZhbHVlKSB8fCBpc1VpbnQ4QXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBiaWdJbnRUb0J1ZmZlcihiaWdOdW1iZXJpc2hUb0JpZ0ludCh2YWx1ZSkpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBidWZmZXIuIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmdcbiAqIHNob3VsZCBub3Qgc3RhcnQgd2l0aCAnMHgnIG9yICcwWCcuIEl0IGtlZXBzIHRoZSBieXRlcyBpbiB0aGUgc2FtZSBvcmRlci5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgYnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGhleGFkZWNpbWFsVG9CdWZmZXIodmFsdWUpIHtcbiAgICByZXF1aXJlSGV4YWRlY2ltYWwodmFsdWUsIFwidmFsdWVcIiwgZmFsc2UpO1xuICAgIC8vIEVuc3VyZSBldmVuIGxlbmd0aCBiZWZvcmUgY29udmVydGluZyB0byBidWZmZXIuXG4gICAgaWYgKHZhbHVlLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgdmFsdWUgPSBgMCR7dmFsdWV9YDtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlLCBcImhleFwiKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBidWZmZXIgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuIEl0IGFjY2VwdHMgJ0J1ZmZlcicgb3IgJ1VpbnQ4QXJyYXknLlxuICogVGhlIGhleGFkZWNpbWFsIHN0cmluZyB3aWxsIG5vdCBzdGFydCB3aXRoICcweCcgb3IgJzBYJy4gSXQga2VlcHMgdGhlIGJ5dGVzIGluIHRoZSBzYW1lIG9yZGVyLlxuICogQHBhcmFtIHZhbHVlIFRoZSBidWZmZXIgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBjb252ZXJ0ZWQgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBidWZmZXJUb0hleGFkZWNpbWFsKHZhbHVlKSB7XG4gICAgcmVxdWlyZVR5cGVzKHZhbHVlLCBcInZhbHVlXCIsIFtcIkJ1ZmZlclwiLCBcIlVpbnQ4QXJyYXlcIl0pO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZSkudG9TdHJpbmcoXCJoZXhcIik7XG59XG4vKipcbiAqIENvbnZlcnRzIGJ5dGVzIHRvIGEgYmFzZTY0IHN0cmluZy4gSXQgYWNjZXB0cyAnQnVmZmVyJyBvciAnVWludDhBcnJheScuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIGJ5dGVzIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgY29udmVydGVkIGJhc2U2NCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlclRvQmFzZTY0KHZhbHVlKSB7XG4gICAgcmVxdWlyZVR5cGVzKHZhbHVlLCBcInZhbHVlXCIsIFtcIkJ1ZmZlclwiLCBcIlVpbnQ4QXJyYXlcIl0pO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZSkudG9TdHJpbmcoXCJiYXNlNjRcIik7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgYmFzZTY0IHN0cmluZyB0byBieXRlcyAoaS5lLiBhIGJ1ZmZlcikuIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgY2hlY2tcbiAqIGlmIHRoZSBpbnB1dCB2YWx1ZSBpcyBhIHZhbGlkIGJhc2U2NCBzdHJpbmcuIElmIHRoZXJlIGFyZSB1bnN1cHBvcnRlZCBjaGFyYWN0ZXJzXG4gKiB0aGV5IHdpbGwgYmUgaWdub3JlZC5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgYmFzZTY0IHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGJhc2U2NFRvQnVmZmVyKHZhbHVlKSB7XG4gICAgcmVxdWlyZVN0cmluZyh2YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUsIFwiYmFzZTY0XCIpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyB0ZXh0ICh1dGY4KSB0byBhIGJhc2U2NCBzdHJpbmcuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHRleHQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBjb252ZXJ0ZWQgYmFzZTY0IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdGV4dFRvQmFzZTY0KHZhbHVlKSB7XG4gICAgcmVxdWlyZVN0cmluZyh2YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUsIFwidXRmOFwiKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBiYXNlNjQgc3RyaW5nIHRvIHRleHQgKHV0ZjgpLiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGNoZWNrXG4gKiBpZiB0aGUgaW5wdXQgdmFsdWUgaXMgYSB2YWxpZCBiYXNlNjQgc3RyaW5nLiBJZiB0aGVyZSBhcmUgdW5zdXBwb3J0ZWQgY2hhcmFjdGVyc1xuICogdGhleSBjb3VsZCBiZSBpZ25vcmVkIGFuZCB0aGUgcmVzdWx0IG1heSBiZSB1bmV4cGVjdGVkLlxuICogQHBhcmFtIHZhbHVlIFRoZSBiYXNlNjQgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgY29udmVydGVkIHRleHQuXG4gKi9cbmZ1bmN0aW9uIGJhc2U2NFRvVGV4dCh2YWx1ZSkge1xuICAgIHJlcXVpcmVTdHJpbmcodmFsdWUsIFwidmFsdWVcIik7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlLCBcImJhc2U2NFwiKS50b1N0cmluZyhcInV0ZjhcIik7XG59XG5cbmV4cG9ydCB7IGJhc2U2NFRvQnVmZmVyLCBiYXNlNjRUb1RleHQsIGJlQmlnSW50VG9CdWZmZXIsIGJlQnVmZmVyVG9CaWdJbnQsIGJpZ0ludFRvQnVmZmVyLCBiaWdJbnRUb0hleGFkZWNpbWFsLCBiaWdOdW1iZXJpc2hUb0JpZ0ludCwgYmlnTnVtYmVyaXNoVG9CdWZmZXIsIGJ1ZmZlclRvQmFzZTY0LCBidWZmZXJUb0JpZ0ludCwgYnVmZmVyVG9IZXhhZGVjaW1hbCwgaGV4YWRlY2ltYWxUb0JpZ0ludCwgaGV4YWRlY2ltYWxUb0J1ZmZlciwgbGVCaWdJbnRUb0J1ZmZlciwgbGVCdWZmZXJUb0JpZ0ludCwgdGV4dFRvQmFzZTY0IH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@zk-kit/baby-jubjub/node_modules/@zk-kit/utils/dist/lib.esm/conversions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@zk-kit/baby-jubjub/node_modules/@zk-kit/utils/dist/lib.esm/error-handlers.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@zk-kit/baby-jubjub/node_modules/@zk-kit/utils/dist/lib.esm/error-handlers.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   requireArray: () => (/* binding */ requireArray),\n/* harmony export */   requireBigInt: () => (/* binding */ requireBigInt),\n/* harmony export */   requireBigNumber: () => (/* binding */ requireBigNumber),\n/* harmony export */   requireBigNumberish: () => (/* binding */ requireBigNumberish),\n/* harmony export */   requireBuffer: () => (/* binding */ requireBuffer),\n/* harmony export */   requireDefined: () => (/* binding */ requireDefined),\n/* harmony export */   requireFunction: () => (/* binding */ requireFunction),\n/* harmony export */   requireHexadecimal: () => (/* binding */ requireHexadecimal),\n/* harmony export */   requireNumber: () => (/* binding */ requireNumber),\n/* harmony export */   requireObject: () => (/* binding */ requireObject),\n/* harmony export */   requireString: () => (/* binding */ requireString),\n/* harmony export */   requireStringifiedBigInt: () => (/* binding */ requireStringifiedBigInt),\n/* harmony export */   requireTypes: () => (/* binding */ requireTypes),\n/* harmony export */   requireUint8Array: () => (/* binding */ requireUint8Array)\n/* harmony export */ });\n/* harmony import */ var _type_checks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./type-checks.js */ \"(ssr)/./node_modules/@zk-kit/baby-jubjub/node_modules/@zk-kit/utils/dist/lib.esm/type-checks.js\");\n/**\n * @module @zk-kit/utils\n * @version 1.2.1\n * @file Essential zero-knowledge utility library for JavaScript developers.\n * @copyright Ethereum Foundation 2024\n * @license MIT\n * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/utils}\n*/\n\n\n/**\n * @module ErrorHandlers\n * This module is designed to provide utility functions for validating\n * function parameters. It includes functions that throw type errors if\n * the parameters do not meet specified criteria, such as being defined,\n * a number, a string, a function, or an array. This module helps ensure\n * that functions receive the correct types of inputs, enhancing code\n * reliability and reducing runtime errors.\n */\n/**\n * @throws Throws a type error if the parameter value has not been defined.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireDefined(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isDefined)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not defined`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a number.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireNumber(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isNumber)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a number, received type: ${typeof parameterValue}`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a string.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireString(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isString)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a string, received type: ${typeof parameterValue}`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a function.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireFunction(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a function, received type: ${typeof parameterValue}`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not an Array.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireArray(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not an Array instance`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a Uint8Array.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireUint8Array(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isUint8Array)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a Uint8Array instance`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a Buffer.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireBuffer(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isBuffer)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a Buffer instance`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not an object.\n * Please, note that arrays are also objects in JavaScript.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireObject(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not an object, received type: ${typeof parameterValue}`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a bigint.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireBigInt(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isBigInt)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a bigint, received type: ${typeof parameterValue}`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a stringified bigint.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireStringifiedBigInt(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isStringifiedBigInt)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a stringified bigint`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a hexadecimal string.\n * If 'prefix' is 'true', the string must start with '0x' or '0X' followed by one or more\n * hexadecimal digits (0-9, a-f, A-F), otherwise no prefix is expected. 'prefix' is optional and\n * if its value it is not explicitly defined it will be set to 'true' by default.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n * @param prefix A boolean to include or not a '0x' or '0X' prefix.\n */\nfunction requireHexadecimal(parameterValue, parameterName, prefix = true) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isHexadecimal)(parameterValue, prefix)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a hexadecimal string`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a bignumber.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireBigNumber(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isBigNumber)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a bignumber`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a bignumber-ish.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireBigNumberish(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isBigNumberish)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a bignumber-ish`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value type is not part of the list of types.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireTypes(parameterValue, parameterName, types) {\n    for (const type of types) {\n        if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isSupportedType)(type)) {\n            throw new Error(`Type '${type}' is not supported`);\n        }\n    }\n    for (const type of types) {\n        if ((0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isType)(parameterValue, type)) {\n            return;\n        }\n    }\n    throw new TypeError(`Parameter '${parameterName}' is none of the following types: ${types.join(\", \")}`);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHprLWtpdC9iYWJ5LWp1Ymp1Yi9ub2RlX21vZHVsZXMvQHprLWtpdC91dGlscy9kaXN0L2xpYi5lc20vZXJyb3ItaGFuZGxlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQzROOztBQUU1TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDBEQUFTO0FBQ2xCLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHlEQUFRO0FBQ2pCLDBDQUEwQyxjQUFjLG9DQUFvQyxzQkFBc0I7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMseURBQVE7QUFDakIsMENBQTBDLGNBQWMsb0NBQW9DLHNCQUFzQjtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywyREFBVTtBQUNuQiwwQ0FBMEMsY0FBYyxzQ0FBc0Msc0JBQXNCO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHdEQUFPO0FBQ2hCLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZEQUFZO0FBQ3JCLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHlEQUFRO0FBQ2pCLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMseURBQVE7QUFDakIsMENBQTBDLGNBQWMscUNBQXFDLHNCQUFzQjtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx5REFBUTtBQUNqQiwwQ0FBMEMsY0FBYyxvQ0FBb0Msc0JBQXNCO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG9FQUFtQjtBQUM1QiwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhEQUFhO0FBQ3RCLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDREQUFXO0FBQ3BCLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLCtEQUFjO0FBQ3ZCLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0VBQWU7QUFDNUIscUNBQXFDLEtBQUs7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1REFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsY0FBYyxvQ0FBb0MsaUJBQWlCO0FBQ3pHOztBQUUwUCIsInNvdXJjZXMiOlsiL1VzZXJzL2NoYW5jZW1jYWxsaXN0ZXIvUHJvamVjdHMvenVwYXNzaHVudC9ub2RlX21vZHVsZXMvQHprLWtpdC9iYWJ5LWp1Ymp1Yi9ub2RlX21vZHVsZXMvQHprLWtpdC91dGlscy9kaXN0L2xpYi5lc20vZXJyb3ItaGFuZGxlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIEB6ay1raXQvdXRpbHNcbiAqIEB2ZXJzaW9uIDEuMi4xXG4gKiBAZmlsZSBFc3NlbnRpYWwgemVyby1rbm93bGVkZ2UgdXRpbGl0eSBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0IGRldmVsb3BlcnMuXG4gKiBAY29weXJpZ2h0IEV0aGVyZXVtIEZvdW5kYXRpb24gMjAyNFxuICogQGxpY2Vuc2UgTUlUXG4gKiBAc2VlIFtHaXRodWJde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9wcml2YWN5LXNjYWxpbmctZXhwbG9yYXRpb25zL3prLWtpdC90cmVlL21haW4vcGFja2FnZXMvdXRpbHN9XG4qL1xuaW1wb3J0IHsgaXNEZWZpbmVkLCBpc051bWJlciwgaXNTdHJpbmcsIGlzRnVuY3Rpb24sIGlzQXJyYXksIGlzVWludDhBcnJheSwgaXNCdWZmZXIsIGlzT2JqZWN0LCBpc0JpZ0ludCwgaXNTdHJpbmdpZmllZEJpZ0ludCwgaXNIZXhhZGVjaW1hbCwgaXNCaWdOdW1iZXIsIGlzQmlnTnVtYmVyaXNoLCBpc1N1cHBvcnRlZFR5cGUsIGlzVHlwZSB9IGZyb20gJy4vdHlwZS1jaGVja3MuanMnO1xuXG4vKipcbiAqIEBtb2R1bGUgRXJyb3JIYW5kbGVyc1xuICogVGhpcyBtb2R1bGUgaXMgZGVzaWduZWQgdG8gcHJvdmlkZSB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgdmFsaWRhdGluZ1xuICogZnVuY3Rpb24gcGFyYW1ldGVycy4gSXQgaW5jbHVkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3cgdHlwZSBlcnJvcnMgaWZcbiAqIHRoZSBwYXJhbWV0ZXJzIGRvIG5vdCBtZWV0IHNwZWNpZmllZCBjcml0ZXJpYSwgc3VjaCBhcyBiZWluZyBkZWZpbmVkLFxuICogYSBudW1iZXIsIGEgc3RyaW5nLCBhIGZ1bmN0aW9uLCBvciBhbiBhcnJheS4gVGhpcyBtb2R1bGUgaGVscHMgZW5zdXJlXG4gKiB0aGF0IGZ1bmN0aW9ucyByZWNlaXZlIHRoZSBjb3JyZWN0IHR5cGVzIG9mIGlucHV0cywgZW5oYW5jaW5nIGNvZGVcbiAqIHJlbGlhYmlsaXR5IGFuZCByZWR1Y2luZyBydW50aW1lIGVycm9ycy5cbiAqL1xuLyoqXG4gKiBAdGhyb3dzIFRocm93cyBhIHR5cGUgZXJyb3IgaWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBoYXMgbm90IGJlZW4gZGVmaW5lZC5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJWYWx1ZSBUaGUgcGFyYW1ldGVyIHZhbHVlLlxuICogQHBhcmFtIHBhcmFtZXRlck5hbWUgVGhlIHBhcmFtZXRlciBuYW1lLlxuICovXG5mdW5jdGlvbiByZXF1aXJlRGVmaW5lZChwYXJhbWV0ZXJWYWx1ZSwgcGFyYW1ldGVyTmFtZSkge1xuICAgIGlmICghaXNEZWZpbmVkKHBhcmFtZXRlclZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJyR7cGFyYW1ldGVyTmFtZX0nIGlzIG5vdCBkZWZpbmVkYCk7XG4gICAgfVxufVxuLyoqXG4gKiBAdGhyb3dzIFRocm93cyBhIHR5cGUgZXJyb3IgaWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBpcyBub3QgYSBudW1iZXIuXG4gKiBAcGFyYW0gcGFyYW1ldGVyVmFsdWUgVGhlIHBhcmFtZXRlciB2YWx1ZS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJOYW1lIFRoZSBwYXJhbWV0ZXIgbmFtZS5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZU51bWJlcihwYXJhbWV0ZXJWYWx1ZSwgcGFyYW1ldGVyTmFtZSkge1xuICAgIGlmICghaXNOdW1iZXIocGFyYW1ldGVyVmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAnJHtwYXJhbWV0ZXJOYW1lfScgaXMgbm90IGEgbnVtYmVyLCByZWNlaXZlZCB0eXBlOiAke3R5cGVvZiBwYXJhbWV0ZXJWYWx1ZX1gKTtcbiAgICB9XG59XG4vKipcbiAqIEB0aHJvd3MgVGhyb3dzIGEgdHlwZSBlcnJvciBpZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIG5vdCBhIHN0cmluZy5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJWYWx1ZSBUaGUgcGFyYW1ldGVyIHZhbHVlLlxuICogQHBhcmFtIHBhcmFtZXRlck5hbWUgVGhlIHBhcmFtZXRlciBuYW1lLlxuICovXG5mdW5jdGlvbiByZXF1aXJlU3RyaW5nKHBhcmFtZXRlclZhbHVlLCBwYXJhbWV0ZXJOYW1lKSB7XG4gICAgaWYgKCFpc1N0cmluZyhwYXJhbWV0ZXJWYWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGFyYW1ldGVyICcke3BhcmFtZXRlck5hbWV9JyBpcyBub3QgYSBzdHJpbmcsIHJlY2VpdmVkIHR5cGU6ICR7dHlwZW9mIHBhcmFtZXRlclZhbHVlfWApO1xuICAgIH1cbn1cbi8qKlxuICogQHRocm93cyBUaHJvd3MgYSB0eXBlIGVycm9yIGlmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgaXMgbm90IGEgZnVuY3Rpb24uXG4gKiBAcGFyYW0gcGFyYW1ldGVyVmFsdWUgVGhlIHBhcmFtZXRlciB2YWx1ZS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJOYW1lIFRoZSBwYXJhbWV0ZXIgbmFtZS5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZUZ1bmN0aW9uKHBhcmFtZXRlclZhbHVlLCBwYXJhbWV0ZXJOYW1lKSB7XG4gICAgaWYgKCFpc0Z1bmN0aW9uKHBhcmFtZXRlclZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJyR7cGFyYW1ldGVyTmFtZX0nIGlzIG5vdCBhIGZ1bmN0aW9uLCByZWNlaXZlZCB0eXBlOiAke3R5cGVvZiBwYXJhbWV0ZXJWYWx1ZX1gKTtcbiAgICB9XG59XG4vKipcbiAqIEB0aHJvd3MgVGhyb3dzIGEgdHlwZSBlcnJvciBpZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIG5vdCBhbiBBcnJheS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJWYWx1ZSBUaGUgcGFyYW1ldGVyIHZhbHVlLlxuICogQHBhcmFtIHBhcmFtZXRlck5hbWUgVGhlIHBhcmFtZXRlciBuYW1lLlxuICovXG5mdW5jdGlvbiByZXF1aXJlQXJyYXkocGFyYW1ldGVyVmFsdWUsIHBhcmFtZXRlck5hbWUpIHtcbiAgICBpZiAoIWlzQXJyYXkocGFyYW1ldGVyVmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAnJHtwYXJhbWV0ZXJOYW1lfScgaXMgbm90IGFuIEFycmF5IGluc3RhbmNlYCk7XG4gICAgfVxufVxuLyoqXG4gKiBAdGhyb3dzIFRocm93cyBhIHR5cGUgZXJyb3IgaWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBpcyBub3QgYSBVaW50OEFycmF5LlxuICogQHBhcmFtIHBhcmFtZXRlclZhbHVlIFRoZSBwYXJhbWV0ZXIgdmFsdWUuXG4gKiBAcGFyYW0gcGFyYW1ldGVyTmFtZSBUaGUgcGFyYW1ldGVyIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVVaW50OEFycmF5KHBhcmFtZXRlclZhbHVlLCBwYXJhbWV0ZXJOYW1lKSB7XG4gICAgaWYgKCFpc1VpbnQ4QXJyYXkocGFyYW1ldGVyVmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAnJHtwYXJhbWV0ZXJOYW1lfScgaXMgbm90IGEgVWludDhBcnJheSBpbnN0YW5jZWApO1xuICAgIH1cbn1cbi8qKlxuICogQHRocm93cyBUaHJvd3MgYSB0eXBlIGVycm9yIGlmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgaXMgbm90IGEgQnVmZmVyLlxuICogQHBhcmFtIHBhcmFtZXRlclZhbHVlIFRoZSBwYXJhbWV0ZXIgdmFsdWUuXG4gKiBAcGFyYW0gcGFyYW1ldGVyTmFtZSBUaGUgcGFyYW1ldGVyIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVCdWZmZXIocGFyYW1ldGVyVmFsdWUsIHBhcmFtZXRlck5hbWUpIHtcbiAgICBpZiAoIWlzQnVmZmVyKHBhcmFtZXRlclZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJyR7cGFyYW1ldGVyTmFtZX0nIGlzIG5vdCBhIEJ1ZmZlciBpbnN0YW5jZWApO1xuICAgIH1cbn1cbi8qKlxuICogQHRocm93cyBUaHJvd3MgYSB0eXBlIGVycm9yIGlmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgaXMgbm90IGFuIG9iamVjdC5cbiAqIFBsZWFzZSwgbm90ZSB0aGF0IGFycmF5cyBhcmUgYWxzbyBvYmplY3RzIGluIEphdmFTY3JpcHQuXG4gKiBAcGFyYW0gcGFyYW1ldGVyVmFsdWUgVGhlIHBhcmFtZXRlciB2YWx1ZS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJOYW1lIFRoZSBwYXJhbWV0ZXIgbmFtZS5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZU9iamVjdChwYXJhbWV0ZXJWYWx1ZSwgcGFyYW1ldGVyTmFtZSkge1xuICAgIGlmICghaXNPYmplY3QocGFyYW1ldGVyVmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAnJHtwYXJhbWV0ZXJOYW1lfScgaXMgbm90IGFuIG9iamVjdCwgcmVjZWl2ZWQgdHlwZTogJHt0eXBlb2YgcGFyYW1ldGVyVmFsdWV9YCk7XG4gICAgfVxufVxuLyoqXG4gKiBAdGhyb3dzIFRocm93cyBhIHR5cGUgZXJyb3IgaWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBpcyBub3QgYSBiaWdpbnQuXG4gKiBAcGFyYW0gcGFyYW1ldGVyVmFsdWUgVGhlIHBhcmFtZXRlciB2YWx1ZS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJOYW1lIFRoZSBwYXJhbWV0ZXIgbmFtZS5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZUJpZ0ludChwYXJhbWV0ZXJWYWx1ZSwgcGFyYW1ldGVyTmFtZSkge1xuICAgIGlmICghaXNCaWdJbnQocGFyYW1ldGVyVmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAnJHtwYXJhbWV0ZXJOYW1lfScgaXMgbm90IGEgYmlnaW50LCByZWNlaXZlZCB0eXBlOiAke3R5cGVvZiBwYXJhbWV0ZXJWYWx1ZX1gKTtcbiAgICB9XG59XG4vKipcbiAqIEB0aHJvd3MgVGhyb3dzIGEgdHlwZSBlcnJvciBpZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIG5vdCBhIHN0cmluZ2lmaWVkIGJpZ2ludC5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJWYWx1ZSBUaGUgcGFyYW1ldGVyIHZhbHVlLlxuICogQHBhcmFtIHBhcmFtZXRlck5hbWUgVGhlIHBhcmFtZXRlciBuYW1lLlxuICovXG5mdW5jdGlvbiByZXF1aXJlU3RyaW5naWZpZWRCaWdJbnQocGFyYW1ldGVyVmFsdWUsIHBhcmFtZXRlck5hbWUpIHtcbiAgICBpZiAoIWlzU3RyaW5naWZpZWRCaWdJbnQocGFyYW1ldGVyVmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAnJHtwYXJhbWV0ZXJOYW1lfScgaXMgbm90IGEgc3RyaW5naWZpZWQgYmlnaW50YCk7XG4gICAgfVxufVxuLyoqXG4gKiBAdGhyb3dzIFRocm93cyBhIHR5cGUgZXJyb3IgaWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBpcyBub3QgYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKiBJZiAncHJlZml4JyBpcyAndHJ1ZScsIHRoZSBzdHJpbmcgbXVzdCBzdGFydCB3aXRoICcweCcgb3IgJzBYJyBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZVxuICogaGV4YWRlY2ltYWwgZGlnaXRzICgwLTksIGEtZiwgQS1GKSwgb3RoZXJ3aXNlIG5vIHByZWZpeCBpcyBleHBlY3RlZC4gJ3ByZWZpeCcgaXMgb3B0aW9uYWwgYW5kXG4gKiBpZiBpdHMgdmFsdWUgaXQgaXMgbm90IGV4cGxpY2l0bHkgZGVmaW5lZCBpdCB3aWxsIGJlIHNldCB0byAndHJ1ZScgYnkgZGVmYXVsdC5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJWYWx1ZSBUaGUgcGFyYW1ldGVyIHZhbHVlLlxuICogQHBhcmFtIHBhcmFtZXRlck5hbWUgVGhlIHBhcmFtZXRlciBuYW1lLlxuICogQHBhcmFtIHByZWZpeCBBIGJvb2xlYW4gdG8gaW5jbHVkZSBvciBub3QgYSAnMHgnIG9yICcwWCcgcHJlZml4LlxuICovXG5mdW5jdGlvbiByZXF1aXJlSGV4YWRlY2ltYWwocGFyYW1ldGVyVmFsdWUsIHBhcmFtZXRlck5hbWUsIHByZWZpeCA9IHRydWUpIHtcbiAgICBpZiAoIWlzSGV4YWRlY2ltYWwocGFyYW1ldGVyVmFsdWUsIHByZWZpeCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGFyYW1ldGVyICcke3BhcmFtZXRlck5hbWV9JyBpcyBub3QgYSBoZXhhZGVjaW1hbCBzdHJpbmdgKTtcbiAgICB9XG59XG4vKipcbiAqIEB0aHJvd3MgVGhyb3dzIGEgdHlwZSBlcnJvciBpZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIG5vdCBhIGJpZ251bWJlci5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJWYWx1ZSBUaGUgcGFyYW1ldGVyIHZhbHVlLlxuICogQHBhcmFtIHBhcmFtZXRlck5hbWUgVGhlIHBhcmFtZXRlciBuYW1lLlxuICovXG5mdW5jdGlvbiByZXF1aXJlQmlnTnVtYmVyKHBhcmFtZXRlclZhbHVlLCBwYXJhbWV0ZXJOYW1lKSB7XG4gICAgaWYgKCFpc0JpZ051bWJlcihwYXJhbWV0ZXJWYWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGFyYW1ldGVyICcke3BhcmFtZXRlck5hbWV9JyBpcyBub3QgYSBiaWdudW1iZXJgKTtcbiAgICB9XG59XG4vKipcbiAqIEB0aHJvd3MgVGhyb3dzIGEgdHlwZSBlcnJvciBpZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIG5vdCBhIGJpZ251bWJlci1pc2guXG4gKiBAcGFyYW0gcGFyYW1ldGVyVmFsdWUgVGhlIHBhcmFtZXRlciB2YWx1ZS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJOYW1lIFRoZSBwYXJhbWV0ZXIgbmFtZS5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZUJpZ051bWJlcmlzaChwYXJhbWV0ZXJWYWx1ZSwgcGFyYW1ldGVyTmFtZSkge1xuICAgIGlmICghaXNCaWdOdW1iZXJpc2gocGFyYW1ldGVyVmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAnJHtwYXJhbWV0ZXJOYW1lfScgaXMgbm90IGEgYmlnbnVtYmVyLWlzaGApO1xuICAgIH1cbn1cbi8qKlxuICogQHRocm93cyBUaHJvd3MgYSB0eXBlIGVycm9yIGlmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgdHlwZSBpcyBub3QgcGFydCBvZiB0aGUgbGlzdCBvZiB0eXBlcy5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJWYWx1ZSBUaGUgcGFyYW1ldGVyIHZhbHVlLlxuICogQHBhcmFtIHBhcmFtZXRlck5hbWUgVGhlIHBhcmFtZXRlciBuYW1lLlxuICovXG5mdW5jdGlvbiByZXF1aXJlVHlwZXMocGFyYW1ldGVyVmFsdWUsIHBhcmFtZXRlck5hbWUsIHR5cGVzKSB7XG4gICAgZm9yIChjb25zdCB0eXBlIG9mIHR5cGVzKSB7XG4gICAgICAgIGlmICghaXNTdXBwb3J0ZWRUeXBlKHR5cGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFR5cGUgJyR7dHlwZX0nIGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgdHlwZXMpIHtcbiAgICAgICAgaWYgKGlzVHlwZShwYXJhbWV0ZXJWYWx1ZSwgdHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJyR7cGFyYW1ldGVyTmFtZX0nIGlzIG5vbmUgb2YgdGhlIGZvbGxvd2luZyB0eXBlczogJHt0eXBlcy5qb2luKFwiLCBcIil9YCk7XG59XG5cbmV4cG9ydCB7IHJlcXVpcmVBcnJheSwgcmVxdWlyZUJpZ0ludCwgcmVxdWlyZUJpZ051bWJlciwgcmVxdWlyZUJpZ051bWJlcmlzaCwgcmVxdWlyZUJ1ZmZlciwgcmVxdWlyZURlZmluZWQsIHJlcXVpcmVGdW5jdGlvbiwgcmVxdWlyZUhleGFkZWNpbWFsLCByZXF1aXJlTnVtYmVyLCByZXF1aXJlT2JqZWN0LCByZXF1aXJlU3RyaW5nLCByZXF1aXJlU3RyaW5naWZpZWRCaWdJbnQsIHJlcXVpcmVUeXBlcywgcmVxdWlyZVVpbnQ4QXJyYXkgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@zk-kit/baby-jubjub/node_modules/@zk-kit/utils/dist/lib.esm/error-handlers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@zk-kit/baby-jubjub/node_modules/@zk-kit/utils/dist/lib.esm/f1-field.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@zk-kit/baby-jubjub/node_modules/@zk-kit/utils/dist/lib.esm/f1-field.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ F1Field)\n/* harmony export */ });\n/* harmony import */ var _scalar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scalar.js */ \"(ssr)/./node_modules/@zk-kit/baby-jubjub/node_modules/@zk-kit/utils/dist/lib.esm/scalar.js\");\n/**\n * @module @zk-kit/utils\n * @version 1.2.1\n * @file Essential zero-knowledge utility library for JavaScript developers.\n * @copyright Ethereum Foundation 2024\n * @license MIT\n * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/utils}\n*/\n\n\n/**\n * @class F1Field\n * Represents a finite field of order 'order' providing arithmetic operations under modulus.\n * This class includes operations such as addition, subtraction, multiplication, division,\n * and inversion, all performed modulo the field's order. It's designed to work with bigints,\n * supporting large numbers for cryptographic purposes and other applications requiring\n * modular arithmetic.\n * Note that the outputs of the functions will always be within the field if and only if\n * the input values are within the field. Devs need to make sure of that.\n *\n * @property one Represents the scalar value 1 in the field.\n * @property zero Represents the scalar value 0 in the field.\n * @property _order The order of the finite field (i.e., the modulus).\n * @property _half Half the order of the field, used for certain comparisons.\n * @property _negone The scalar value -1 in the field, represented positively.\n */\nclass F1Field {\n    constructor(order) {\n        this.one = 1n;\n        this.zero = 0n;\n        this._order = order;\n        this._half = order >> this.one;\n        this._negone = this._order - this.one;\n    }\n    /**\n     * Ensures a given result falls within the field by applying modular reduction.\n     * This method also handles negative inputs, correctly mapping them into the field.\n     * @param res The result to be normalized to the field.\n     * @returns The equivalent value within the field.\n     */\n    e(res) {\n        res %= this._order;\n        return res < 0 ? res + this._order : res;\n    }\n    /**\n     * Performs modular multiplication of two bigint values within the field.\n     * @param a The first value.\n     * @param b The second value.\n     * @returns The product of 'a' and 'b' modulo the field's order.\n     */\n    mul(a, b) {\n        return (a * b) % this._order;\n    }\n    /**\n     * Subtracts one bigint from another under modulus.\n     * It ensures the result is within the field if and only if the input values are within the field.\n     * @param a The value from which to subtract.\n     * @param b The value to be subtracted.\n     * @returns The difference of 'a' and 'b' modulo the field's order.\n     */\n    sub(a, b) {\n        return a >= b ? a - b : this._order - b + a;\n    }\n    /**\n     * Adds two bigint values together under modulus.\n     * It ensures the result is within the field if and only if the input values are within the field.\n     * @param a The first value.\n     * @param b The second value.\n     * @returns The sum of 'a' and 'b' modulo the field's order.\n     */\n    add(a, b) {\n        const res = a + b;\n        return res >= this._order ? res - this._order : res;\n    }\n    /**\n     * Computes the multiplicative inverse of a given value within the field.\n     * This method uses the Extended Euclidean Algorithm to find the inverse,\n     * ensuring the result is always a positive value less than the field's order.\n     * If the input value is zero, which has no inverse, an error is thrown.\n     * @param a The value for which to compute the inverse.\n     * @returns The multiplicative inverse of 'a' modulo the field's order.\n     * @throws if 'a' is zero.\n     */\n    inv(a) {\n        if (a === this.zero) {\n            throw new Error(\"Zero has no inverse\");\n        }\n        let t = this.zero;\n        let r = this._order;\n        let newt = this.one;\n        let newr = a % this._order;\n        while (newr) {\n            const q = r / newr;\n            [t, newt] = [newt, t - q * newt];\n            [r, newr] = [newr, r - q * newr];\n        }\n        if (t < this.zero) {\n            t += this._order;\n        }\n        return t;\n    }\n    /**\n     * Divides one bigint by another within the field by multiplying the first value\n     * by the multiplicative inverse of the second.\n     * @param a The dividend.\n     * @param b The divisor.\n     * @returns The result of the division of 'a' by 'b' modulo the field's order.\n     */\n    div(a, b) {\n        return this.mul(a, this.inv(b));\n    }\n    /**\n     * Checks if two bigint values are equal within the context of the field.\n     * It ensures the result is within the field if and only if the input values are within the field.\n     * @param a The first value to compare.\n     * @param b The second value to compare.\n     * @returns True if 'a' equals 'b', false otherwise.\n     */\n    eq(a, b) {\n        return a === b;\n    }\n    /**\n     * Squares a bigint value within the field.\n     * This is a specific case of multiplication where the value is multiplied by itself,\n     * optimized for performance where applicable.\n     * It ensures the result is within the field if and only if the input values are within the field.\n     * @param a The value to square.\n     * @returns The square of 'a' modulo the field's order.\n     */\n    square(a) {\n        return (a * a) % this._order;\n    }\n    /**\n     * Compares two bigint values to determine if the first is less than the second,\n     * taking into account the field's order for modular comparison.\n     * It ensures the result is within the field if and only if the input values are within the field.\n     * @param a The first value to compare.\n     * @param b The second value to compare.\n     * @returns True if 'a' is less than 'b', false otherwise.\n     */\n    lt(a, b) {\n        const aa = a > this._half ? a - this._order : a;\n        const bb = b > this._half ? b - this._order : b;\n        return aa < bb;\n    }\n    /**\n     * Compares two bigint values to determine if the first is greater than or equal to the second,\n     * considering the field's modular context.\n     * It ensures the result is within the field if and only if the input values are within the field.\n     * @param a The first value to compare.\n     * @param b The second value to compare.\n     * @returns True if 'a' is greater than or equal to 'b', false otherwise.\n     */\n    geq(a, b) {\n        const aa = a > this._half ? a - this._order : a;\n        const bb = b > this._half ? b - this._order : b;\n        return aa >= bb;\n    }\n    /**\n     * Computes the negation of a bigint value within the field.\n     * The result is the modular additive inverse that, when added to the original value,\n     * yields zero in the field's modulus.\n     * It ensures the result is within the field if and only if the input values are within the field.\n     * @param a The value to negate.\n     * @returns The negation of 'a' modulo the field's order.\n     */\n    neg(a) {\n        return a ? this._order - a : a;\n    }\n    /**\n     * Checks if a bigint value is zero within the context of the field.\n     * @param a The value to check.\n     * @returns True if 'a' is zero, false otherwise.\n     */\n    isZero(a) {\n        return a === this.zero;\n    }\n    /**\n     * Raises a base to an exponent within the field, efficiently computing\n     * scalar exponentiation using the square-and-multiply algorithm.\n     * Supports both positive and negative exponents through the use of the `inv` method for negatives.\n     * @param base The base to be exponentiated.\n     * @param e The exponent.\n     * @returns The result of raising 'base' to the power 'e' modulo the field's order.\n     */\n    pow(base, e) {\n        if ((0,_scalar_js__WEBPACK_IMPORTED_MODULE_0__.isZero)(e)) {\n            return this.one;\n        }\n        if (e < 0n) {\n            base = this.inv(base);\n            e = -e;\n        }\n        const n = (0,_scalar_js__WEBPACK_IMPORTED_MODULE_0__.bits)(e);\n        if (n.length === 0) {\n            return this.one;\n        }\n        let res = base;\n        for (let i = n.length - 2; i >= 0; i -= 1) {\n            res = this.square(res);\n            if (n[i]) {\n                res = this.mul(res, base);\n            }\n        }\n        return res;\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHprLWtpdC9iYWJ5LWp1Ymp1Yi9ub2RlX21vZHVsZXMvQHprLWtpdC91dGlscy9kaXN0L2xpYi5lc20vZjEtZmllbGQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtEQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnREFBSTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRThCIiwic291cmNlcyI6WyIvVXNlcnMvY2hhbmNlbWNhbGxpc3Rlci9Qcm9qZWN0cy96dXBhc3NodW50L25vZGVfbW9kdWxlcy9Aemsta2l0L2JhYnktanVianViL25vZGVfbW9kdWxlcy9Aemsta2l0L3V0aWxzL2Rpc3QvbGliLmVzbS9mMS1maWVsZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgQHprLWtpdC91dGlsc1xuICogQHZlcnNpb24gMS4yLjFcbiAqIEBmaWxlIEVzc2VudGlhbCB6ZXJvLWtub3dsZWRnZSB1dGlsaXR5IGxpYnJhcnkgZm9yIEphdmFTY3JpcHQgZGV2ZWxvcGVycy5cbiAqIEBjb3B5cmlnaHQgRXRoZXJldW0gRm91bmRhdGlvbiAyMDI0XG4gKiBAbGljZW5zZSBNSVRcbiAqIEBzZWUgW0dpdGh1Yl17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3ByaXZhY3ktc2NhbGluZy1leHBsb3JhdGlvbnMvemsta2l0L3RyZWUvbWFpbi9wYWNrYWdlcy91dGlsc31cbiovXG5pbXBvcnQgeyBpc1plcm8sIGJpdHMgfSBmcm9tICcuL3NjYWxhci5qcyc7XG5cbi8qKlxuICogQGNsYXNzIEYxRmllbGRcbiAqIFJlcHJlc2VudHMgYSBmaW5pdGUgZmllbGQgb2Ygb3JkZXIgJ29yZGVyJyBwcm92aWRpbmcgYXJpdGhtZXRpYyBvcGVyYXRpb25zIHVuZGVyIG1vZHVsdXMuXG4gKiBUaGlzIGNsYXNzIGluY2x1ZGVzIG9wZXJhdGlvbnMgc3VjaCBhcyBhZGRpdGlvbiwgc3VidHJhY3Rpb24sIG11bHRpcGxpY2F0aW9uLCBkaXZpc2lvbixcbiAqIGFuZCBpbnZlcnNpb24sIGFsbCBwZXJmb3JtZWQgbW9kdWxvIHRoZSBmaWVsZCdzIG9yZGVyLiBJdCdzIGRlc2lnbmVkIHRvIHdvcmsgd2l0aCBiaWdpbnRzLFxuICogc3VwcG9ydGluZyBsYXJnZSBudW1iZXJzIGZvciBjcnlwdG9ncmFwaGljIHB1cnBvc2VzIGFuZCBvdGhlciBhcHBsaWNhdGlvbnMgcmVxdWlyaW5nXG4gKiBtb2R1bGFyIGFyaXRobWV0aWMuXG4gKiBOb3RlIHRoYXQgdGhlIG91dHB1dHMgb2YgdGhlIGZ1bmN0aW9ucyB3aWxsIGFsd2F5cyBiZSB3aXRoaW4gdGhlIGZpZWxkIGlmIGFuZCBvbmx5IGlmXG4gKiB0aGUgaW5wdXQgdmFsdWVzIGFyZSB3aXRoaW4gdGhlIGZpZWxkLiBEZXZzIG5lZWQgdG8gbWFrZSBzdXJlIG9mIHRoYXQuXG4gKlxuICogQHByb3BlcnR5IG9uZSBSZXByZXNlbnRzIHRoZSBzY2FsYXIgdmFsdWUgMSBpbiB0aGUgZmllbGQuXG4gKiBAcHJvcGVydHkgemVybyBSZXByZXNlbnRzIHRoZSBzY2FsYXIgdmFsdWUgMCBpbiB0aGUgZmllbGQuXG4gKiBAcHJvcGVydHkgX29yZGVyIFRoZSBvcmRlciBvZiB0aGUgZmluaXRlIGZpZWxkIChpLmUuLCB0aGUgbW9kdWx1cykuXG4gKiBAcHJvcGVydHkgX2hhbGYgSGFsZiB0aGUgb3JkZXIgb2YgdGhlIGZpZWxkLCB1c2VkIGZvciBjZXJ0YWluIGNvbXBhcmlzb25zLlxuICogQHByb3BlcnR5IF9uZWdvbmUgVGhlIHNjYWxhciB2YWx1ZSAtMSBpbiB0aGUgZmllbGQsIHJlcHJlc2VudGVkIHBvc2l0aXZlbHkuXG4gKi9cbmNsYXNzIEYxRmllbGQge1xuICAgIGNvbnN0cnVjdG9yKG9yZGVyKSB7XG4gICAgICAgIHRoaXMub25lID0gMW47XG4gICAgICAgIHRoaXMuemVybyA9IDBuO1xuICAgICAgICB0aGlzLl9vcmRlciA9IG9yZGVyO1xuICAgICAgICB0aGlzLl9oYWxmID0gb3JkZXIgPj4gdGhpcy5vbmU7XG4gICAgICAgIHRoaXMuX25lZ29uZSA9IHRoaXMuX29yZGVyIC0gdGhpcy5vbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgYSBnaXZlbiByZXN1bHQgZmFsbHMgd2l0aGluIHRoZSBmaWVsZCBieSBhcHBseWluZyBtb2R1bGFyIHJlZHVjdGlvbi5cbiAgICAgKiBUaGlzIG1ldGhvZCBhbHNvIGhhbmRsZXMgbmVnYXRpdmUgaW5wdXRzLCBjb3JyZWN0bHkgbWFwcGluZyB0aGVtIGludG8gdGhlIGZpZWxkLlxuICAgICAqIEBwYXJhbSByZXMgVGhlIHJlc3VsdCB0byBiZSBub3JtYWxpemVkIHRvIHRoZSBmaWVsZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgZXF1aXZhbGVudCB2YWx1ZSB3aXRoaW4gdGhlIGZpZWxkLlxuICAgICAqL1xuICAgIGUocmVzKSB7XG4gICAgICAgIHJlcyAlPSB0aGlzLl9vcmRlcjtcbiAgICAgICAgcmV0dXJuIHJlcyA8IDAgPyByZXMgKyB0aGlzLl9vcmRlciA6IHJlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgbW9kdWxhciBtdWx0aXBsaWNhdGlvbiBvZiB0d28gYmlnaW50IHZhbHVlcyB3aXRoaW4gdGhlIGZpZWxkLlxuICAgICAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIFRoZSBwcm9kdWN0IG9mICdhJyBhbmQgJ2InIG1vZHVsbyB0aGUgZmllbGQncyBvcmRlci5cbiAgICAgKi9cbiAgICBtdWwoYSwgYikge1xuICAgICAgICByZXR1cm4gKGEgKiBiKSAlIHRoaXMuX29yZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgb25lIGJpZ2ludCBmcm9tIGFub3RoZXIgdW5kZXIgbW9kdWx1cy5cbiAgICAgKiBJdCBlbnN1cmVzIHRoZSByZXN1bHQgaXMgd2l0aGluIHRoZSBmaWVsZCBpZiBhbmQgb25seSBpZiB0aGUgaW5wdXQgdmFsdWVzIGFyZSB3aXRoaW4gdGhlIGZpZWxkLlxuICAgICAqIEBwYXJhbSBhIFRoZSB2YWx1ZSBmcm9tIHdoaWNoIHRvIHN1YnRyYWN0LlxuICAgICAqIEBwYXJhbSBiIFRoZSB2YWx1ZSB0byBiZSBzdWJ0cmFjdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBkaWZmZXJlbmNlIG9mICdhJyBhbmQgJ2InIG1vZHVsbyB0aGUgZmllbGQncyBvcmRlci5cbiAgICAgKi9cbiAgICBzdWIoYSwgYikge1xuICAgICAgICByZXR1cm4gYSA+PSBiID8gYSAtIGIgOiB0aGlzLl9vcmRlciAtIGIgKyBhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHR3byBiaWdpbnQgdmFsdWVzIHRvZ2V0aGVyIHVuZGVyIG1vZHVsdXMuXG4gICAgICogSXQgZW5zdXJlcyB0aGUgcmVzdWx0IGlzIHdpdGhpbiB0aGUgZmllbGQgaWYgYW5kIG9ubHkgaWYgdGhlIGlucHV0IHZhbHVlcyBhcmUgd2l0aGluIHRoZSBmaWVsZC5cbiAgICAgKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmFsdWUuXG4gICAgICogQHBhcmFtIGIgVGhlIHNlY29uZCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgc3VtIG9mICdhJyBhbmQgJ2InIG1vZHVsbyB0aGUgZmllbGQncyBvcmRlci5cbiAgICAgKi9cbiAgICBhZGQoYSwgYikge1xuICAgICAgICBjb25zdCByZXMgPSBhICsgYjtcbiAgICAgICAgcmV0dXJuIHJlcyA+PSB0aGlzLl9vcmRlciA/IHJlcyAtIHRoaXMuX29yZGVyIDogcmVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbXVsdGlwbGljYXRpdmUgaW52ZXJzZSBvZiBhIGdpdmVuIHZhbHVlIHdpdGhpbiB0aGUgZmllbGQuXG4gICAgICogVGhpcyBtZXRob2QgdXNlcyB0aGUgRXh0ZW5kZWQgRXVjbGlkZWFuIEFsZ29yaXRobSB0byBmaW5kIHRoZSBpbnZlcnNlLFxuICAgICAqIGVuc3VyaW5nIHRoZSByZXN1bHQgaXMgYWx3YXlzIGEgcG9zaXRpdmUgdmFsdWUgbGVzcyB0aGFuIHRoZSBmaWVsZCdzIG9yZGVyLlxuICAgICAqIElmIHRoZSBpbnB1dCB2YWx1ZSBpcyB6ZXJvLCB3aGljaCBoYXMgbm8gaW52ZXJzZSwgYW4gZXJyb3IgaXMgdGhyb3duLlxuICAgICAqIEBwYXJhbSBhIFRoZSB2YWx1ZSBmb3Igd2hpY2ggdG8gY29tcHV0ZSB0aGUgaW52ZXJzZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgbXVsdGlwbGljYXRpdmUgaW52ZXJzZSBvZiAnYScgbW9kdWxvIHRoZSBmaWVsZCdzIG9yZGVyLlxuICAgICAqIEB0aHJvd3MgaWYgJ2EnIGlzIHplcm8uXG4gICAgICovXG4gICAgaW52KGEpIHtcbiAgICAgICAgaWYgKGEgPT09IHRoaXMuemVybykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWmVybyBoYXMgbm8gaW52ZXJzZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdCA9IHRoaXMuemVybztcbiAgICAgICAgbGV0IHIgPSB0aGlzLl9vcmRlcjtcbiAgICAgICAgbGV0IG5ld3QgPSB0aGlzLm9uZTtcbiAgICAgICAgbGV0IG5ld3IgPSBhICUgdGhpcy5fb3JkZXI7XG4gICAgICAgIHdoaWxlIChuZXdyKSB7XG4gICAgICAgICAgICBjb25zdCBxID0gciAvIG5ld3I7XG4gICAgICAgICAgICBbdCwgbmV3dF0gPSBbbmV3dCwgdCAtIHEgKiBuZXd0XTtcbiAgICAgICAgICAgIFtyLCBuZXdyXSA9IFtuZXdyLCByIC0gcSAqIG5ld3JdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0IDwgdGhpcy56ZXJvKSB7XG4gICAgICAgICAgICB0ICs9IHRoaXMuX29yZGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIG9uZSBiaWdpbnQgYnkgYW5vdGhlciB3aXRoaW4gdGhlIGZpZWxkIGJ5IG11bHRpcGx5aW5nIHRoZSBmaXJzdCB2YWx1ZVxuICAgICAqIGJ5IHRoZSBtdWx0aXBsaWNhdGl2ZSBpbnZlcnNlIG9mIHRoZSBzZWNvbmQuXG4gICAgICogQHBhcmFtIGEgVGhlIGRpdmlkZW5kLlxuICAgICAqIEBwYXJhbSBiIFRoZSBkaXZpc29yLlxuICAgICAqIEByZXR1cm5zIFRoZSByZXN1bHQgb2YgdGhlIGRpdmlzaW9uIG9mICdhJyBieSAnYicgbW9kdWxvIHRoZSBmaWVsZCdzIG9yZGVyLlxuICAgICAqL1xuICAgIGRpdihhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm11bChhLCB0aGlzLmludihiKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0d28gYmlnaW50IHZhbHVlcyBhcmUgZXF1YWwgd2l0aGluIHRoZSBjb250ZXh0IG9mIHRoZSBmaWVsZC5cbiAgICAgKiBJdCBlbnN1cmVzIHRoZSByZXN1bHQgaXMgd2l0aGluIHRoZSBmaWVsZCBpZiBhbmQgb25seSBpZiB0aGUgaW5wdXQgdmFsdWVzIGFyZSB3aXRoaW4gdGhlIGZpZWxkLlxuICAgICAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmICdhJyBlcXVhbHMgJ2InLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZXEoYSwgYikge1xuICAgICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3F1YXJlcyBhIGJpZ2ludCB2YWx1ZSB3aXRoaW4gdGhlIGZpZWxkLlxuICAgICAqIFRoaXMgaXMgYSBzcGVjaWZpYyBjYXNlIG9mIG11bHRpcGxpY2F0aW9uIHdoZXJlIHRoZSB2YWx1ZSBpcyBtdWx0aXBsaWVkIGJ5IGl0c2VsZixcbiAgICAgKiBvcHRpbWl6ZWQgZm9yIHBlcmZvcm1hbmNlIHdoZXJlIGFwcGxpY2FibGUuXG4gICAgICogSXQgZW5zdXJlcyB0aGUgcmVzdWx0IGlzIHdpdGhpbiB0aGUgZmllbGQgaWYgYW5kIG9ubHkgaWYgdGhlIGlucHV0IHZhbHVlcyBhcmUgd2l0aGluIHRoZSBmaWVsZC5cbiAgICAgKiBAcGFyYW0gYSBUaGUgdmFsdWUgdG8gc3F1YXJlLlxuICAgICAqIEByZXR1cm5zIFRoZSBzcXVhcmUgb2YgJ2EnIG1vZHVsbyB0aGUgZmllbGQncyBvcmRlci5cbiAgICAgKi9cbiAgICBzcXVhcmUoYSkge1xuICAgICAgICByZXR1cm4gKGEgKiBhKSAlIHRoaXMuX29yZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyB0d28gYmlnaW50IHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhlIGZpcnN0IGlzIGxlc3MgdGhhbiB0aGUgc2Vjb25kLFxuICAgICAqIHRha2luZyBpbnRvIGFjY291bnQgdGhlIGZpZWxkJ3Mgb3JkZXIgZm9yIG1vZHVsYXIgY29tcGFyaXNvbi5cbiAgICAgKiBJdCBlbnN1cmVzIHRoZSByZXN1bHQgaXMgd2l0aGluIHRoZSBmaWVsZCBpZiBhbmQgb25seSBpZiB0aGUgaW5wdXQgdmFsdWVzIGFyZSB3aXRoaW4gdGhlIGZpZWxkLlxuICAgICAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmICdhJyBpcyBsZXNzIHRoYW4gJ2InLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgbHQoYSwgYikge1xuICAgICAgICBjb25zdCBhYSA9IGEgPiB0aGlzLl9oYWxmID8gYSAtIHRoaXMuX29yZGVyIDogYTtcbiAgICAgICAgY29uc3QgYmIgPSBiID4gdGhpcy5faGFsZiA/IGIgLSB0aGlzLl9vcmRlciA6IGI7XG4gICAgICAgIHJldHVybiBhYSA8IGJiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyB0d28gYmlnaW50IHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhlIGZpcnN0IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgc2Vjb25kLFxuICAgICAqIGNvbnNpZGVyaW5nIHRoZSBmaWVsZCdzIG1vZHVsYXIgY29udGV4dC5cbiAgICAgKiBJdCBlbnN1cmVzIHRoZSByZXN1bHQgaXMgd2l0aGluIHRoZSBmaWVsZCBpZiBhbmQgb25seSBpZiB0aGUgaW5wdXQgdmFsdWVzIGFyZSB3aXRoaW4gdGhlIGZpZWxkLlxuICAgICAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmICdhJyBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJ2InLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZ2VxKGEsIGIpIHtcbiAgICAgICAgY29uc3QgYWEgPSBhID4gdGhpcy5faGFsZiA/IGEgLSB0aGlzLl9vcmRlciA6IGE7XG4gICAgICAgIGNvbnN0IGJiID0gYiA+IHRoaXMuX2hhbGYgPyBiIC0gdGhpcy5fb3JkZXIgOiBiO1xuICAgICAgICByZXR1cm4gYWEgPj0gYmI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBuZWdhdGlvbiBvZiBhIGJpZ2ludCB2YWx1ZSB3aXRoaW4gdGhlIGZpZWxkLlxuICAgICAqIFRoZSByZXN1bHQgaXMgdGhlIG1vZHVsYXIgYWRkaXRpdmUgaW52ZXJzZSB0aGF0LCB3aGVuIGFkZGVkIHRvIHRoZSBvcmlnaW5hbCB2YWx1ZSxcbiAgICAgKiB5aWVsZHMgemVybyBpbiB0aGUgZmllbGQncyBtb2R1bHVzLlxuICAgICAqIEl0IGVuc3VyZXMgdGhlIHJlc3VsdCBpcyB3aXRoaW4gdGhlIGZpZWxkIGlmIGFuZCBvbmx5IGlmIHRoZSBpbnB1dCB2YWx1ZXMgYXJlIHdpdGhpbiB0aGUgZmllbGQuXG4gICAgICogQHBhcmFtIGEgVGhlIHZhbHVlIHRvIG5lZ2F0ZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgbmVnYXRpb24gb2YgJ2EnIG1vZHVsbyB0aGUgZmllbGQncyBvcmRlci5cbiAgICAgKi9cbiAgICBuZWcoYSkge1xuICAgICAgICByZXR1cm4gYSA/IHRoaXMuX29yZGVyIC0gYSA6IGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGJpZ2ludCB2YWx1ZSBpcyB6ZXJvIHdpdGhpbiB0aGUgY29udGV4dCBvZiB0aGUgZmllbGQuXG4gICAgICogQHBhcmFtIGEgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgJ2EnIGlzIHplcm8sIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc1plcm8oYSkge1xuICAgICAgICByZXR1cm4gYSA9PT0gdGhpcy56ZXJvO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSYWlzZXMgYSBiYXNlIHRvIGFuIGV4cG9uZW50IHdpdGhpbiB0aGUgZmllbGQsIGVmZmljaWVudGx5IGNvbXB1dGluZ1xuICAgICAqIHNjYWxhciBleHBvbmVudGlhdGlvbiB1c2luZyB0aGUgc3F1YXJlLWFuZC1tdWx0aXBseSBhbGdvcml0aG0uXG4gICAgICogU3VwcG9ydHMgYm90aCBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgZXhwb25lbnRzIHRocm91Z2ggdGhlIHVzZSBvZiB0aGUgYGludmAgbWV0aG9kIGZvciBuZWdhdGl2ZXMuXG4gICAgICogQHBhcmFtIGJhc2UgVGhlIGJhc2UgdG8gYmUgZXhwb25lbnRpYXRlZC5cbiAgICAgKiBAcGFyYW0gZSBUaGUgZXhwb25lbnQuXG4gICAgICogQHJldHVybnMgVGhlIHJlc3VsdCBvZiByYWlzaW5nICdiYXNlJyB0byB0aGUgcG93ZXIgJ2UnIG1vZHVsbyB0aGUgZmllbGQncyBvcmRlci5cbiAgICAgKi9cbiAgICBwb3coYmFzZSwgZSkge1xuICAgICAgICBpZiAoaXNaZXJvKGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbmU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUgPCAwbikge1xuICAgICAgICAgICAgYmFzZSA9IHRoaXMuaW52KGJhc2UpO1xuICAgICAgICAgICAgZSA9IC1lO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG4gPSBiaXRzKGUpO1xuICAgICAgICBpZiAobi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzID0gYmFzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IG4ubGVuZ3RoIC0gMjsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICAgIHJlcyA9IHRoaXMuc3F1YXJlKHJlcyk7XG4gICAgICAgICAgICBpZiAobltpXSkge1xuICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMubXVsKHJlcywgYmFzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG5cbmV4cG9ydCB7IEYxRmllbGQgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@zk-kit/baby-jubjub/node_modules/@zk-kit/utils/dist/lib.esm/f1-field.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@zk-kit/baby-jubjub/node_modules/@zk-kit/utils/dist/lib.esm/scalar.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@zk-kit/baby-jubjub/node_modules/@zk-kit/utils/dist/lib.esm/scalar.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bits: () => (/* binding */ bits),\n/* harmony export */   gt: () => (/* binding */ gt),\n/* harmony export */   isOdd: () => (/* binding */ isOdd),\n/* harmony export */   isZero: () => (/* binding */ isZero),\n/* harmony export */   mul: () => (/* binding */ mul),\n/* harmony export */   shiftRight: () => (/* binding */ shiftRight)\n/* harmony export */ });\n/**\n * @module @zk-kit/utils\n * @version 1.2.1\n * @file Essential zero-knowledge utility library for JavaScript developers.\n * @copyright Ethereum Foundation 2024\n * @license MIT\n * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/utils}\n*/\n/**\n * @module Scalar\n * This module provides utility functions for performing scalar operations\n * within a field, especially designed to handle operations on bigints.\n * The operations include scalar inversion (`inv`), scalar exponentiation (`pow`),\n * and modular reduction. Functions are carefully implemented to ensure\n * mathematical correctness and efficiency, supporting both positive and\n * negative bigint values. The module aims to provide robust tools for\n * cryptographic calculations and other applications requiring high-precision\n * arithmetic in fields.\n */\n/**\n * Checks if a bigint scalar value is zero.\n * @param a The bigint scalar value to check.\n * @returns True if 'a' is zero, false otherwise.\n */\nfunction isZero(a) {\n    return !a;\n}\n/**\n * Determines whether a bigint scalar value is odd.\n * @param a The bigint scalar value to check.\n * @returns True if 'a' is odd, false if it is even.\n */\nfunction isOdd(a) {\n    return (a & BigInt(1)) === BigInt(1);\n}\n/**\n * Performs a bitwise right shift on a bigint scalar value.\n * This operation is equivalent to dividing by 2^n, but it operates directly\n * on the binary representation, making it efficient for certain types of calculations.\n * @param a The bigint scalar value to shift.\n * @param n The number of bits to shift 'a' by.\n * @returns The result of shifting 'a' right by 'n' bits.\n */\nfunction shiftRight(a, n) {\n    return a >> n;\n}\n/**\n * Multiplies two bigint scalar values.\n * @param a The first bigint scalar value.\n * @param b The second bigint scalar value.\n * @returns The product of 'a' and 'b'.\n */\nfunction mul(a, b) {\n    return a * b;\n}\n/**\n * Compares two bigint scalar values to determine if the first is greater than the second.\n * @param a The first bigint scalar value to compare.\n * @param b The second bigint scalar value to compare.\n * @returns True if 'a' is greater than 'b', false otherwise.\n */\nfunction gt(a, b) {\n    return a > b;\n}\n/**\n * Converts a bigint scalar value into an array of bits, represented as numbers.\n * This function is particularly useful for examining the binary structure of bigints,\n * which can be necessary for bit manipulation and understanding the representation\n * of numbers at a lower level.\n * @param n The bigint scalar value to convert into bits.\n * @returns An array of numbers representing the bits of 'n', starting from the least significant bit.\n */\nfunction bits(n) {\n    const res = [];\n    let E = n;\n    while (E) {\n        if (E & BigInt(1)) {\n            res.push(1);\n        }\n        else {\n            res.push(0);\n        }\n        E >>= BigInt(1);\n    }\n    return res;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHprLWtpdC9iYWJ5LWp1Ymp1Yi9ub2RlX21vZHVsZXMvQHprLWtpdC91dGlscy9kaXN0L2xpYi5lc20vc2NhbGFyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFb0QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jaGFuY2VtY2FsbGlzdGVyL1Byb2plY3RzL3p1cGFzc2h1bnQvbm9kZV9tb2R1bGVzL0B6ay1raXQvYmFieS1qdWJqdWIvbm9kZV9tb2R1bGVzL0B6ay1raXQvdXRpbHMvZGlzdC9saWIuZXNtL3NjYWxhci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgQHprLWtpdC91dGlsc1xuICogQHZlcnNpb24gMS4yLjFcbiAqIEBmaWxlIEVzc2VudGlhbCB6ZXJvLWtub3dsZWRnZSB1dGlsaXR5IGxpYnJhcnkgZm9yIEphdmFTY3JpcHQgZGV2ZWxvcGVycy5cbiAqIEBjb3B5cmlnaHQgRXRoZXJldW0gRm91bmRhdGlvbiAyMDI0XG4gKiBAbGljZW5zZSBNSVRcbiAqIEBzZWUgW0dpdGh1Yl17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3ByaXZhY3ktc2NhbGluZy1leHBsb3JhdGlvbnMvemsta2l0L3RyZWUvbWFpbi9wYWNrYWdlcy91dGlsc31cbiovXG4vKipcbiAqIEBtb2R1bGUgU2NhbGFyXG4gKiBUaGlzIG1vZHVsZSBwcm92aWRlcyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgcGVyZm9ybWluZyBzY2FsYXIgb3BlcmF0aW9uc1xuICogd2l0aGluIGEgZmllbGQsIGVzcGVjaWFsbHkgZGVzaWduZWQgdG8gaGFuZGxlIG9wZXJhdGlvbnMgb24gYmlnaW50cy5cbiAqIFRoZSBvcGVyYXRpb25zIGluY2x1ZGUgc2NhbGFyIGludmVyc2lvbiAoYGludmApLCBzY2FsYXIgZXhwb25lbnRpYXRpb24gKGBwb3dgKSxcbiAqIGFuZCBtb2R1bGFyIHJlZHVjdGlvbi4gRnVuY3Rpb25zIGFyZSBjYXJlZnVsbHkgaW1wbGVtZW50ZWQgdG8gZW5zdXJlXG4gKiBtYXRoZW1hdGljYWwgY29ycmVjdG5lc3MgYW5kIGVmZmljaWVuY3ksIHN1cHBvcnRpbmcgYm90aCBwb3NpdGl2ZSBhbmRcbiAqIG5lZ2F0aXZlIGJpZ2ludCB2YWx1ZXMuIFRoZSBtb2R1bGUgYWltcyB0byBwcm92aWRlIHJvYnVzdCB0b29scyBmb3JcbiAqIGNyeXB0b2dyYXBoaWMgY2FsY3VsYXRpb25zIGFuZCBvdGhlciBhcHBsaWNhdGlvbnMgcmVxdWlyaW5nIGhpZ2gtcHJlY2lzaW9uXG4gKiBhcml0aG1ldGljIGluIGZpZWxkcy5cbiAqL1xuLyoqXG4gKiBDaGVja3MgaWYgYSBiaWdpbnQgc2NhbGFyIHZhbHVlIGlzIHplcm8uXG4gKiBAcGFyYW0gYSBUaGUgYmlnaW50IHNjYWxhciB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFRydWUgaWYgJ2EnIGlzIHplcm8sIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNaZXJvKGEpIHtcbiAgICByZXR1cm4gIWE7XG59XG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhIGJpZ2ludCBzY2FsYXIgdmFsdWUgaXMgb2RkLlxuICogQHBhcmFtIGEgVGhlIGJpZ2ludCBzY2FsYXIgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBUcnVlIGlmICdhJyBpcyBvZGQsIGZhbHNlIGlmIGl0IGlzIGV2ZW4uXG4gKi9cbmZ1bmN0aW9uIGlzT2RkKGEpIHtcbiAgICByZXR1cm4gKGEgJiBCaWdJbnQoMSkpID09PSBCaWdJbnQoMSk7XG59XG4vKipcbiAqIFBlcmZvcm1zIGEgYml0d2lzZSByaWdodCBzaGlmdCBvbiBhIGJpZ2ludCBzY2FsYXIgdmFsdWUuXG4gKiBUaGlzIG9wZXJhdGlvbiBpcyBlcXVpdmFsZW50IHRvIGRpdmlkaW5nIGJ5IDJebiwgYnV0IGl0IG9wZXJhdGVzIGRpcmVjdGx5XG4gKiBvbiB0aGUgYmluYXJ5IHJlcHJlc2VudGF0aW9uLCBtYWtpbmcgaXQgZWZmaWNpZW50IGZvciBjZXJ0YWluIHR5cGVzIG9mIGNhbGN1bGF0aW9ucy5cbiAqIEBwYXJhbSBhIFRoZSBiaWdpbnQgc2NhbGFyIHZhbHVlIHRvIHNoaWZ0LlxuICogQHBhcmFtIG4gVGhlIG51bWJlciBvZiBiaXRzIHRvIHNoaWZ0ICdhJyBieS5cbiAqIEByZXR1cm5zIFRoZSByZXN1bHQgb2Ygc2hpZnRpbmcgJ2EnIHJpZ2h0IGJ5ICduJyBiaXRzLlxuICovXG5mdW5jdGlvbiBzaGlmdFJpZ2h0KGEsIG4pIHtcbiAgICByZXR1cm4gYSA+PiBuO1xufVxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBiaWdpbnQgc2NhbGFyIHZhbHVlcy5cbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCBiaWdpbnQgc2NhbGFyIHZhbHVlLlxuICogQHBhcmFtIGIgVGhlIHNlY29uZCBiaWdpbnQgc2NhbGFyIHZhbHVlLlxuICogQHJldHVybnMgVGhlIHByb2R1Y3Qgb2YgJ2EnIGFuZCAnYicuXG4gKi9cbmZ1bmN0aW9uIG11bChhLCBiKSB7XG4gICAgcmV0dXJuIGEgKiBiO1xufVxuLyoqXG4gKiBDb21wYXJlcyB0d28gYmlnaW50IHNjYWxhciB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZSBmaXJzdCBpcyBncmVhdGVyIHRoYW4gdGhlIHNlY29uZC5cbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCBiaWdpbnQgc2NhbGFyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0gYiBUaGUgc2Vjb25kIGJpZ2ludCBzY2FsYXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIFRydWUgaWYgJ2EnIGlzIGdyZWF0ZXIgdGhhbiAnYicsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gZ3QoYSwgYikge1xuICAgIHJldHVybiBhID4gYjtcbn1cbi8qKlxuICogQ29udmVydHMgYSBiaWdpbnQgc2NhbGFyIHZhbHVlIGludG8gYW4gYXJyYXkgb2YgYml0cywgcmVwcmVzZW50ZWQgYXMgbnVtYmVycy5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3IgZXhhbWluaW5nIHRoZSBiaW5hcnkgc3RydWN0dXJlIG9mIGJpZ2ludHMsXG4gKiB3aGljaCBjYW4gYmUgbmVjZXNzYXJ5IGZvciBiaXQgbWFuaXB1bGF0aW9uIGFuZCB1bmRlcnN0YW5kaW5nIHRoZSByZXByZXNlbnRhdGlvblxuICogb2YgbnVtYmVycyBhdCBhIGxvd2VyIGxldmVsLlxuICogQHBhcmFtIG4gVGhlIGJpZ2ludCBzY2FsYXIgdmFsdWUgdG8gY29udmVydCBpbnRvIGJpdHMuXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBudW1iZXJzIHJlcHJlc2VudGluZyB0aGUgYml0cyBvZiAnbicsIHN0YXJ0aW5nIGZyb20gdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdC5cbiAqL1xuZnVuY3Rpb24gYml0cyhuKSB7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgbGV0IEUgPSBuO1xuICAgIHdoaWxlIChFKSB7XG4gICAgICAgIGlmIChFICYgQmlnSW50KDEpKSB7XG4gICAgICAgICAgICByZXMucHVzaCgxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICAgIEUgPj49IEJpZ0ludCgxKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuZXhwb3J0IHsgYml0cywgZ3QsIGlzT2RkLCBpc1plcm8sIG11bCwgc2hpZnRSaWdodCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@zk-kit/baby-jubjub/node_modules/@zk-kit/utils/dist/lib.esm/scalar.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@zk-kit/baby-jubjub/node_modules/@zk-kit/utils/dist/lib.esm/type-checks.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@zk-kit/baby-jubjub/node_modules/@zk-kit/utils/dist/lib.esm/type-checks.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isArray: () => (/* binding */ isArray),\n/* harmony export */   isBigInt: () => (/* binding */ isBigInt),\n/* harmony export */   isBigNumber: () => (/* binding */ isBigNumber),\n/* harmony export */   isBigNumberish: () => (/* binding */ isBigNumberish),\n/* harmony export */   isBuffer: () => (/* binding */ isBuffer),\n/* harmony export */   isDefined: () => (/* binding */ isDefined),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isHexadecimal: () => (/* binding */ isHexadecimal),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   isStringifiedBigInt: () => (/* binding */ isStringifiedBigInt),\n/* harmony export */   isSupportedType: () => (/* binding */ isSupportedType),\n/* harmony export */   isType: () => (/* binding */ isType),\n/* harmony export */   isUint8Array: () => (/* binding */ isUint8Array),\n/* harmony export */   supportedTypes: () => (/* binding */ supportedTypes)\n/* harmony export */ });\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ \"buffer\");\n/**\n * @module @zk-kit/utils\n * @version 1.2.1\n * @file Essential zero-knowledge utility library for JavaScript developers.\n * @copyright Ethereum Foundation 2024\n * @license MIT\n * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/utils}\n*/\n\n\n/**\n * @module TypeChecks\n * This module provides utility functions to check data types.\n * It defines a set of supported types and includes functions to check if\n * a value is defined and if it matches a supported type. These functions\n * are useful for type checking and validation in the other libraries,\n * enhancing code robustness and reliability.\n */\n/** @internal */\nconst supportedTypes = [\n    \"number\",\n    \"string\",\n    \"function\",\n    \"Array\",\n    \"Uint8Array\",\n    \"Buffer\",\n    \"object\",\n    \"bigint\",\n    \"stringified-bigint\",\n    \"hexadecimal\",\n    \"bignumber\",\n    \"bignumberish\"\n];\n/**\n * Returns true if the value is defined, false otherwise.\n * @param value The value to be checked.\n */\nfunction isDefined(value) {\n    return typeof value !== \"undefined\";\n}\n/**\n * Returns true if the value is a number, false otherwise.\n * @param value The value to be checked.\n */\nfunction isNumber(value) {\n    return typeof value === \"number\";\n}\n/**\n * Returns true if the value is a string, false otherwise.\n * @param value The value to be checked.\n */\nfunction isString(value) {\n    return typeof value === \"string\";\n}\n/**\n * Returns true if the value is a function, false otherwise.\n * @param value The value to be checked.\n */\nfunction isFunction(value) {\n    return typeof value === \"function\";\n}\n/**\n * Returns true if the value is an object, false otherwise.\n * Please, note that arrays are also objects in JavaScript.\n * @param value The value to be checked.\n */\nfunction isObject(value) {\n    return typeof value === \"object\";\n}\n/**\n * Returns true if the value is an Array instance, false otherwise.\n * @param value The value to be checked.\n */\nfunction isArray(value) {\n    return isObject(value) && Array.isArray(value);\n}\n/**\n * Returns true if the value is a Uint8Array instance, false otherwise.\n * @param value The value to be checked.\n */\nfunction isUint8Array(value) {\n    return value instanceof Uint8Array;\n}\n/**\n * Returns true if the value is a Buffer instance, false otherwise.\n * @param value The value to be checked.\n */\nfunction isBuffer(value) {\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.isBuffer(value);\n}\n/**\n * Returns true if the value is a bigint, false otherwise.\n * @param value The value to be checked.\n */\nfunction isBigInt(value) {\n    return typeof value === \"bigint\";\n}\n/**\n * Checks if the given value is a string that represents a valid bigint.\n * @param value The value to be checked if it's a stringified bigint.\n */\nfunction isStringifiedBigInt(value) {\n    // Check if value is a string first.\n    if (!isString(value)) {\n        return false;\n    }\n    try {\n        // Attempt to convert the string to BigInt.\n        BigInt(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Checks if a string is a valid hexadecimal string representation.\n * If 'prefix' is 'true', the string must start with '0x' or '0X' followed by one or more\n * hexadecimal digits (0-9, a-f, A-F), otherwise no prefix is expected. 'prefix' is optional and\n * if its value it is not explicitly defined it will be set to 'true' by default.\n * @param value The string to be tested.\n * @param prefix A boolean to include or not a '0x' or '0X' prefix.\n */\nfunction isHexadecimal(value, prefix = true) {\n    if (!isString(value)) {\n        return false;\n    }\n    if (prefix) {\n        return /^(0x|0X)[0-9a-fA-F]+$/.test(value);\n    }\n    return /^[0-9a-fA-F]+$/.test(value);\n}\n/**\n * Checks if the given value can be considered as BigNumber.\n * A value is considered a BigNumber if it is a bigint or a string\n * that can be converted to a bigint (via `Bigint(s)`).\n * @param value The value to check.\n */\nfunction isBigNumber(value) {\n    return isBigInt(value) || isStringifiedBigInt(value);\n}\n/**\n * Checks if the given value can be considered as BigNumberish.\n * A value is considered BigNumberish if it meets\n * any of the following conditions: it's a number, a bigint, a string\n * that can be converted to a bigint, a hexadecimal\n * string, or a Buffer object.\n * @param value The value to check.\n */\nfunction isBigNumberish(value) {\n    return (isNumber(value) ||\n        isBigInt(value) ||\n        isStringifiedBigInt(value) ||\n        isHexadecimal(value) ||\n        isBuffer(value) ||\n        isUint8Array(value));\n}\n/**\n * Returns true if the value type is the same as the type passed\n * as the second parameter, false otherwise.\n * @param value\n * @param type The expected type.\n */\nfunction isType(value, type) {\n    switch (type) {\n        case \"number\":\n            return isNumber(value);\n        case \"string\":\n            return isString(value);\n        case \"function\":\n            return isFunction(value);\n        case \"Array\":\n            return isArray(value);\n        case \"Uint8Array\":\n            return isUint8Array(value);\n        case \"Buffer\":\n            return isBuffer(value);\n        case \"object\":\n            return isObject(value);\n        case \"bigint\":\n            return isBigInt(value);\n        case \"stringified-bigint\":\n            return isStringifiedBigInt(value);\n        case \"hexadecimal\":\n            return isHexadecimal(value);\n        case \"bignumber\":\n            return isBigNumber(value);\n        case \"bignumberish\":\n            return isBigNumberish(value);\n        default:\n            return false;\n    }\n}\n/**\n * Returns true if the type is being supported by this utility\n * functions, false otherwise.\n * @param type The type to be checked.\n */\nfunction isSupportedType(type) {\n    return supportedTypes.includes(type);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHprLWtpdC9iYWJ5LWp1Ymp1Yi9ub2RlX21vZHVsZXMvQHprLWtpdC91dGlscy9kaXN0L2xpYi5lc20vdHlwZS1jaGVja3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMENBQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW9OIiwic291cmNlcyI6WyIvVXNlcnMvY2hhbmNlbWNhbGxpc3Rlci9Qcm9qZWN0cy96dXBhc3NodW50L25vZGVfbW9kdWxlcy9Aemsta2l0L2JhYnktanVianViL25vZGVfbW9kdWxlcy9Aemsta2l0L3V0aWxzL2Rpc3QvbGliLmVzbS90eXBlLWNoZWNrcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgQHprLWtpdC91dGlsc1xuICogQHZlcnNpb24gMS4yLjFcbiAqIEBmaWxlIEVzc2VudGlhbCB6ZXJvLWtub3dsZWRnZSB1dGlsaXR5IGxpYnJhcnkgZm9yIEphdmFTY3JpcHQgZGV2ZWxvcGVycy5cbiAqIEBjb3B5cmlnaHQgRXRoZXJldW0gRm91bmRhdGlvbiAyMDI0XG4gKiBAbGljZW5zZSBNSVRcbiAqIEBzZWUgW0dpdGh1Yl17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3ByaXZhY3ktc2NhbGluZy1leHBsb3JhdGlvbnMvemsta2l0L3RyZWUvbWFpbi9wYWNrYWdlcy91dGlsc31cbiovXG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXInO1xuXG4vKipcbiAqIEBtb2R1bGUgVHlwZUNoZWNrc1xuICogVGhpcyBtb2R1bGUgcHJvdmlkZXMgdXRpbGl0eSBmdW5jdGlvbnMgdG8gY2hlY2sgZGF0YSB0eXBlcy5cbiAqIEl0IGRlZmluZXMgYSBzZXQgb2Ygc3VwcG9ydGVkIHR5cGVzIGFuZCBpbmNsdWRlcyBmdW5jdGlvbnMgdG8gY2hlY2sgaWZcbiAqIGEgdmFsdWUgaXMgZGVmaW5lZCBhbmQgaWYgaXQgbWF0Y2hlcyBhIHN1cHBvcnRlZCB0eXBlLiBUaGVzZSBmdW5jdGlvbnNcbiAqIGFyZSB1c2VmdWwgZm9yIHR5cGUgY2hlY2tpbmcgYW5kIHZhbGlkYXRpb24gaW4gdGhlIG90aGVyIGxpYnJhcmllcyxcbiAqIGVuaGFuY2luZyBjb2RlIHJvYnVzdG5lc3MgYW5kIHJlbGlhYmlsaXR5LlxuICovXG4vKiogQGludGVybmFsICovXG5jb25zdCBzdXBwb3J0ZWRUeXBlcyA9IFtcbiAgICBcIm51bWJlclwiLFxuICAgIFwic3RyaW5nXCIsXG4gICAgXCJmdW5jdGlvblwiLFxuICAgIFwiQXJyYXlcIixcbiAgICBcIlVpbnQ4QXJyYXlcIixcbiAgICBcIkJ1ZmZlclwiLFxuICAgIFwib2JqZWN0XCIsXG4gICAgXCJiaWdpbnRcIixcbiAgICBcInN0cmluZ2lmaWVkLWJpZ2ludFwiLFxuICAgIFwiaGV4YWRlY2ltYWxcIixcbiAgICBcImJpZ251bWJlclwiLFxuICAgIFwiYmlnbnVtYmVyaXNoXCJcbl07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgZGVmaW5lZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICovXG5mdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGlzIGEgbnVtYmVyLCBmYWxzZSBvdGhlcndpc2UuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIjtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZywgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBmdW5jdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogUGxlYXNlLCBub3RlIHRoYXQgYXJyYXlzIGFyZSBhbHNvIG9iamVjdHMgaW4gSmF2YVNjcmlwdC5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGlzIGFuIEFycmF5IGluc3RhbmNlLCBmYWxzZSBvdGhlcndpc2UuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIEFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGlzIGEgVWludDhBcnJheSBpbnN0YW5jZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICovXG5mdW5jdGlvbiBpc1VpbnQ4QXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGlzIGEgQnVmZmVyIGluc3RhbmNlLCBmYWxzZSBvdGhlcndpc2UuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKi9cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSk7XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBiaWdpbnQsIGZhbHNlIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqL1xuZnVuY3Rpb24gaXNCaWdJbnQodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBhIHZhbGlkIGJpZ2ludC5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgY2hlY2tlZCBpZiBpdCdzIGEgc3RyaW5naWZpZWQgYmlnaW50LlxuICovXG5mdW5jdGlvbiBpc1N0cmluZ2lmaWVkQmlnSW50KHZhbHVlKSB7XG4gICAgLy8gQ2hlY2sgaWYgdmFsdWUgaXMgYSBzdHJpbmcgZmlyc3QuXG4gICAgaWYgKCFpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyBBdHRlbXB0IHRvIGNvbnZlcnQgdGhlIHN0cmluZyB0byBCaWdJbnQuXG4gICAgICAgIEJpZ0ludCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIENoZWNrcyBpZiBhIHN0cmluZyBpcyBhIHZhbGlkIGhleGFkZWNpbWFsIHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAqIElmICdwcmVmaXgnIGlzICd0cnVlJywgdGhlIHN0cmluZyBtdXN0IHN0YXJ0IHdpdGggJzB4JyBvciAnMFgnIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlXG4gKiBoZXhhZGVjaW1hbCBkaWdpdHMgKDAtOSwgYS1mLCBBLUYpLCBvdGhlcndpc2Ugbm8gcHJlZml4IGlzIGV4cGVjdGVkLiAncHJlZml4JyBpcyBvcHRpb25hbCBhbmRcbiAqIGlmIGl0cyB2YWx1ZSBpdCBpcyBub3QgZXhwbGljaXRseSBkZWZpbmVkIGl0IHdpbGwgYmUgc2V0IHRvICd0cnVlJyBieSBkZWZhdWx0LlxuICogQHBhcmFtIHZhbHVlIFRoZSBzdHJpbmcgdG8gYmUgdGVzdGVkLlxuICogQHBhcmFtIHByZWZpeCBBIGJvb2xlYW4gdG8gaW5jbHVkZSBvciBub3QgYSAnMHgnIG9yICcwWCcgcHJlZml4LlxuICovXG5mdW5jdGlvbiBpc0hleGFkZWNpbWFsKHZhbHVlLCBwcmVmaXggPSB0cnVlKSB7XG4gICAgaWYgKCFpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAocHJlZml4KSB7XG4gICAgICAgIHJldHVybiAvXigweHwwWClbMC05YS1mQS1GXSskLy50ZXN0KHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIC9eWzAtOWEtZkEtRl0rJC8udGVzdCh2YWx1ZSk7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgY2FuIGJlIGNvbnNpZGVyZWQgYXMgQmlnTnVtYmVyLlxuICogQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGEgQmlnTnVtYmVyIGlmIGl0IGlzIGEgYmlnaW50IG9yIGEgc3RyaW5nXG4gKiB0aGF0IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYSBiaWdpbnQgKHZpYSBgQmlnaW50KHMpYCkuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICovXG5mdW5jdGlvbiBpc0JpZ051bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiBpc0JpZ0ludCh2YWx1ZSkgfHwgaXNTdHJpbmdpZmllZEJpZ0ludCh2YWx1ZSk7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgY2FuIGJlIGNvbnNpZGVyZWQgYXMgQmlnTnVtYmVyaXNoLlxuICogQSB2YWx1ZSBpcyBjb25zaWRlcmVkIEJpZ051bWJlcmlzaCBpZiBpdCBtZWV0c1xuICogYW55IG9mIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczogaXQncyBhIG51bWJlciwgYSBiaWdpbnQsIGEgc3RyaW5nXG4gKiB0aGF0IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYSBiaWdpbnQsIGEgaGV4YWRlY2ltYWxcbiAqIHN0cmluZywgb3IgYSBCdWZmZXIgb2JqZWN0LlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqL1xuZnVuY3Rpb24gaXNCaWdOdW1iZXJpc2godmFsdWUpIHtcbiAgICByZXR1cm4gKGlzTnVtYmVyKHZhbHVlKSB8fFxuICAgICAgICBpc0JpZ0ludCh2YWx1ZSkgfHxcbiAgICAgICAgaXNTdHJpbmdpZmllZEJpZ0ludCh2YWx1ZSkgfHxcbiAgICAgICAgaXNIZXhhZGVjaW1hbCh2YWx1ZSkgfHxcbiAgICAgICAgaXNCdWZmZXIodmFsdWUpIHx8XG4gICAgICAgIGlzVWludDhBcnJheSh2YWx1ZSkpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIHR5cGUgaXMgdGhlIHNhbWUgYXMgdGhlIHR5cGUgcGFzc2VkXG4gKiBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHBhcmFtIHZhbHVlXG4gKiBAcGFyYW0gdHlwZSBUaGUgZXhwZWN0ZWQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaXNUeXBlKHZhbHVlLCB0eXBlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIHJldHVybiBpc051bWJlcih2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBpc1N0cmluZyh2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24odmFsdWUpO1xuICAgICAgICBjYXNlIFwiQXJyYXlcIjpcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKTtcbiAgICAgICAgY2FzZSBcIlVpbnQ4QXJyYXlcIjpcbiAgICAgICAgICAgIHJldHVybiBpc1VpbnQ4QXJyYXkodmFsdWUpO1xuICAgICAgICBjYXNlIFwiQnVmZmVyXCI6XG4gICAgICAgICAgICByZXR1cm4gaXNCdWZmZXIodmFsdWUpO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpO1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgICAgICByZXR1cm4gaXNCaWdJbnQodmFsdWUpO1xuICAgICAgICBjYXNlIFwic3RyaW5naWZpZWQtYmlnaW50XCI6XG4gICAgICAgICAgICByZXR1cm4gaXNTdHJpbmdpZmllZEJpZ0ludCh2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJoZXhhZGVjaW1hbFwiOlxuICAgICAgICAgICAgcmV0dXJuIGlzSGV4YWRlY2ltYWwodmFsdWUpO1xuICAgICAgICBjYXNlIFwiYmlnbnVtYmVyXCI6XG4gICAgICAgICAgICByZXR1cm4gaXNCaWdOdW1iZXIodmFsdWUpO1xuICAgICAgICBjYXNlIFwiYmlnbnVtYmVyaXNoXCI6XG4gICAgICAgICAgICByZXR1cm4gaXNCaWdOdW1iZXJpc2godmFsdWUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB0eXBlIGlzIGJlaW5nIHN1cHBvcnRlZCBieSB0aGlzIHV0aWxpdHlcbiAqIGZ1bmN0aW9ucywgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgdG8gYmUgY2hlY2tlZC5cbiAqL1xuZnVuY3Rpb24gaXNTdXBwb3J0ZWRUeXBlKHR5cGUpIHtcbiAgICByZXR1cm4gc3VwcG9ydGVkVHlwZXMuaW5jbHVkZXModHlwZSk7XG59XG5cbmV4cG9ydCB7IGlzQXJyYXksIGlzQmlnSW50LCBpc0JpZ051bWJlciwgaXNCaWdOdW1iZXJpc2gsIGlzQnVmZmVyLCBpc0RlZmluZWQsIGlzRnVuY3Rpb24sIGlzSGV4YWRlY2ltYWwsIGlzTnVtYmVyLCBpc09iamVjdCwgaXNTdHJpbmcsIGlzU3RyaW5naWZpZWRCaWdJbnQsIGlzU3VwcG9ydGVkVHlwZSwgaXNUeXBlLCBpc1VpbnQ4QXJyYXksIHN1cHBvcnRlZFR5cGVzIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@zk-kit/baby-jubjub/node_modules/@zk-kit/utils/dist/lib.esm/type-checks.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@zk-kit/eddsa-poseidon/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@zk-kit/eddsa-poseidon/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EdDSAPoseidon: () => (/* binding */ EdDSAPoseidon),\n/* harmony export */   derivePublicKey: () => (/* binding */ derivePublicKey),\n/* harmony export */   deriveSecretScalar: () => (/* binding */ deriveSecretScalar),\n/* harmony export */   packPublicKey: () => (/* binding */ packPublicKey),\n/* harmony export */   packSignature: () => (/* binding */ packSignature),\n/* harmony export */   signMessage: () => (/* binding */ signMessage),\n/* harmony export */   unpackPublicKey: () => (/* binding */ unpackPublicKey),\n/* harmony export */   unpackSignature: () => (/* binding */ unpackSignature),\n/* harmony export */   verifySignature: () => (/* binding */ verifySignature)\n/* harmony export */ });\n/* harmony import */ var _zk_kit_baby_jubjub__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zk-kit/baby-jubjub */ \"(ssr)/./node_modules/@zk-kit/baby-jubjub/dist/index.js\");\n/* harmony import */ var _zk_kit_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @zk-kit/utils */ \"(ssr)/./node_modules/@zk-kit/eddsa-poseidon/node_modules/@zk-kit/utils/dist/index.node.js\");\n/* harmony import */ var _zk_kit_utils_conversions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @zk-kit/utils/conversions */ \"(ssr)/./node_modules/@zk-kit/eddsa-poseidon/node_modules/@zk-kit/utils/dist/lib.esm/conversions.js\");\n/* harmony import */ var _zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @zk-kit/utils/error-handlers */ \"(ssr)/./node_modules/@zk-kit/eddsa-poseidon/node_modules/@zk-kit/utils/dist/lib.esm/error-handlers.js\");\n/* harmony import */ var _zk_kit_utils_f1_field__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @zk-kit/utils/f1-field */ \"(ssr)/./node_modules/@zk-kit/eddsa-poseidon/node_modules/@zk-kit/utils/dist/lib.esm/f1-field.js\");\n/* harmony import */ var _zk_kit_utils_scalar__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @zk-kit/utils/scalar */ \"(ssr)/./node_modules/@zk-kit/eddsa-poseidon/node_modules/@zk-kit/utils/dist/lib.esm/scalar.js\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var poseidon_lite_poseidon5__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! poseidon-lite/poseidon5 */ \"(ssr)/./node_modules/poseidon-lite/poseidon5.js\");\n/* harmony import */ var _zk_kit_utils_type_checks__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @zk-kit/utils/type-checks */ \"(ssr)/./node_modules/@zk-kit/eddsa-poseidon/node_modules/@zk-kit/utils/dist/lib.esm/type-checks.js\");\n/**\n * @module @zk-kit/eddsa-poseidon\n * @version 1.0.4\n * @file A JavaScript EdDSA library for secure signing and verification using Poseidon the Baby Jubjub elliptic curve.\n * @copyright Ethereum Foundation 2024\n * @license MIT\n * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/eddsa-poseidon}\n*/\n\n\n\n\n\n\n\n\n\n\n/**\n * Copyright\n * This code is a TypeScript adaptation of the 'blake-hash' library code (https://www.npmjs.com/package/blake-hash)\n * using the 'buffer' npm package (https://www.npmjs.com/package/buffer).\n * The 'js-crypto' library (https://github.com/iden3/js-crypto/blob/main/src/blake.ts) from Iden3 was used as a reference\n * for this work, specifically for types and adaptation.\n */\n/**\n * @module Blake\n * Implements the Blake-512 cryptographic hash function.\n * Blake-512 is part of the BLAKE family of cryptographic hash functions, known\n * for its speed and security. This module offers functionality to compute Blake-512\n * hashes of input data, providing both one-time hashing capabilities and incremental\n * hashing to process large or streaming data.\n *\n * This code is adapted from the \"blake-hash\" JavaScript library, ensuring compatibility\n * and performance in TypeScript environments. It supports hashing with optional\n * salt for enhanced security in certain contexts.\n */\nconst zo = buffer__WEBPACK_IMPORTED_MODULE_6__.Buffer.from([0x01]);\nconst oo = buffer__WEBPACK_IMPORTED_MODULE_6__.Buffer.from([0x81]);\n// Static properties for sigma, u256, u512, and padding are defined here below\nconst sigma = [\n    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n    [14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3],\n    [11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4],\n    [7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8],\n    [9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13],\n    [2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9],\n    [12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11],\n    [13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10],\n    [6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5],\n    [10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0],\n    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n    [14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3],\n    [11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4],\n    [7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8],\n    [9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13],\n    [2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9]\n];\nconst u512 = [\n    0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344, 0xa4093822, 0x299f31d0, 0x082efa98, 0xec4e6c89, 0x452821e6,\n    0x38d01377, 0xbe5466cf, 0x34e90c6c, 0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5, 0xb5470917, 0x9216d5d9, 0x8979fb1b,\n    0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7, 0xb8e1afed, 0x6a267e96, 0xba7c9045, 0xf12c7f99, 0x24a19947,\n    0xb3916cf7, 0x0801f2e2, 0x858efc16, 0x636920d8, 0x71574e69\n];\nconst padding = buffer__WEBPACK_IMPORTED_MODULE_6__.Buffer.from([\n    0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n]);\n/**\n * Performs a bitwise rotation on the values of two elements in an array.\n * This operation is a key component of the Blake-512 algorithm, enabling\n * the mixing of bits in a non-linear fashion.\n * @param v The array containing values to rotate.\n * @param i The index of the first element to rotate.\n * @param j The index of the second element to rotate.\n * @param n The number of bits to rotate by.\n */\nfunction rot(v, i, j, n) {\n    let hi = v[i * 2] ^ v[j * 2];\n    let lo = v[i * 2 + 1] ^ v[j * 2 + 1];\n    if (n >= 32) {\n        lo ^= hi;\n        hi ^= lo;\n        lo ^= hi;\n        n -= 32;\n    }\n    if (n === 0) {\n        v[i * 2] = hi >>> 0;\n        v[i * 2 + 1] = lo >>> 0;\n    }\n    else {\n        v[i * 2] = ((hi >>> n) | (lo << (32 - n))) >>> 0;\n        v[i * 2 + 1] = ((lo >>> n) | (hi << (32 - n))) >>> 0;\n    }\n}\n/**\n * The G function is one of the core operations in the Blake-512 compression function.\n * It mixes the input values based on the message block and the round constants,\n * contributing to the diffusion and confusion properties of the hash function.\n * @param v The working vector, part of the state being updated.\n * @param m - The message block being processed.\n * @param i The current round index.\n * @param a, b, c, d Indices within the working vector to mix.\n * @param e Index within the message block and round constants.\n */\nfunction g(v, m, i, a, b, c, d, e) {\n    let lo;\n    // v[a] += (m[sigma[i][e]] ^ u512[sigma[i][e+1]]) + v[b];\n    lo = v[a * 2 + 1] + ((m[sigma[i][e] * 2 + 1] ^ u512[sigma[i][e + 1] * 2 + 1]) >>> 0) + v[b * 2 + 1];\n    v[a * 2] =\n        (v[a * 2] + ((m[sigma[i][e] * 2] ^ u512[sigma[i][e + 1] * 2]) >>> 0) + v[b * 2] + ~~(lo / 0x0100000000)) >>> 0;\n    v[a * 2 + 1] = lo >>> 0;\n    // v[d] = ROT( v[d] ^ v[a],32);\n    rot(v, d, a, 32);\n    // v[c] += v[d];\n    lo = v[c * 2 + 1] + v[d * 2 + 1];\n    v[c * 2] = (v[c * 2] + v[d * 2] + ~~(lo / 0x0100000000)) >>> 0;\n    v[c * 2 + 1] = lo >>> 0;\n    // v[b] = ROT( v[b] ^ v[c],25);\n    rot(v, b, c, 25);\n    // v[a] += (m[sigma[i][e+1]] ^ u512[sigma[i][e]])+v[b];\n    lo = v[a * 2 + 1] + ((m[sigma[i][e + 1] * 2 + 1] ^ u512[sigma[i][e] * 2 + 1]) >>> 0) + v[b * 2 + 1];\n    v[a * 2] =\n        (v[a * 2] + ((m[sigma[i][e + 1] * 2] ^ u512[sigma[i][e] * 2]) >>> 0) + v[b * 2] + ~~(lo / 0x0100000000)) >>> 0;\n    v[a * 2 + 1] = lo >>> 0;\n    // v[d] = ROT( v[d] ^ v[a],16);\n    rot(v, d, a, 16);\n    // v[c] += v[d];\n    lo = v[c * 2 + 1] + v[d * 2 + 1];\n    v[c * 2] = (v[c * 2] + v[d * 2] + ~~(lo / 0x0100000000)) >>> 0;\n    v[c * 2 + 1] = lo >>> 0;\n    // v[b] = ROT( v[b] ^ v[c],11)\n    rot(v, b, c, 11);\n}\n/**\n * Processes the carry for the bit length counter, ensuring it remains\n * within bounds as a 128-bit number.\n * @param arr The array representing the 128-bit counter.\n */\nfunction lengthCarry(arr) {\n    for (let j = 0; j < arr.length; j += 1) {\n        if (arr[j] < 0x0100000000)\n            break;\n        arr[j] -= 0x0100000000;\n        arr[j + 1] += 1;\n    }\n}\n/**\n * Represents a Blake-512 hash computation instance.\n * This class maintains the internal state, buffers, and counters needed to\n * process input data and produce the final hash output. It supports incremental\n * hashing, allowing data to be added in chunks.\n */\n/* eslint-disable import/prefer-default-export */\nclass Blake512 {\n    /**\n     * Initializes a new Blake-512 hash instance with the default parameters.\n     */\n    constructor() {\n        this._h = [\n            0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1, 0x510e527f,\n            0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179\n        ];\n        this._s = [0, 0, 0, 0, 0, 0, 0, 0];\n        this._block = buffer__WEBPACK_IMPORTED_MODULE_6__.Buffer.alloc(128);\n        this._blockOffset = 0;\n        this._length = [0, 0, 0, 0];\n        this._nullt = false;\n        this._zo = zo;\n        this._oo = oo;\n    }\n    /**\n     * The core compression function for Blake-512. It transforms the internal\n     * state based on the input block and the current hash parameters.\n     */\n    _compress() {\n        const v = new Array(32);\n        const m = new Array(32);\n        let i;\n        for (i = 0; i < 32; i += 1)\n            m[i] = this._block.readUInt32BE(i * 4);\n        for (i = 0; i < 16; i += 1)\n            v[i] = this._h[i] >>> 0;\n        for (i = 16; i < 24; i += 1)\n            v[i] = (this._s[i - 16] ^ u512[i - 16]) >>> 0;\n        for (i = 24; i < 32; i += 1)\n            v[i] = u512[i - 16];\n        if (!this._nullt) {\n            v[24] = (v[24] ^ this._length[1]) >>> 0;\n            v[25] = (v[25] ^ this._length[0]) >>> 0;\n            v[26] = (v[26] ^ this._length[1]) >>> 0;\n            v[27] = (v[27] ^ this._length[0]) >>> 0;\n            v[28] = (v[28] ^ this._length[3]) >>> 0;\n            v[29] = (v[29] ^ this._length[2]) >>> 0;\n            v[30] = (v[30] ^ this._length[3]) >>> 0;\n            v[31] = (v[31] ^ this._length[2]) >>> 0;\n        }\n        for (i = 0; i < 16; i += 1) {\n            /* column step */\n            g(v, m, i, 0, 4, 8, 12, 0);\n            g(v, m, i, 1, 5, 9, 13, 2);\n            g(v, m, i, 2, 6, 10, 14, 4);\n            g(v, m, i, 3, 7, 11, 15, 6);\n            /* diagonal step */\n            g(v, m, i, 0, 5, 10, 15, 8);\n            g(v, m, i, 1, 6, 11, 12, 10);\n            g(v, m, i, 2, 7, 8, 13, 12);\n            g(v, m, i, 3, 4, 9, 14, 14);\n        }\n        for (i = 0; i < 16; i += 1) {\n            this._h[(i % 8) * 2] = (this._h[(i % 8) * 2] ^ v[i * 2]) >>> 0;\n            this._h[(i % 8) * 2 + 1] = (this._h[(i % 8) * 2 + 1] ^ v[i * 2 + 1]) >>> 0;\n        }\n        for (i = 0; i < 8; i += 1) {\n            this._h[i * 2] = (this._h[i * 2] ^ this._s[(i % 4) * 2]) >>> 0;\n            this._h[i * 2 + 1] = (this._h[i * 2 + 1] ^ this._s[(i % 4) * 2 + 1]) >>> 0;\n        }\n    }\n    /**\n     * Adds padding to the message as per the Blake-512 specification, ensuring\n     * the message length is a multiple of the block size.\n     */\n    _padding() {\n        const len = this._length.slice();\n        len[0] += this._blockOffset * 8;\n        lengthCarry(len);\n        const msglen = buffer__WEBPACK_IMPORTED_MODULE_6__.Buffer.alloc(16);\n        for (let i = 0; i < 4; i += 1)\n            msglen.writeUInt32BE(len[3 - i], i * 4);\n        if (this._blockOffset === 111) {\n            this._length[0] -= 8;\n            this.update(this._oo);\n        }\n        else {\n            if (this._blockOffset < 111) {\n                if (this._blockOffset === 0)\n                    this._nullt = true;\n                this._length[0] -= (111 - this._blockOffset) * 8;\n                this.update(padding.subarray(0, 111 - this._blockOffset));\n            }\n            else {\n                this._length[0] -= (128 - this._blockOffset) * 8;\n                this.update(padding.subarray(0, 128 - this._blockOffset));\n                this._length[0] -= 111 * 8;\n                this.update(padding.subarray(1, 1 + 111));\n                this._nullt = true;\n            }\n            this.update(this._zo);\n            this._length[0] -= 8;\n        }\n        this._length[0] -= 128;\n        this.update(msglen);\n    }\n    /**\n     * Completes the hash computation and returns the final hash value.\n     * This method applies the necessary padding, performs the final compression,\n     * and returns the hash output.\n     * @returns The Blake-512 hash of the input data.\n     */\n    digest() {\n        this._padding();\n        const buffer = buffer__WEBPACK_IMPORTED_MODULE_6__.Buffer.alloc(64);\n        for (let i = 0; i < 16; i += 1)\n            buffer.writeUInt32BE(this._h[i], i * 4);\n        return buffer;\n    }\n    /**\n     * Updates the hash with new data. This method can be called multiple\n     * times to incrementally add data to the hash computation.\n     * @param data The data to add to the hash.\n     * @returns This instance, to allow method chaining.\n     */\n    update(data) {\n        const block = this._block;\n        let offset = 0;\n        while (this._blockOffset + data.length - offset >= block.length) {\n            for (let i = this._blockOffset; i < block.length;)\n                /* eslint-disable no-plusplus */\n                block[i++] = data[offset++];\n            this._length[0] += block.length * 8;\n            lengthCarry(this._length);\n            this._compress();\n            this._blockOffset = 0;\n        }\n        while (offset < data.length)\n            /* eslint-disable no-plusplus */\n            block[this._blockOffset++] = data[offset++];\n        return this;\n    }\n}\n\n/**\n * Prunes a buffer to meet the specific requirements for using it as a private key\n * or part of a signature.\n * @param buff The buffer to be pruned.\n * @returns The pruned buffer.\n */\nfunction pruneBuffer(buff) {\n    buff[0] &= 0xf8;\n    buff[31] &= 0x7f;\n    buff[31] |= 0x40;\n    return buff;\n}\n/**\n * Validates if the given object is a valid point on the Baby Jubjub elliptic curve.\n * @param point The point to validate.\n * @returns True if the object is a valid point, false otherwise.\n */\nfunction isPoint(point) {\n    return (0,_zk_kit_utils_type_checks__WEBPACK_IMPORTED_MODULE_8__.isArray)(point) && point.length === 2 && (0,_zk_kit_utils_type_checks__WEBPACK_IMPORTED_MODULE_8__.isBigNumber)(point[0]) && (0,_zk_kit_utils_type_checks__WEBPACK_IMPORTED_MODULE_8__.isBigNumber)(point[1]);\n}\n/**\n * Checks if the provided object conforms to the expected format of a Signature.\n * @param signature The signature to validate.\n * @returns True if the object is a valid Signature, false otherwise.\n */\nfunction isSignature(signature) {\n    return ((0,_zk_kit_utils_type_checks__WEBPACK_IMPORTED_MODULE_8__.isObject)(signature) &&\n        Object.prototype.hasOwnProperty.call(signature, \"R8\") &&\n        Object.prototype.hasOwnProperty.call(signature, \"S\") &&\n        isPoint(signature.R8) &&\n        (0,_zk_kit_utils_type_checks__WEBPACK_IMPORTED_MODULE_8__.isBigNumber)(signature.S));\n}\n/**\n * Validates and converts a BigNumberish private key to a Buffer.\n * @param privateKey The private key to check and convert.\n * @returns The private key as a Buffer.\n */\nfunction checkPrivateKey(privateKey) {\n    (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_3__.requireTypes)(privateKey, \"privateKey\", [\"Buffer\", \"Uint8Array\", \"string\"]);\n    return buffer__WEBPACK_IMPORTED_MODULE_6__.Buffer.from(privateKey);\n}\n/**\n * Validates and converts a BigNumberish message to a bigint.\n * @param message The message to check and convert.\n * @returns The message as a bigint.\n */\nfunction checkMessage(message) {\n    (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_3__.requireTypes)(message, \"message\", [\"bignumberish\", \"string\"]);\n    if ((0,_zk_kit_utils_type_checks__WEBPACK_IMPORTED_MODULE_8__.isBigNumberish)(message)) {\n        return (0,_zk_kit_utils_conversions__WEBPACK_IMPORTED_MODULE_2__.bigNumberishToBigInt)(message);\n    }\n    return (0,_zk_kit_utils_conversions__WEBPACK_IMPORTED_MODULE_2__.bufferToBigInt)(buffer__WEBPACK_IMPORTED_MODULE_6__.Buffer.from(message));\n}\n/**\n * Computes the Blake512 hash of the input message.\n * Blake512 is a cryptographic hash function that produces a hash value of 512 bits,\n * commonly used for data integrity checks and other cryptographic applications.\n * @param message The input data to hash, provided as a Buffer.\n * @returns A Buffer containing the 512-bit hash result.\n */\nfunction hash(message) {\n    const engine = new Blake512();\n    engine.update(buffer__WEBPACK_IMPORTED_MODULE_6__.Buffer.from(message));\n    return engine.digest();\n}\n\n/**\n * Derives a secret scalar from a given EdDSA private key.\n *\n * This process involves hashing the private key with Blake1, pruning the resulting hash to retain the lower 32 bytes,\n * and converting it into a little-endian integer. The use of the secret scalar streamlines the public key generation\n * process by omitting steps 1, 2, and 3 as outlined in RFC 8032 section 5.1.5, enhancing circuit efficiency and simplicity.\n * This method is crucial for fixed-base scalar multiplication operations within the correspondent cryptographic circuit.\n * For detailed steps, see: {@link https://datatracker.ietf.org/doc/html/rfc8032#section-5.1.5}.\n * For example usage in a circuit, see: {@link https://github.com/semaphore-protocol/semaphore/blob/2c144fc9e55b30ad09474aeafa763c4115338409/packages/circuits/semaphore.circom#L21}\n *\n * The private key must be an instance of Buffer, Uint8Array or a string. The input will be used to\n * generate entropy and there is no limit in size.\n * The string is used as a set of raw bytes (in UTF-8) and is typically used to pass passwords or secret messages.\n * If you want to pass a bigint, a number or a hexadecimal, be sure to convert them to one of the supported types first.\n * The 'conversions' module in @zk-kit/utils provides a set of functions that may be useful in case you need to convert types.\n *\n * @param privateKey The EdDSA private key for generating the associated public key.\n * @returns The derived secret scalar to be used to calculate public key and optimized for circuit calculations.\n */\nfunction deriveSecretScalar(privateKey) {\n    // Convert the private key to buffer.\n    privateKey = checkPrivateKey(privateKey);\n    let hash$1 = hash(privateKey);\n    hash$1 = hash$1.slice(0, 32);\n    hash$1 = pruneBuffer(hash$1);\n    return _zk_kit_utils_scalar__WEBPACK_IMPORTED_MODULE_5__.shiftRight((0,_zk_kit_utils_conversions__WEBPACK_IMPORTED_MODULE_2__.leBufferToBigInt)(hash$1), BigInt(3)) % _zk_kit_baby_jubjub__WEBPACK_IMPORTED_MODULE_0__.subOrder;\n}\n/**\n * Derives a public key from a given private key using the\n * {@link https://eips.ethereum.org/EIPS/eip-2494|Baby Jubjub} elliptic curve.\n * This function utilizes the Baby Jubjub elliptic curve for cryptographic operations.\n * The private key should be securely stored and managed, and it should never be exposed\n * or transmitted in an unsecured manner.\n *\n * The private key must be an instance of Buffer, Uint8Array or a string. The input will be used to\n * generate entropy and there is no limit in size.\n * The string is used as a set of raw bytes (in UTF-8) and is typically used to pass passwords or secret messages.\n * If you want to pass a bigint, a number or a hexadecimal, be sure to convert them to one of the supported types first.\n * The 'conversions' module in @zk-kit/utils provides a set of functions that may be useful in case you need to convert types.\n *\n * @param privateKey The private key used for generating the public key.\n * @returns The derived public key.\n */\nfunction derivePublicKey(privateKey) {\n    const s = deriveSecretScalar(privateKey);\n    return (0,_zk_kit_baby_jubjub__WEBPACK_IMPORTED_MODULE_0__.mulPointEscalar)(_zk_kit_baby_jubjub__WEBPACK_IMPORTED_MODULE_0__.Base8, s);\n}\n/**\n * Signs a message using the provided private key, employing Poseidon hashing and\n * EdDSA with the Baby Jubjub elliptic curve.\n *\n * The private key must be an instance of Buffer, Uint8Array or a string. The input will be used to\n * generate entropy and there is no limit in size.\n * The string is used as a set of raw bytes (in UTF-8) and is typically used to pass passwords or secret messages.\n * If you want to pass a bigint, a number or a hexadecimal, be sure to convert them to one of the supported types first.\n * The 'conversions' module in @zk-kit/utils provides a set of functions that may be useful in case you need to convert types.\n *\n * @param privateKey The private key used to sign the message.\n * @param message The message to be signed.\n * @returns The signature object, containing properties relevant to EdDSA signatures, such as 'R8' and 'S' values.\n */\nfunction signMessage(privateKey, message) {\n    // Convert the private key to buffer.\n    privateKey = checkPrivateKey(privateKey);\n    // Convert the message to big integer.\n    message = checkMessage(message);\n    const hash$1 = hash(privateKey);\n    const sBuff = pruneBuffer(hash$1.slice(0, 32));\n    const s = (0,_zk_kit_utils_conversions__WEBPACK_IMPORTED_MODULE_2__.leBufferToBigInt)(sBuff);\n    const A = (0,_zk_kit_baby_jubjub__WEBPACK_IMPORTED_MODULE_0__.mulPointEscalar)(_zk_kit_baby_jubjub__WEBPACK_IMPORTED_MODULE_0__.Base8, _zk_kit_utils_scalar__WEBPACK_IMPORTED_MODULE_5__.shiftRight(s, BigInt(3)));\n    const msgBuff = (0,_zk_kit_utils_conversions__WEBPACK_IMPORTED_MODULE_2__.leBigIntToBuffer)(message, 32);\n    const rBuff = hash(buffer__WEBPACK_IMPORTED_MODULE_6__.Buffer.concat([hash$1.slice(32, 64), msgBuff]));\n    const Fr = new _zk_kit_utils_f1_field__WEBPACK_IMPORTED_MODULE_4__[\"default\"](_zk_kit_baby_jubjub__WEBPACK_IMPORTED_MODULE_0__.subOrder);\n    const r = Fr.e((0,_zk_kit_utils_conversions__WEBPACK_IMPORTED_MODULE_2__.leBufferToBigInt)(rBuff));\n    const R8 = (0,_zk_kit_baby_jubjub__WEBPACK_IMPORTED_MODULE_0__.mulPointEscalar)(_zk_kit_baby_jubjub__WEBPACK_IMPORTED_MODULE_0__.Base8, r);\n    const hm = (0,poseidon_lite_poseidon5__WEBPACK_IMPORTED_MODULE_7__.poseidon5)([R8[0], R8[1], A[0], A[1], message]);\n    const S = Fr.add(r, Fr.mul(hm, s));\n    return { R8, S };\n}\n/**\n * Verifies an EdDSA signature using the Baby Jubjub elliptic curve and Poseidon hash function.\n * @param message The original message that was be signed.\n * @param signature The EdDSA signature to be verified.\n * @param publicKey The public key associated with the private key used to sign the message.\n * @returns Returns true if the signature is valid and corresponds to the message and public key, false otherwise.\n */\nfunction verifySignature(message, signature, publicKey) {\n    if (!isPoint(publicKey) ||\n        !isSignature(signature) ||\n        !(0,_zk_kit_baby_jubjub__WEBPACK_IMPORTED_MODULE_0__.inCurve)(signature.R8) ||\n        !(0,_zk_kit_baby_jubjub__WEBPACK_IMPORTED_MODULE_0__.inCurve)(publicKey) ||\n        BigInt(signature.S) >= _zk_kit_baby_jubjub__WEBPACK_IMPORTED_MODULE_0__.subOrder) {\n        return false;\n    }\n    // Convert the message to big integer.\n    message = checkMessage(message);\n    // Convert the signature values to big integers for calculations.\n    const _signature = {\n        R8: [BigInt(signature.R8[0]), BigInt(signature.R8[1])],\n        S: BigInt(signature.S)\n    };\n    // Convert the public key values to big integers for calculations.\n    const _publicKey = [BigInt(publicKey[0]), BigInt(publicKey[1])];\n    const hm = (0,poseidon_lite_poseidon5__WEBPACK_IMPORTED_MODULE_7__.poseidon5)([signature.R8[0], signature.R8[1], publicKey[0], publicKey[1], message]);\n    const pLeft = (0,_zk_kit_baby_jubjub__WEBPACK_IMPORTED_MODULE_0__.mulPointEscalar)(_zk_kit_baby_jubjub__WEBPACK_IMPORTED_MODULE_0__.Base8, BigInt(signature.S));\n    let pRight = (0,_zk_kit_baby_jubjub__WEBPACK_IMPORTED_MODULE_0__.mulPointEscalar)(_publicKey, _zk_kit_utils_scalar__WEBPACK_IMPORTED_MODULE_5__.mul(hm, BigInt(8)));\n    pRight = (0,_zk_kit_baby_jubjub__WEBPACK_IMPORTED_MODULE_0__.addPoint)(_signature.R8, pRight);\n    // Return true if the points match.\n    return _zk_kit_baby_jubjub__WEBPACK_IMPORTED_MODULE_0__.Fr.eq(pLeft[0], pRight[0]) && _zk_kit_baby_jubjub__WEBPACK_IMPORTED_MODULE_0__.Fr.eq(pLeft[1], pRight[1]);\n}\n/**\n * Converts a given public key into a packed (compressed) string format for efficient transmission and storage.\n * This method ensures the public key is valid and within the Baby Jubjub curve before packing.\n * @param publicKey The public key to be packed.\n * @returns A string representation of the packed public key.\n */\nfunction packPublicKey(publicKey) {\n    if (!isPoint(publicKey) || !(0,_zk_kit_baby_jubjub__WEBPACK_IMPORTED_MODULE_0__.inCurve)(publicKey)) {\n        throw new Error(\"Invalid public key\");\n    }\n    // Convert the public key values to big integers for calculations.\n    const _publicKey = [BigInt(publicKey[0]), BigInt(publicKey[1])];\n    return (0,_zk_kit_baby_jubjub__WEBPACK_IMPORTED_MODULE_0__.packPoint)(_publicKey);\n}\n/**\n * Unpacks a public key from its packed string representation back to its original point form on the Baby Jubjub curve.\n * This function checks for the validity of the input format before attempting to unpack.\n * @param publicKey The packed public key as a bignumberish.\n * @returns The unpacked public key as a point.\n */\nfunction unpackPublicKey(publicKey) {\n    (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_3__.requireBigNumberish)(publicKey, \"publicKey\");\n    const unpackedPublicKey = (0,_zk_kit_baby_jubjub__WEBPACK_IMPORTED_MODULE_0__.unpackPoint)((0,_zk_kit_utils_conversions__WEBPACK_IMPORTED_MODULE_2__.bigNumberishToBigInt)(publicKey));\n    if (unpackedPublicKey === null) {\n        throw new Error(\"Invalid public key\");\n    }\n    return unpackedPublicKey;\n}\n/**\n * Packs an EdDSA signature into a buffer of 64 bytes for efficient storage.\n * Use {@link unpackSignature} to reverse the process without needing to know\n * the details of the format.\n *\n * The buffer contains the R8 point packed int 32 bytes (via\n * {@link packSignature}) followed by the S scalar.  All encodings are\n * little-endian.\n *\n * @param signature the signature to pack\n * @returns a 64 byte buffer containing the packed signature\n */\nfunction packSignature(signature) {\n    if (!isSignature(signature) || !(0,_zk_kit_baby_jubjub__WEBPACK_IMPORTED_MODULE_0__.inCurve)(signature.R8) || BigInt(signature.S) >= _zk_kit_baby_jubjub__WEBPACK_IMPORTED_MODULE_0__.subOrder) {\n        throw new Error(\"Invalid signature\");\n    }\n    const numericSignature = {\n        R8: signature.R8.map((c) => BigInt(c)),\n        S: BigInt(signature.S)\n    };\n    const packedR8 = (0,_zk_kit_baby_jubjub__WEBPACK_IMPORTED_MODULE_0__.packPoint)(numericSignature.R8);\n    const packedBytes = buffer__WEBPACK_IMPORTED_MODULE_6__.Buffer.alloc(64);\n    packedBytes.set((0,_zk_kit_utils_conversions__WEBPACK_IMPORTED_MODULE_2__.leBigIntToBuffer)(packedR8, 32), 0);\n    packedBytes.set((0,_zk_kit_utils_conversions__WEBPACK_IMPORTED_MODULE_2__.leBigIntToBuffer)(numericSignature.S, 32), 32);\n    return packedBytes;\n}\n/**\n * Unpacks a signature produced by {@link packSignature}.  See that function\n * for the details of the format.\n *\n * @param packedSignature the 64 byte buffer to unpack\n * @returns a Signature with numbers in string form\n */\nfunction unpackSignature(packedSignature) {\n    (0,_zk_kit_utils__WEBPACK_IMPORTED_MODULE_1__.requireBuffer)(packedSignature, \"packedSignature\");\n    if (packedSignature.length !== 64) {\n        throw new Error(\"Packed signature must be 64 bytes\");\n    }\n    const sliceR8 = packedSignature.subarray(0, 32);\n    const sliceS = packedSignature.subarray(32, 64);\n    const unpackedR8 = (0,_zk_kit_baby_jubjub__WEBPACK_IMPORTED_MODULE_0__.unpackPoint)((0,_zk_kit_utils_conversions__WEBPACK_IMPORTED_MODULE_2__.leBufferToBigInt)(sliceR8));\n    if (unpackedR8 === null) {\n        throw new Error(`Invalid packed signature point ${sliceS.toString(\"hex\")}.`);\n    }\n    return {\n        R8: unpackedR8,\n        S: (0,_zk_kit_utils_conversions__WEBPACK_IMPORTED_MODULE_2__.leBufferToBigInt)(sliceS)\n    };\n}\n/**\n * Represents a cryptographic entity capable of signing messages and verifying signatures\n * using the EdDSA scheme with Poseidon hash and the Baby Jubjub elliptic curve.\n */\nclass EdDSAPoseidon {\n    /**\n     * Initializes a new instance, deriving necessary cryptographic parameters from the provided private key.\n     * If the private key is not passed as a parameter, a random 32-byte hexadecimal key is generated.\n     *\n     * The private key must be an instance of Buffer, Uint8Array or a string. The input will be used to\n     * generate entropy and there is no limit in size.\n     * The string is used as a set of raw bytes (in UTF-8) and is typically used to pass passwords or secret messages.\n     * If you want to pass a bigint, a number or a hexadecimal, be sure to convert them to one of the supported types first.\n     * The 'conversions' module in @zk-kit/utils provides a set of functions that may be useful in case you need to convert types.\n     *\n     * @param privateKey The private key used for signing and public key derivation.\n     */\n    constructor(privateKey = _zk_kit_utils__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues(32)) {\n        this.privateKey = privateKey;\n        this.secretScalar = deriveSecretScalar(privateKey);\n        this.publicKey = derivePublicKey(privateKey);\n        this.packedPublicKey = packPublicKey(this.publicKey);\n    }\n    /**\n     * Signs a given message using the private key and returns the signature.\n     * @param message The message to be signed.\n     * @returns The signature of the message.\n     */\n    signMessage(message) {\n        return signMessage(this.privateKey, message);\n    }\n    /**\n     * Verifies a signature against a message and the public key stored in this instance.\n     * @param message The message whose signature is to be verified.\n     * @param signature The signature to be verified.\n     * @returns True if the signature is valid for the message and public key, false otherwise.\n     */\n    verifySignature(message, signature) {\n        return verifySignature(message, signature, this.publicKey);\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHprLWtpdC9lZGRzYS1wb3NlaWRvbi9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNzSDtBQUNoRTtBQUMrRDtBQUNwQztBQUNwQztBQUNFO0FBQ2Y7QUFDb0I7QUFDdUM7O0FBRTNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQ0FBTTtBQUNqQixXQUFXLDBDQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBDQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMENBQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBDQUFNO0FBQzdCLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQ0FBTTtBQUM3Qix3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxpQkFBaUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrRUFBTyxpQ0FBaUMsc0VBQVcsY0FBYyxzRUFBVztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUVBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzRUFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksMEVBQVk7QUFDaEIsV0FBVywwQ0FBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksMEVBQVk7QUFDaEIsUUFBUSx5RUFBYztBQUN0QixlQUFlLCtFQUFvQjtBQUNuQztBQUNBLFdBQVcseUVBQWMsQ0FBQywwQ0FBTTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwQ0FBTTtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtFQUFrRTtBQUMvRix5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDREQUFpQixDQUFDLDJFQUFnQix1QkFBdUIseURBQVE7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsSUFBSSwyREFBMkQ7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvRUFBZSxDQUFDLHNEQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyRUFBZ0I7QUFDOUIsY0FBYyxvRUFBZSxDQUFDLHNEQUFLLEVBQUUsNERBQWlCO0FBQ3RELG9CQUFvQiwyRUFBZ0I7QUFDcEMsdUJBQXVCLDBDQUFNO0FBQzdCLG1CQUFtQiw4REFBTyxDQUFDLHlEQUFRO0FBQ25DLG1CQUFtQiwyRUFBZ0I7QUFDbkMsZUFBZSxvRUFBZSxDQUFDLHNEQUFLO0FBQ3BDLGVBQWUsa0VBQVM7QUFDeEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNERBQU87QUFDaEIsU0FBUyw0REFBTztBQUNoQiwrQkFBK0IseURBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0VBQVM7QUFDeEIsa0JBQWtCLG9FQUFlLENBQUMsc0RBQUs7QUFDdkMsaUJBQWlCLG9FQUFlLGFBQWEscURBQVU7QUFDdkQsYUFBYSw2REFBUTtBQUNyQjtBQUNBLFdBQVcsbURBQUUsNEJBQTRCLG1EQUFFO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNERBQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhEQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlGQUFtQjtBQUN2Qiw4QkFBOEIsZ0VBQVcsQ0FBQywrRUFBb0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVCQUF1QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxJQUFJLG9CQUFvQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsNERBQU8seUNBQXlDLHlEQUFRO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw4REFBUztBQUM5Qix3QkFBd0IsMENBQU07QUFDOUIsb0JBQW9CLDJFQUFnQjtBQUNwQyxvQkFBb0IsMkVBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0REFBYTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdFQUFXLENBQUMsMkVBQWdCO0FBQ25EO0FBQ0EsMERBQTBELHVCQUF1QjtBQUNqRjtBQUNBO0FBQ0E7QUFDQSxXQUFXLDJFQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpREFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU0SiIsInNvdXJjZXMiOlsiL1VzZXJzL2NoYW5jZW1jYWxsaXN0ZXIvUHJvamVjdHMvenVwYXNzaHVudC9ub2RlX21vZHVsZXMvQHprLWtpdC9lZGRzYS1wb3NlaWRvbi9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBAemsta2l0L2VkZHNhLXBvc2VpZG9uXG4gKiBAdmVyc2lvbiAxLjAuNFxuICogQGZpbGUgQSBKYXZhU2NyaXB0IEVkRFNBIGxpYnJhcnkgZm9yIHNlY3VyZSBzaWduaW5nIGFuZCB2ZXJpZmljYXRpb24gdXNpbmcgUG9zZWlkb24gdGhlIEJhYnkgSnVianViIGVsbGlwdGljIGN1cnZlLlxuICogQGNvcHlyaWdodCBFdGhlcmV1bSBGb3VuZGF0aW9uIDIwMjRcbiAqIEBsaWNlbnNlIE1JVFxuICogQHNlZSBbR2l0aHViXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcHJpdmFjeS1zY2FsaW5nLWV4cGxvcmF0aW9ucy96ay1raXQvdHJlZS9tYWluL3BhY2thZ2VzL2VkZHNhLXBvc2VpZG9ufVxuKi9cbmltcG9ydCB7IHN1Yk9yZGVyLCBtdWxQb2ludEVzY2FsYXIsIEJhc2U4LCBpbkN1cnZlLCBhZGRQb2ludCwgRnIsIHBhY2tQb2ludCwgdW5wYWNrUG9pbnQgfSBmcm9tICdAemsta2l0L2JhYnktanVianViJztcbmltcG9ydCB7IHJlcXVpcmVCdWZmZXIsIGNyeXB0byB9IGZyb20gJ0B6ay1raXQvdXRpbHMnO1xuaW1wb3J0IHsgYmlnTnVtYmVyaXNoVG9CaWdJbnQsIGJ1ZmZlclRvQmlnSW50LCBsZUJ1ZmZlclRvQmlnSW50LCBsZUJpZ0ludFRvQnVmZmVyIH0gZnJvbSAnQHprLWtpdC91dGlscy9jb252ZXJzaW9ucyc7XG5pbXBvcnQgeyByZXF1aXJlVHlwZXMsIHJlcXVpcmVCaWdOdW1iZXJpc2ggfSBmcm9tICdAemsta2l0L3V0aWxzL2Vycm9yLWhhbmRsZXJzJztcbmltcG9ydCBGMUZpZWxkIGZyb20gJ0B6ay1raXQvdXRpbHMvZjEtZmllbGQnO1xuaW1wb3J0ICogYXMgc2NhbGFyIGZyb20gJ0B6ay1raXQvdXRpbHMvc2NhbGFyJztcbmltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJ2J1ZmZlcic7XG5pbXBvcnQgeyBwb3NlaWRvbjUgfSBmcm9tICdwb3NlaWRvbi1saXRlL3Bvc2VpZG9uNSc7XG5pbXBvcnQgeyBpc0FycmF5LCBpc0JpZ051bWJlciwgaXNPYmplY3QsIGlzQmlnTnVtYmVyaXNoIH0gZnJvbSAnQHprLWtpdC91dGlscy90eXBlLWNoZWNrcyc7XG5cbi8qKlxuICogQ29weXJpZ2h0XG4gKiBUaGlzIGNvZGUgaXMgYSBUeXBlU2NyaXB0IGFkYXB0YXRpb24gb2YgdGhlICdibGFrZS1oYXNoJyBsaWJyYXJ5IGNvZGUgKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2JsYWtlLWhhc2gpXG4gKiB1c2luZyB0aGUgJ2J1ZmZlcicgbnBtIHBhY2thZ2UgKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2J1ZmZlcikuXG4gKiBUaGUgJ2pzLWNyeXB0bycgbGlicmFyeSAoaHR0cHM6Ly9naXRodWIuY29tL2lkZW4zL2pzLWNyeXB0by9ibG9iL21haW4vc3JjL2JsYWtlLnRzKSBmcm9tIElkZW4zIHdhcyB1c2VkIGFzIGEgcmVmZXJlbmNlXG4gKiBmb3IgdGhpcyB3b3JrLCBzcGVjaWZpY2FsbHkgZm9yIHR5cGVzIGFuZCBhZGFwdGF0aW9uLlxuICovXG4vKipcbiAqIEBtb2R1bGUgQmxha2VcbiAqIEltcGxlbWVudHMgdGhlIEJsYWtlLTUxMiBjcnlwdG9ncmFwaGljIGhhc2ggZnVuY3Rpb24uXG4gKiBCbGFrZS01MTIgaXMgcGFydCBvZiB0aGUgQkxBS0UgZmFtaWx5IG9mIGNyeXB0b2dyYXBoaWMgaGFzaCBmdW5jdGlvbnMsIGtub3duXG4gKiBmb3IgaXRzIHNwZWVkIGFuZCBzZWN1cml0eS4gVGhpcyBtb2R1bGUgb2ZmZXJzIGZ1bmN0aW9uYWxpdHkgdG8gY29tcHV0ZSBCbGFrZS01MTJcbiAqIGhhc2hlcyBvZiBpbnB1dCBkYXRhLCBwcm92aWRpbmcgYm90aCBvbmUtdGltZSBoYXNoaW5nIGNhcGFiaWxpdGllcyBhbmQgaW5jcmVtZW50YWxcbiAqIGhhc2hpbmcgdG8gcHJvY2VzcyBsYXJnZSBvciBzdHJlYW1pbmcgZGF0YS5cbiAqXG4gKiBUaGlzIGNvZGUgaXMgYWRhcHRlZCBmcm9tIHRoZSBcImJsYWtlLWhhc2hcIiBKYXZhU2NyaXB0IGxpYnJhcnksIGVuc3VyaW5nIGNvbXBhdGliaWxpdHlcbiAqIGFuZCBwZXJmb3JtYW5jZSBpbiBUeXBlU2NyaXB0IGVudmlyb25tZW50cy4gSXQgc3VwcG9ydHMgaGFzaGluZyB3aXRoIG9wdGlvbmFsXG4gKiBzYWx0IGZvciBlbmhhbmNlZCBzZWN1cml0eSBpbiBjZXJ0YWluIGNvbnRleHRzLlxuICovXG5jb25zdCB6byA9IEJ1ZmZlci5mcm9tKFsweDAxXSk7XG5jb25zdCBvbyA9IEJ1ZmZlci5mcm9tKFsweDgxXSk7XG4vLyBTdGF0aWMgcHJvcGVydGllcyBmb3Igc2lnbWEsIHUyNTYsIHU1MTIsIGFuZCBwYWRkaW5nIGFyZSBkZWZpbmVkIGhlcmUgYmVsb3dcbmNvbnN0IHNpZ21hID0gW1xuICAgIFswLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1XSxcbiAgICBbMTQsIDEwLCA0LCA4LCA5LCAxNSwgMTMsIDYsIDEsIDEyLCAwLCAyLCAxMSwgNywgNSwgM10sXG4gICAgWzExLCA4LCAxMiwgMCwgNSwgMiwgMTUsIDEzLCAxMCwgMTQsIDMsIDYsIDcsIDEsIDksIDRdLFxuICAgIFs3LCA5LCAzLCAxLCAxMywgMTIsIDExLCAxNCwgMiwgNiwgNSwgMTAsIDQsIDAsIDE1LCA4XSxcbiAgICBbOSwgMCwgNSwgNywgMiwgNCwgMTAsIDE1LCAxNCwgMSwgMTEsIDEyLCA2LCA4LCAzLCAxM10sXG4gICAgWzIsIDEyLCA2LCAxMCwgMCwgMTEsIDgsIDMsIDQsIDEzLCA3LCA1LCAxNSwgMTQsIDEsIDldLFxuICAgIFsxMiwgNSwgMSwgMTUsIDE0LCAxMywgNCwgMTAsIDAsIDcsIDYsIDMsIDksIDIsIDgsIDExXSxcbiAgICBbMTMsIDExLCA3LCAxNCwgMTIsIDEsIDMsIDksIDUsIDAsIDE1LCA0LCA4LCA2LCAyLCAxMF0sXG4gICAgWzYsIDE1LCAxNCwgOSwgMTEsIDMsIDAsIDgsIDEyLCAyLCAxMywgNywgMSwgNCwgMTAsIDVdLFxuICAgIFsxMCwgMiwgOCwgNCwgNywgNiwgMSwgNSwgMTUsIDExLCA5LCAxNCwgMywgMTIsIDEzLCAwXSxcbiAgICBbMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNV0sXG4gICAgWzE0LCAxMCwgNCwgOCwgOSwgMTUsIDEzLCA2LCAxLCAxMiwgMCwgMiwgMTEsIDcsIDUsIDNdLFxuICAgIFsxMSwgOCwgMTIsIDAsIDUsIDIsIDE1LCAxMywgMTAsIDE0LCAzLCA2LCA3LCAxLCA5LCA0XSxcbiAgICBbNywgOSwgMywgMSwgMTMsIDEyLCAxMSwgMTQsIDIsIDYsIDUsIDEwLCA0LCAwLCAxNSwgOF0sXG4gICAgWzksIDAsIDUsIDcsIDIsIDQsIDEwLCAxNSwgMTQsIDEsIDExLCAxMiwgNiwgOCwgMywgMTNdLFxuICAgIFsyLCAxMiwgNiwgMTAsIDAsIDExLCA4LCAzLCA0LCAxMywgNywgNSwgMTUsIDE0LCAxLCA5XVxuXTtcbmNvbnN0IHU1MTIgPSBbXG4gICAgMHgyNDNmNmE4OCwgMHg4NWEzMDhkMywgMHgxMzE5OGEyZSwgMHgwMzcwNzM0NCwgMHhhNDA5MzgyMiwgMHgyOTlmMzFkMCwgMHgwODJlZmE5OCwgMHhlYzRlNmM4OSwgMHg0NTI4MjFlNixcbiAgICAweDM4ZDAxMzc3LCAweGJlNTQ2NmNmLCAweDM0ZTkwYzZjLCAweGMwYWMyOWI3LCAweGM5N2M1MGRkLCAweDNmODRkNWI1LCAweGI1NDcwOTE3LCAweDkyMTZkNWQ5LCAweDg5NzlmYjFiLFxuICAgIDB4ZDEzMTBiYTYsIDB4OThkZmI1YWMsIDB4MmZmZDcyZGIsIDB4ZDAxYWRmYjcsIDB4YjhlMWFmZWQsIDB4NmEyNjdlOTYsIDB4YmE3YzkwNDUsIDB4ZjEyYzdmOTksIDB4MjRhMTk5NDcsXG4gICAgMHhiMzkxNmNmNywgMHgwODAxZjJlMiwgMHg4NThlZmMxNiwgMHg2MzY5MjBkOCwgMHg3MTU3NGU2OVxuXTtcbmNvbnN0IHBhZGRpbmcgPSBCdWZmZXIuZnJvbShbXG4gICAgMHg4MCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMFxuXSk7XG4vKipcbiAqIFBlcmZvcm1zIGEgYml0d2lzZSByb3RhdGlvbiBvbiB0aGUgdmFsdWVzIG9mIHR3byBlbGVtZW50cyBpbiBhbiBhcnJheS5cbiAqIFRoaXMgb3BlcmF0aW9uIGlzIGEga2V5IGNvbXBvbmVudCBvZiB0aGUgQmxha2UtNTEyIGFsZ29yaXRobSwgZW5hYmxpbmdcbiAqIHRoZSBtaXhpbmcgb2YgYml0cyBpbiBhIG5vbi1saW5lYXIgZmFzaGlvbi5cbiAqIEBwYXJhbSB2IFRoZSBhcnJheSBjb250YWluaW5nIHZhbHVlcyB0byByb3RhdGUuXG4gKiBAcGFyYW0gaSBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgdG8gcm90YXRlLlxuICogQHBhcmFtIGogVGhlIGluZGV4IG9mIHRoZSBzZWNvbmQgZWxlbWVudCB0byByb3RhdGUuXG4gKiBAcGFyYW0gbiBUaGUgbnVtYmVyIG9mIGJpdHMgdG8gcm90YXRlIGJ5LlxuICovXG5mdW5jdGlvbiByb3QodiwgaSwgaiwgbikge1xuICAgIGxldCBoaSA9IHZbaSAqIDJdIF4gdltqICogMl07XG4gICAgbGV0IGxvID0gdltpICogMiArIDFdIF4gdltqICogMiArIDFdO1xuICAgIGlmIChuID49IDMyKSB7XG4gICAgICAgIGxvIF49IGhpO1xuICAgICAgICBoaSBePSBsbztcbiAgICAgICAgbG8gXj0gaGk7XG4gICAgICAgIG4gLT0gMzI7XG4gICAgfVxuICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgIHZbaSAqIDJdID0gaGkgPj4+IDA7XG4gICAgICAgIHZbaSAqIDIgKyAxXSA9IGxvID4+PiAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdltpICogMl0gPSAoKGhpID4+PiBuKSB8IChsbyA8PCAoMzIgLSBuKSkpID4+PiAwO1xuICAgICAgICB2W2kgKiAyICsgMV0gPSAoKGxvID4+PiBuKSB8IChoaSA8PCAoMzIgLSBuKSkpID4+PiAwO1xuICAgIH1cbn1cbi8qKlxuICogVGhlIEcgZnVuY3Rpb24gaXMgb25lIG9mIHRoZSBjb3JlIG9wZXJhdGlvbnMgaW4gdGhlIEJsYWtlLTUxMiBjb21wcmVzc2lvbiBmdW5jdGlvbi5cbiAqIEl0IG1peGVzIHRoZSBpbnB1dCB2YWx1ZXMgYmFzZWQgb24gdGhlIG1lc3NhZ2UgYmxvY2sgYW5kIHRoZSByb3VuZCBjb25zdGFudHMsXG4gKiBjb250cmlidXRpbmcgdG8gdGhlIGRpZmZ1c2lvbiBhbmQgY29uZnVzaW9uIHByb3BlcnRpZXMgb2YgdGhlIGhhc2ggZnVuY3Rpb24uXG4gKiBAcGFyYW0gdiBUaGUgd29ya2luZyB2ZWN0b3IsIHBhcnQgb2YgdGhlIHN0YXRlIGJlaW5nIHVwZGF0ZWQuXG4gKiBAcGFyYW0gbSAtIFRoZSBtZXNzYWdlIGJsb2NrIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSBpIFRoZSBjdXJyZW50IHJvdW5kIGluZGV4LlxuICogQHBhcmFtIGEsIGIsIGMsIGQgSW5kaWNlcyB3aXRoaW4gdGhlIHdvcmtpbmcgdmVjdG9yIHRvIG1peC5cbiAqIEBwYXJhbSBlIEluZGV4IHdpdGhpbiB0aGUgbWVzc2FnZSBibG9jayBhbmQgcm91bmQgY29uc3RhbnRzLlxuICovXG5mdW5jdGlvbiBnKHYsIG0sIGksIGEsIGIsIGMsIGQsIGUpIHtcbiAgICBsZXQgbG87XG4gICAgLy8gdlthXSArPSAobVtzaWdtYVtpXVtlXV0gXiB1NTEyW3NpZ21hW2ldW2UrMV1dKSArIHZbYl07XG4gICAgbG8gPSB2W2EgKiAyICsgMV0gKyAoKG1bc2lnbWFbaV1bZV0gKiAyICsgMV0gXiB1NTEyW3NpZ21hW2ldW2UgKyAxXSAqIDIgKyAxXSkgPj4+IDApICsgdltiICogMiArIDFdO1xuICAgIHZbYSAqIDJdID1cbiAgICAgICAgKHZbYSAqIDJdICsgKChtW3NpZ21hW2ldW2VdICogMl0gXiB1NTEyW3NpZ21hW2ldW2UgKyAxXSAqIDJdKSA+Pj4gMCkgKyB2W2IgKiAyXSArIH5+KGxvIC8gMHgwMTAwMDAwMDAwKSkgPj4+IDA7XG4gICAgdlthICogMiArIDFdID0gbG8gPj4+IDA7XG4gICAgLy8gdltkXSA9IFJPVCggdltkXSBeIHZbYV0sMzIpO1xuICAgIHJvdCh2LCBkLCBhLCAzMik7XG4gICAgLy8gdltjXSArPSB2W2RdO1xuICAgIGxvID0gdltjICogMiArIDFdICsgdltkICogMiArIDFdO1xuICAgIHZbYyAqIDJdID0gKHZbYyAqIDJdICsgdltkICogMl0gKyB+fihsbyAvIDB4MDEwMDAwMDAwMCkpID4+PiAwO1xuICAgIHZbYyAqIDIgKyAxXSA9IGxvID4+PiAwO1xuICAgIC8vIHZbYl0gPSBST1QoIHZbYl0gXiB2W2NdLDI1KTtcbiAgICByb3QodiwgYiwgYywgMjUpO1xuICAgIC8vIHZbYV0gKz0gKG1bc2lnbWFbaV1bZSsxXV0gXiB1NTEyW3NpZ21hW2ldW2VdXSkrdltiXTtcbiAgICBsbyA9IHZbYSAqIDIgKyAxXSArICgobVtzaWdtYVtpXVtlICsgMV0gKiAyICsgMV0gXiB1NTEyW3NpZ21hW2ldW2VdICogMiArIDFdKSA+Pj4gMCkgKyB2W2IgKiAyICsgMV07XG4gICAgdlthICogMl0gPVxuICAgICAgICAodlthICogMl0gKyAoKG1bc2lnbWFbaV1bZSArIDFdICogMl0gXiB1NTEyW3NpZ21hW2ldW2VdICogMl0pID4+PiAwKSArIHZbYiAqIDJdICsgfn4obG8gLyAweDAxMDAwMDAwMDApKSA+Pj4gMDtcbiAgICB2W2EgKiAyICsgMV0gPSBsbyA+Pj4gMDtcbiAgICAvLyB2W2RdID0gUk9UKCB2W2RdIF4gdlthXSwxNik7XG4gICAgcm90KHYsIGQsIGEsIDE2KTtcbiAgICAvLyB2W2NdICs9IHZbZF07XG4gICAgbG8gPSB2W2MgKiAyICsgMV0gKyB2W2QgKiAyICsgMV07XG4gICAgdltjICogMl0gPSAodltjICogMl0gKyB2W2QgKiAyXSArIH5+KGxvIC8gMHgwMTAwMDAwMDAwKSkgPj4+IDA7XG4gICAgdltjICogMiArIDFdID0gbG8gPj4+IDA7XG4gICAgLy8gdltiXSA9IFJPVCggdltiXSBeIHZbY10sMTEpXG4gICAgcm90KHYsIGIsIGMsIDExKTtcbn1cbi8qKlxuICogUHJvY2Vzc2VzIHRoZSBjYXJyeSBmb3IgdGhlIGJpdCBsZW5ndGggY291bnRlciwgZW5zdXJpbmcgaXQgcmVtYWluc1xuICogd2l0aGluIGJvdW5kcyBhcyBhIDEyOC1iaXQgbnVtYmVyLlxuICogQHBhcmFtIGFyciBUaGUgYXJyYXkgcmVwcmVzZW50aW5nIHRoZSAxMjgtYml0IGNvdW50ZXIuXG4gKi9cbmZ1bmN0aW9uIGxlbmd0aENhcnJ5KGFycikge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgYXJyLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgIGlmIChhcnJbal0gPCAweDAxMDAwMDAwMDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgYXJyW2pdIC09IDB4MDEwMDAwMDAwMDtcbiAgICAgICAgYXJyW2ogKyAxXSArPSAxO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhIEJsYWtlLTUxMiBoYXNoIGNvbXB1dGF0aW9uIGluc3RhbmNlLlxuICogVGhpcyBjbGFzcyBtYWludGFpbnMgdGhlIGludGVybmFsIHN0YXRlLCBidWZmZXJzLCBhbmQgY291bnRlcnMgbmVlZGVkIHRvXG4gKiBwcm9jZXNzIGlucHV0IGRhdGEgYW5kIHByb2R1Y2UgdGhlIGZpbmFsIGhhc2ggb3V0cHV0LiBJdCBzdXBwb3J0cyBpbmNyZW1lbnRhbFxuICogaGFzaGluZywgYWxsb3dpbmcgZGF0YSB0byBiZSBhZGRlZCBpbiBjaHVua3MuXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9wcmVmZXItZGVmYXVsdC1leHBvcnQgKi9cbmNsYXNzIEJsYWtlNTEyIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhIG5ldyBCbGFrZS01MTIgaGFzaCBpbnN0YW5jZSB3aXRoIHRoZSBkZWZhdWx0IHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2ggPSBbXG4gICAgICAgICAgICAweDZhMDllNjY3LCAweGYzYmNjOTA4LCAweGJiNjdhZTg1LCAweDg0Y2FhNzNiLCAweDNjNmVmMzcyLCAweGZlOTRmODJiLCAweGE1NGZmNTNhLCAweDVmMWQzNmYxLCAweDUxMGU1MjdmLFxuICAgICAgICAgICAgMHhhZGU2ODJkMSwgMHg5YjA1Njg4YywgMHgyYjNlNmMxZiwgMHgxZjgzZDlhYiwgMHhmYjQxYmQ2YiwgMHg1YmUwY2QxOSwgMHgxMzdlMjE3OVxuICAgICAgICBdO1xuICAgICAgICB0aGlzLl9zID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdO1xuICAgICAgICB0aGlzLl9ibG9jayA9IEJ1ZmZlci5hbGxvYygxMjgpO1xuICAgICAgICB0aGlzLl9ibG9ja09mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgdGhpcy5fbnVsbHQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fem8gPSB6bztcbiAgICAgICAgdGhpcy5fb28gPSBvbztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNvcmUgY29tcHJlc3Npb24gZnVuY3Rpb24gZm9yIEJsYWtlLTUxMi4gSXQgdHJhbnNmb3JtcyB0aGUgaW50ZXJuYWxcbiAgICAgKiBzdGF0ZSBiYXNlZCBvbiB0aGUgaW5wdXQgYmxvY2sgYW5kIHRoZSBjdXJyZW50IGhhc2ggcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgICBfY29tcHJlc3MoKSB7XG4gICAgICAgIGNvbnN0IHYgPSBuZXcgQXJyYXkoMzIpO1xuICAgICAgICBjb25zdCBtID0gbmV3IEFycmF5KDMyKTtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAzMjsgaSArPSAxKVxuICAgICAgICAgICAgbVtpXSA9IHRoaXMuX2Jsb2NrLnJlYWRVSW50MzJCRShpICogNCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSArPSAxKVxuICAgICAgICAgICAgdltpXSA9IHRoaXMuX2hbaV0gPj4+IDA7XG4gICAgICAgIGZvciAoaSA9IDE2OyBpIDwgMjQ7IGkgKz0gMSlcbiAgICAgICAgICAgIHZbaV0gPSAodGhpcy5fc1tpIC0gMTZdIF4gdTUxMltpIC0gMTZdKSA+Pj4gMDtcbiAgICAgICAgZm9yIChpID0gMjQ7IGkgPCAzMjsgaSArPSAxKVxuICAgICAgICAgICAgdltpXSA9IHU1MTJbaSAtIDE2XTtcbiAgICAgICAgaWYgKCF0aGlzLl9udWxsdCkge1xuICAgICAgICAgICAgdlsyNF0gPSAodlsyNF0gXiB0aGlzLl9sZW5ndGhbMV0pID4+PiAwO1xuICAgICAgICAgICAgdlsyNV0gPSAodlsyNV0gXiB0aGlzLl9sZW5ndGhbMF0pID4+PiAwO1xuICAgICAgICAgICAgdlsyNl0gPSAodlsyNl0gXiB0aGlzLl9sZW5ndGhbMV0pID4+PiAwO1xuICAgICAgICAgICAgdlsyN10gPSAodlsyN10gXiB0aGlzLl9sZW5ndGhbMF0pID4+PiAwO1xuICAgICAgICAgICAgdlsyOF0gPSAodlsyOF0gXiB0aGlzLl9sZW5ndGhbM10pID4+PiAwO1xuICAgICAgICAgICAgdlsyOV0gPSAodlsyOV0gXiB0aGlzLl9sZW5ndGhbMl0pID4+PiAwO1xuICAgICAgICAgICAgdlszMF0gPSAodlszMF0gXiB0aGlzLl9sZW5ndGhbM10pID4+PiAwO1xuICAgICAgICAgICAgdlszMV0gPSAodlszMV0gXiB0aGlzLl9sZW5ndGhbMl0pID4+PiAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSArPSAxKSB7XG4gICAgICAgICAgICAvKiBjb2x1bW4gc3RlcCAqL1xuICAgICAgICAgICAgZyh2LCBtLCBpLCAwLCA0LCA4LCAxMiwgMCk7XG4gICAgICAgICAgICBnKHYsIG0sIGksIDEsIDUsIDksIDEzLCAyKTtcbiAgICAgICAgICAgIGcodiwgbSwgaSwgMiwgNiwgMTAsIDE0LCA0KTtcbiAgICAgICAgICAgIGcodiwgbSwgaSwgMywgNywgMTEsIDE1LCA2KTtcbiAgICAgICAgICAgIC8qIGRpYWdvbmFsIHN0ZXAgKi9cbiAgICAgICAgICAgIGcodiwgbSwgaSwgMCwgNSwgMTAsIDE1LCA4KTtcbiAgICAgICAgICAgIGcodiwgbSwgaSwgMSwgNiwgMTEsIDEyLCAxMCk7XG4gICAgICAgICAgICBnKHYsIG0sIGksIDIsIDcsIDgsIDEzLCAxMik7XG4gICAgICAgICAgICBnKHYsIG0sIGksIDMsIDQsIDksIDE0LCAxNCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDE2OyBpICs9IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX2hbKGkgJSA4KSAqIDJdID0gKHRoaXMuX2hbKGkgJSA4KSAqIDJdIF4gdltpICogMl0pID4+PiAwO1xuICAgICAgICAgICAgdGhpcy5faFsoaSAlIDgpICogMiArIDFdID0gKHRoaXMuX2hbKGkgJSA4KSAqIDIgKyAxXSBeIHZbaSAqIDIgKyAxXSkgPj4+IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdGhpcy5faFtpICogMl0gPSAodGhpcy5faFtpICogMl0gXiB0aGlzLl9zWyhpICUgNCkgKiAyXSkgPj4+IDA7XG4gICAgICAgICAgICB0aGlzLl9oW2kgKiAyICsgMV0gPSAodGhpcy5faFtpICogMiArIDFdIF4gdGhpcy5fc1soaSAlIDQpICogMiArIDFdKSA+Pj4gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHBhZGRpbmcgdG8gdGhlIG1lc3NhZ2UgYXMgcGVyIHRoZSBCbGFrZS01MTIgc3BlY2lmaWNhdGlvbiwgZW5zdXJpbmdcbiAgICAgKiB0aGUgbWVzc2FnZSBsZW5ndGggaXMgYSBtdWx0aXBsZSBvZiB0aGUgYmxvY2sgc2l6ZS5cbiAgICAgKi9cbiAgICBfcGFkZGluZygpIHtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5fbGVuZ3RoLnNsaWNlKCk7XG4gICAgICAgIGxlblswXSArPSB0aGlzLl9ibG9ja09mZnNldCAqIDg7XG4gICAgICAgIGxlbmd0aENhcnJ5KGxlbik7XG4gICAgICAgIGNvbnN0IG1zZ2xlbiA9IEJ1ZmZlci5hbGxvYygxNik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSArPSAxKVxuICAgICAgICAgICAgbXNnbGVuLndyaXRlVUludDMyQkUobGVuWzMgLSBpXSwgaSAqIDQpO1xuICAgICAgICBpZiAodGhpcy5fYmxvY2tPZmZzZXQgPT09IDExMSkge1xuICAgICAgICAgICAgdGhpcy5fbGVuZ3RoWzBdIC09IDg7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh0aGlzLl9vbyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fYmxvY2tPZmZzZXQgPCAxMTEpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYmxvY2tPZmZzZXQgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX251bGx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sZW5ndGhbMF0gLT0gKDExMSAtIHRoaXMuX2Jsb2NrT2Zmc2V0KSAqIDg7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUocGFkZGluZy5zdWJhcnJheSgwLCAxMTEgLSB0aGlzLl9ibG9ja09mZnNldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGVuZ3RoWzBdIC09ICgxMjggLSB0aGlzLl9ibG9ja09mZnNldCkgKiA4O1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKHBhZGRpbmcuc3ViYXJyYXkoMCwgMTI4IC0gdGhpcy5fYmxvY2tPZmZzZXQpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sZW5ndGhbMF0gLT0gMTExICogODtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZShwYWRkaW5nLnN1YmFycmF5KDEsIDEgKyAxMTEpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9udWxsdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh0aGlzLl96byk7XG4gICAgICAgICAgICB0aGlzLl9sZW5ndGhbMF0gLT0gODtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sZW5ndGhbMF0gLT0gMTI4O1xuICAgICAgICB0aGlzLnVwZGF0ZShtc2dsZW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wbGV0ZXMgdGhlIGhhc2ggY29tcHV0YXRpb24gYW5kIHJldHVybnMgdGhlIGZpbmFsIGhhc2ggdmFsdWUuXG4gICAgICogVGhpcyBtZXRob2QgYXBwbGllcyB0aGUgbmVjZXNzYXJ5IHBhZGRpbmcsIHBlcmZvcm1zIHRoZSBmaW5hbCBjb21wcmVzc2lvbixcbiAgICAgKiBhbmQgcmV0dXJucyB0aGUgaGFzaCBvdXRwdXQuXG4gICAgICogQHJldHVybnMgVGhlIEJsYWtlLTUxMiBoYXNoIG9mIHRoZSBpbnB1dCBkYXRhLlxuICAgICAqL1xuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgdGhpcy5fcGFkZGluZygpO1xuICAgICAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoNjQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpICs9IDEpXG4gICAgICAgICAgICBidWZmZXIud3JpdGVVSW50MzJCRSh0aGlzLl9oW2ldLCBpICogNCk7XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGhhc2ggd2l0aCBuZXcgZGF0YS4gVGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCBtdWx0aXBsZVxuICAgICAqIHRpbWVzIHRvIGluY3JlbWVudGFsbHkgYWRkIGRhdGEgdG8gdGhlIGhhc2ggY29tcHV0YXRpb24uXG4gICAgICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gYWRkIHRvIHRoZSBoYXNoLlxuICAgICAqIEByZXR1cm5zIFRoaXMgaW5zdGFuY2UsIHRvIGFsbG93IG1ldGhvZCBjaGFpbmluZy5cbiAgICAgKi9cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBjb25zdCBibG9jayA9IHRoaXMuX2Jsb2NrO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgd2hpbGUgKHRoaXMuX2Jsb2NrT2Zmc2V0ICsgZGF0YS5sZW5ndGggLSBvZmZzZXQgPj0gYmxvY2subGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fYmxvY2tPZmZzZXQ7IGkgPCBibG9jay5sZW5ndGg7KVxuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXBsdXNwbHVzICovXG4gICAgICAgICAgICAgICAgYmxvY2tbaSsrXSA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgICAgdGhpcy5fbGVuZ3RoWzBdICs9IGJsb2NrLmxlbmd0aCAqIDg7XG4gICAgICAgICAgICBsZW5ndGhDYXJyeSh0aGlzLl9sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5fY29tcHJlc3MoKTtcbiAgICAgICAgICAgIHRoaXMuX2Jsb2NrT2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAob2Zmc2V0IDwgZGF0YS5sZW5ndGgpXG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wbHVzcGx1cyAqL1xuICAgICAgICAgICAgYmxvY2tbdGhpcy5fYmxvY2tPZmZzZXQrK10gPSBkYXRhW29mZnNldCsrXTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG4vKipcbiAqIFBydW5lcyBhIGJ1ZmZlciB0byBtZWV0IHRoZSBzcGVjaWZpYyByZXF1aXJlbWVudHMgZm9yIHVzaW5nIGl0IGFzIGEgcHJpdmF0ZSBrZXlcbiAqIG9yIHBhcnQgb2YgYSBzaWduYXR1cmUuXG4gKiBAcGFyYW0gYnVmZiBUaGUgYnVmZmVyIHRvIGJlIHBydW5lZC5cbiAqIEByZXR1cm5zIFRoZSBwcnVuZWQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBwcnVuZUJ1ZmZlcihidWZmKSB7XG4gICAgYnVmZlswXSAmPSAweGY4O1xuICAgIGJ1ZmZbMzFdICY9IDB4N2Y7XG4gICAgYnVmZlszMV0gfD0gMHg0MDtcbiAgICByZXR1cm4gYnVmZjtcbn1cbi8qKlxuICogVmFsaWRhdGVzIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgYSB2YWxpZCBwb2ludCBvbiB0aGUgQmFieSBKdWJqdWIgZWxsaXB0aWMgY3VydmUuXG4gKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IHRvIHZhbGlkYXRlLlxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGEgdmFsaWQgcG9pbnQsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNQb2ludChwb2ludCkge1xuICAgIHJldHVybiBpc0FycmF5KHBvaW50KSAmJiBwb2ludC5sZW5ndGggPT09IDIgJiYgaXNCaWdOdW1iZXIocG9pbnRbMF0pICYmIGlzQmlnTnVtYmVyKHBvaW50WzFdKTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwcm92aWRlZCBvYmplY3QgY29uZm9ybXMgdG8gdGhlIGV4cGVjdGVkIGZvcm1hdCBvZiBhIFNpZ25hdHVyZS5cbiAqIEBwYXJhbSBzaWduYXR1cmUgVGhlIHNpZ25hdHVyZSB0byB2YWxpZGF0ZS5cbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG9iamVjdCBpcyBhIHZhbGlkIFNpZ25hdHVyZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc1NpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gKGlzT2JqZWN0KHNpZ25hdHVyZSkgJiZcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNpZ25hdHVyZSwgXCJSOFwiKSAmJlxuICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2lnbmF0dXJlLCBcIlNcIikgJiZcbiAgICAgICAgaXNQb2ludChzaWduYXR1cmUuUjgpICYmXG4gICAgICAgIGlzQmlnTnVtYmVyKHNpZ25hdHVyZS5TKSk7XG59XG4vKipcbiAqIFZhbGlkYXRlcyBhbmQgY29udmVydHMgYSBCaWdOdW1iZXJpc2ggcHJpdmF0ZSBrZXkgdG8gYSBCdWZmZXIuXG4gKiBAcGFyYW0gcHJpdmF0ZUtleSBUaGUgcHJpdmF0ZSBrZXkgdG8gY2hlY2sgYW5kIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgcHJpdmF0ZSBrZXkgYXMgYSBCdWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XG4gICAgcmVxdWlyZVR5cGVzKHByaXZhdGVLZXksIFwicHJpdmF0ZUtleVwiLCBbXCJCdWZmZXJcIiwgXCJVaW50OEFycmF5XCIsIFwic3RyaW5nXCJdKTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20ocHJpdmF0ZUtleSk7XG59XG4vKipcbiAqIFZhbGlkYXRlcyBhbmQgY29udmVydHMgYSBCaWdOdW1iZXJpc2ggbWVzc2FnZSB0byBhIGJpZ2ludC5cbiAqIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGNoZWNrIGFuZCBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIG1lc3NhZ2UgYXMgYSBiaWdpbnQuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgcmVxdWlyZVR5cGVzKG1lc3NhZ2UsIFwibWVzc2FnZVwiLCBbXCJiaWdudW1iZXJpc2hcIiwgXCJzdHJpbmdcIl0pO1xuICAgIGlmIChpc0JpZ051bWJlcmlzaChtZXNzYWdlKSkge1xuICAgICAgICByZXR1cm4gYmlnTnVtYmVyaXNoVG9CaWdJbnQobWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXJUb0JpZ0ludChCdWZmZXIuZnJvbShtZXNzYWdlKSk7XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBCbGFrZTUxMiBoYXNoIG9mIHRoZSBpbnB1dCBtZXNzYWdlLlxuICogQmxha2U1MTIgaXMgYSBjcnlwdG9ncmFwaGljIGhhc2ggZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBhIGhhc2ggdmFsdWUgb2YgNTEyIGJpdHMsXG4gKiBjb21tb25seSB1c2VkIGZvciBkYXRhIGludGVncml0eSBjaGVja3MgYW5kIG90aGVyIGNyeXB0b2dyYXBoaWMgYXBwbGljYXRpb25zLlxuICogQHBhcmFtIG1lc3NhZ2UgVGhlIGlucHV0IGRhdGEgdG8gaGFzaCwgcHJvdmlkZWQgYXMgYSBCdWZmZXIuXG4gKiBAcmV0dXJucyBBIEJ1ZmZlciBjb250YWluaW5nIHRoZSA1MTItYml0IGhhc2ggcmVzdWx0LlxuICovXG5mdW5jdGlvbiBoYXNoKG1lc3NhZ2UpIHtcbiAgICBjb25zdCBlbmdpbmUgPSBuZXcgQmxha2U1MTIoKTtcbiAgICBlbmdpbmUudXBkYXRlKEJ1ZmZlci5mcm9tKG1lc3NhZ2UpKTtcbiAgICByZXR1cm4gZW5naW5lLmRpZ2VzdCgpO1xufVxuXG4vKipcbiAqIERlcml2ZXMgYSBzZWNyZXQgc2NhbGFyIGZyb20gYSBnaXZlbiBFZERTQSBwcml2YXRlIGtleS5cbiAqXG4gKiBUaGlzIHByb2Nlc3MgaW52b2x2ZXMgaGFzaGluZyB0aGUgcHJpdmF0ZSBrZXkgd2l0aCBCbGFrZTEsIHBydW5pbmcgdGhlIHJlc3VsdGluZyBoYXNoIHRvIHJldGFpbiB0aGUgbG93ZXIgMzIgYnl0ZXMsXG4gKiBhbmQgY29udmVydGluZyBpdCBpbnRvIGEgbGl0dGxlLWVuZGlhbiBpbnRlZ2VyLiBUaGUgdXNlIG9mIHRoZSBzZWNyZXQgc2NhbGFyIHN0cmVhbWxpbmVzIHRoZSBwdWJsaWMga2V5IGdlbmVyYXRpb25cbiAqIHByb2Nlc3MgYnkgb21pdHRpbmcgc3RlcHMgMSwgMiwgYW5kIDMgYXMgb3V0bGluZWQgaW4gUkZDIDgwMzIgc2VjdGlvbiA1LjEuNSwgZW5oYW5jaW5nIGNpcmN1aXQgZWZmaWNpZW5jeSBhbmQgc2ltcGxpY2l0eS5cbiAqIFRoaXMgbWV0aG9kIGlzIGNydWNpYWwgZm9yIGZpeGVkLWJhc2Ugc2NhbGFyIG11bHRpcGxpY2F0aW9uIG9wZXJhdGlvbnMgd2l0aGluIHRoZSBjb3JyZXNwb25kZW50IGNyeXB0b2dyYXBoaWMgY2lyY3VpdC5cbiAqIEZvciBkZXRhaWxlZCBzdGVwcywgc2VlOiB7QGxpbmsgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM4MDMyI3NlY3Rpb24tNS4xLjV9LlxuICogRm9yIGV4YW1wbGUgdXNhZ2UgaW4gYSBjaXJjdWl0LCBzZWU6IHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vc2VtYXBob3JlLXByb3RvY29sL3NlbWFwaG9yZS9ibG9iLzJjMTQ0ZmM5ZTU1YjMwYWQwOTQ3NGFlYWZhNzYzYzQxMTUzMzg0MDkvcGFja2FnZXMvY2lyY3VpdHMvc2VtYXBob3JlLmNpcmNvbSNMMjF9XG4gKlxuICogVGhlIHByaXZhdGUga2V5IG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgQnVmZmVyLCBVaW50OEFycmF5IG9yIGEgc3RyaW5nLiBUaGUgaW5wdXQgd2lsbCBiZSB1c2VkIHRvXG4gKiBnZW5lcmF0ZSBlbnRyb3B5IGFuZCB0aGVyZSBpcyBubyBsaW1pdCBpbiBzaXplLlxuICogVGhlIHN0cmluZyBpcyB1c2VkIGFzIGEgc2V0IG9mIHJhdyBieXRlcyAoaW4gVVRGLTgpIGFuZCBpcyB0eXBpY2FsbHkgdXNlZCB0byBwYXNzIHBhc3N3b3JkcyBvciBzZWNyZXQgbWVzc2FnZXMuXG4gKiBJZiB5b3Ugd2FudCB0byBwYXNzIGEgYmlnaW50LCBhIG51bWJlciBvciBhIGhleGFkZWNpbWFsLCBiZSBzdXJlIHRvIGNvbnZlcnQgdGhlbSB0byBvbmUgb2YgdGhlIHN1cHBvcnRlZCB0eXBlcyBmaXJzdC5cbiAqIFRoZSAnY29udmVyc2lvbnMnIG1vZHVsZSBpbiBAemsta2l0L3V0aWxzIHByb3ZpZGVzIGEgc2V0IG9mIGZ1bmN0aW9ucyB0aGF0IG1heSBiZSB1c2VmdWwgaW4gY2FzZSB5b3UgbmVlZCB0byBjb252ZXJ0IHR5cGVzLlxuICpcbiAqIEBwYXJhbSBwcml2YXRlS2V5IFRoZSBFZERTQSBwcml2YXRlIGtleSBmb3IgZ2VuZXJhdGluZyB0aGUgYXNzb2NpYXRlZCBwdWJsaWMga2V5LlxuICogQHJldHVybnMgVGhlIGRlcml2ZWQgc2VjcmV0IHNjYWxhciB0byBiZSB1c2VkIHRvIGNhbGN1bGF0ZSBwdWJsaWMga2V5IGFuZCBvcHRpbWl6ZWQgZm9yIGNpcmN1aXQgY2FsY3VsYXRpb25zLlxuICovXG5mdW5jdGlvbiBkZXJpdmVTZWNyZXRTY2FsYXIocHJpdmF0ZUtleSkge1xuICAgIC8vIENvbnZlcnQgdGhlIHByaXZhdGUga2V5IHRvIGJ1ZmZlci5cbiAgICBwcml2YXRlS2V5ID0gY2hlY2tQcml2YXRlS2V5KHByaXZhdGVLZXkpO1xuICAgIGxldCBoYXNoJDEgPSBoYXNoKHByaXZhdGVLZXkpO1xuICAgIGhhc2gkMSA9IGhhc2gkMS5zbGljZSgwLCAzMik7XG4gICAgaGFzaCQxID0gcHJ1bmVCdWZmZXIoaGFzaCQxKTtcbiAgICByZXR1cm4gc2NhbGFyLnNoaWZ0UmlnaHQobGVCdWZmZXJUb0JpZ0ludChoYXNoJDEpLCBCaWdJbnQoMykpICUgc3ViT3JkZXI7XG59XG4vKipcbiAqIERlcml2ZXMgYSBwdWJsaWMga2V5IGZyb20gYSBnaXZlbiBwcml2YXRlIGtleSB1c2luZyB0aGVcbiAqIHtAbGluayBodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTI0OTR8QmFieSBKdWJqdWJ9IGVsbGlwdGljIGN1cnZlLlxuICogVGhpcyBmdW5jdGlvbiB1dGlsaXplcyB0aGUgQmFieSBKdWJqdWIgZWxsaXB0aWMgY3VydmUgZm9yIGNyeXB0b2dyYXBoaWMgb3BlcmF0aW9ucy5cbiAqIFRoZSBwcml2YXRlIGtleSBzaG91bGQgYmUgc2VjdXJlbHkgc3RvcmVkIGFuZCBtYW5hZ2VkLCBhbmQgaXQgc2hvdWxkIG5ldmVyIGJlIGV4cG9zZWRcbiAqIG9yIHRyYW5zbWl0dGVkIGluIGFuIHVuc2VjdXJlZCBtYW5uZXIuXG4gKlxuICogVGhlIHByaXZhdGUga2V5IG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgQnVmZmVyLCBVaW50OEFycmF5IG9yIGEgc3RyaW5nLiBUaGUgaW5wdXQgd2lsbCBiZSB1c2VkIHRvXG4gKiBnZW5lcmF0ZSBlbnRyb3B5IGFuZCB0aGVyZSBpcyBubyBsaW1pdCBpbiBzaXplLlxuICogVGhlIHN0cmluZyBpcyB1c2VkIGFzIGEgc2V0IG9mIHJhdyBieXRlcyAoaW4gVVRGLTgpIGFuZCBpcyB0eXBpY2FsbHkgdXNlZCB0byBwYXNzIHBhc3N3b3JkcyBvciBzZWNyZXQgbWVzc2FnZXMuXG4gKiBJZiB5b3Ugd2FudCB0byBwYXNzIGEgYmlnaW50LCBhIG51bWJlciBvciBhIGhleGFkZWNpbWFsLCBiZSBzdXJlIHRvIGNvbnZlcnQgdGhlbSB0byBvbmUgb2YgdGhlIHN1cHBvcnRlZCB0eXBlcyBmaXJzdC5cbiAqIFRoZSAnY29udmVyc2lvbnMnIG1vZHVsZSBpbiBAemsta2l0L3V0aWxzIHByb3ZpZGVzIGEgc2V0IG9mIGZ1bmN0aW9ucyB0aGF0IG1heSBiZSB1c2VmdWwgaW4gY2FzZSB5b3UgbmVlZCB0byBjb252ZXJ0IHR5cGVzLlxuICpcbiAqIEBwYXJhbSBwcml2YXRlS2V5IFRoZSBwcml2YXRlIGtleSB1c2VkIGZvciBnZW5lcmF0aW5nIHRoZSBwdWJsaWMga2V5LlxuICogQHJldHVybnMgVGhlIGRlcml2ZWQgcHVibGljIGtleS5cbiAqL1xuZnVuY3Rpb24gZGVyaXZlUHVibGljS2V5KHByaXZhdGVLZXkpIHtcbiAgICBjb25zdCBzID0gZGVyaXZlU2VjcmV0U2NhbGFyKHByaXZhdGVLZXkpO1xuICAgIHJldHVybiBtdWxQb2ludEVzY2FsYXIoQmFzZTgsIHMpO1xufVxuLyoqXG4gKiBTaWducyBhIG1lc3NhZ2UgdXNpbmcgdGhlIHByb3ZpZGVkIHByaXZhdGUga2V5LCBlbXBsb3lpbmcgUG9zZWlkb24gaGFzaGluZyBhbmRcbiAqIEVkRFNBIHdpdGggdGhlIEJhYnkgSnVianViIGVsbGlwdGljIGN1cnZlLlxuICpcbiAqIFRoZSBwcml2YXRlIGtleSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEJ1ZmZlciwgVWludDhBcnJheSBvciBhIHN0cmluZy4gVGhlIGlucHV0IHdpbGwgYmUgdXNlZCB0b1xuICogZ2VuZXJhdGUgZW50cm9weSBhbmQgdGhlcmUgaXMgbm8gbGltaXQgaW4gc2l6ZS5cbiAqIFRoZSBzdHJpbmcgaXMgdXNlZCBhcyBhIHNldCBvZiByYXcgYnl0ZXMgKGluIFVURi04KSBhbmQgaXMgdHlwaWNhbGx5IHVzZWQgdG8gcGFzcyBwYXNzd29yZHMgb3Igc2VjcmV0IG1lc3NhZ2VzLlxuICogSWYgeW91IHdhbnQgdG8gcGFzcyBhIGJpZ2ludCwgYSBudW1iZXIgb3IgYSBoZXhhZGVjaW1hbCwgYmUgc3VyZSB0byBjb252ZXJ0IHRoZW0gdG8gb25lIG9mIHRoZSBzdXBwb3J0ZWQgdHlwZXMgZmlyc3QuXG4gKiBUaGUgJ2NvbnZlcnNpb25zJyBtb2R1bGUgaW4gQHprLWtpdC91dGlscyBwcm92aWRlcyBhIHNldCBvZiBmdW5jdGlvbnMgdGhhdCBtYXkgYmUgdXNlZnVsIGluIGNhc2UgeW91IG5lZWQgdG8gY29udmVydCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0gcHJpdmF0ZUtleSBUaGUgcHJpdmF0ZSBrZXkgdXNlZCB0byBzaWduIHRoZSBtZXNzYWdlLlxuICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gYmUgc2lnbmVkLlxuICogQHJldHVybnMgVGhlIHNpZ25hdHVyZSBvYmplY3QsIGNvbnRhaW5pbmcgcHJvcGVydGllcyByZWxldmFudCB0byBFZERTQSBzaWduYXR1cmVzLCBzdWNoIGFzICdSOCcgYW5kICdTJyB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNpZ25NZXNzYWdlKHByaXZhdGVLZXksIG1lc3NhZ2UpIHtcbiAgICAvLyBDb252ZXJ0IHRoZSBwcml2YXRlIGtleSB0byBidWZmZXIuXG4gICAgcHJpdmF0ZUtleSA9IGNoZWNrUHJpdmF0ZUtleShwcml2YXRlS2V5KTtcbiAgICAvLyBDb252ZXJ0IHRoZSBtZXNzYWdlIHRvIGJpZyBpbnRlZ2VyLlxuICAgIG1lc3NhZ2UgPSBjaGVja01lc3NhZ2UobWVzc2FnZSk7XG4gICAgY29uc3QgaGFzaCQxID0gaGFzaChwcml2YXRlS2V5KTtcbiAgICBjb25zdCBzQnVmZiA9IHBydW5lQnVmZmVyKGhhc2gkMS5zbGljZSgwLCAzMikpO1xuICAgIGNvbnN0IHMgPSBsZUJ1ZmZlclRvQmlnSW50KHNCdWZmKTtcbiAgICBjb25zdCBBID0gbXVsUG9pbnRFc2NhbGFyKEJhc2U4LCBzY2FsYXIuc2hpZnRSaWdodChzLCBCaWdJbnQoMykpKTtcbiAgICBjb25zdCBtc2dCdWZmID0gbGVCaWdJbnRUb0J1ZmZlcihtZXNzYWdlLCAzMik7XG4gICAgY29uc3QgckJ1ZmYgPSBoYXNoKEJ1ZmZlci5jb25jYXQoW2hhc2gkMS5zbGljZSgzMiwgNjQpLCBtc2dCdWZmXSkpO1xuICAgIGNvbnN0IEZyID0gbmV3IEYxRmllbGQoc3ViT3JkZXIpO1xuICAgIGNvbnN0IHIgPSBGci5lKGxlQnVmZmVyVG9CaWdJbnQockJ1ZmYpKTtcbiAgICBjb25zdCBSOCA9IG11bFBvaW50RXNjYWxhcihCYXNlOCwgcik7XG4gICAgY29uc3QgaG0gPSBwb3NlaWRvbjUoW1I4WzBdLCBSOFsxXSwgQVswXSwgQVsxXSwgbWVzc2FnZV0pO1xuICAgIGNvbnN0IFMgPSBGci5hZGQociwgRnIubXVsKGhtLCBzKSk7XG4gICAgcmV0dXJuIHsgUjgsIFMgfTtcbn1cbi8qKlxuICogVmVyaWZpZXMgYW4gRWREU0Egc2lnbmF0dXJlIHVzaW5nIHRoZSBCYWJ5IEp1Ymp1YiBlbGxpcHRpYyBjdXJ2ZSBhbmQgUG9zZWlkb24gaGFzaCBmdW5jdGlvbi5cbiAqIEBwYXJhbSBtZXNzYWdlIFRoZSBvcmlnaW5hbCBtZXNzYWdlIHRoYXQgd2FzIGJlIHNpZ25lZC5cbiAqIEBwYXJhbSBzaWduYXR1cmUgVGhlIEVkRFNBIHNpZ25hdHVyZSB0byBiZSB2ZXJpZmllZC5cbiAqIEBwYXJhbSBwdWJsaWNLZXkgVGhlIHB1YmxpYyBrZXkgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcml2YXRlIGtleSB1c2VkIHRvIHNpZ24gdGhlIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyBSZXR1cm5zIHRydWUgaWYgdGhlIHNpZ25hdHVyZSBpcyB2YWxpZCBhbmQgY29ycmVzcG9uZHMgdG8gdGhlIG1lc3NhZ2UgYW5kIHB1YmxpYyBrZXksIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gdmVyaWZ5U2lnbmF0dXJlKG1lc3NhZ2UsIHNpZ25hdHVyZSwgcHVibGljS2V5KSB7XG4gICAgaWYgKCFpc1BvaW50KHB1YmxpY0tleSkgfHxcbiAgICAgICAgIWlzU2lnbmF0dXJlKHNpZ25hdHVyZSkgfHxcbiAgICAgICAgIWluQ3VydmUoc2lnbmF0dXJlLlI4KSB8fFxuICAgICAgICAhaW5DdXJ2ZShwdWJsaWNLZXkpIHx8XG4gICAgICAgIEJpZ0ludChzaWduYXR1cmUuUykgPj0gc3ViT3JkZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBDb252ZXJ0IHRoZSBtZXNzYWdlIHRvIGJpZyBpbnRlZ2VyLlxuICAgIG1lc3NhZ2UgPSBjaGVja01lc3NhZ2UobWVzc2FnZSk7XG4gICAgLy8gQ29udmVydCB0aGUgc2lnbmF0dXJlIHZhbHVlcyB0byBiaWcgaW50ZWdlcnMgZm9yIGNhbGN1bGF0aW9ucy5cbiAgICBjb25zdCBfc2lnbmF0dXJlID0ge1xuICAgICAgICBSODogW0JpZ0ludChzaWduYXR1cmUuUjhbMF0pLCBCaWdJbnQoc2lnbmF0dXJlLlI4WzFdKV0sXG4gICAgICAgIFM6IEJpZ0ludChzaWduYXR1cmUuUylcbiAgICB9O1xuICAgIC8vIENvbnZlcnQgdGhlIHB1YmxpYyBrZXkgdmFsdWVzIHRvIGJpZyBpbnRlZ2VycyBmb3IgY2FsY3VsYXRpb25zLlxuICAgIGNvbnN0IF9wdWJsaWNLZXkgPSBbQmlnSW50KHB1YmxpY0tleVswXSksIEJpZ0ludChwdWJsaWNLZXlbMV0pXTtcbiAgICBjb25zdCBobSA9IHBvc2VpZG9uNShbc2lnbmF0dXJlLlI4WzBdLCBzaWduYXR1cmUuUjhbMV0sIHB1YmxpY0tleVswXSwgcHVibGljS2V5WzFdLCBtZXNzYWdlXSk7XG4gICAgY29uc3QgcExlZnQgPSBtdWxQb2ludEVzY2FsYXIoQmFzZTgsIEJpZ0ludChzaWduYXR1cmUuUykpO1xuICAgIGxldCBwUmlnaHQgPSBtdWxQb2ludEVzY2FsYXIoX3B1YmxpY0tleSwgc2NhbGFyLm11bChobSwgQmlnSW50KDgpKSk7XG4gICAgcFJpZ2h0ID0gYWRkUG9pbnQoX3NpZ25hdHVyZS5SOCwgcFJpZ2h0KTtcbiAgICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgcG9pbnRzIG1hdGNoLlxuICAgIHJldHVybiBGci5lcShwTGVmdFswXSwgcFJpZ2h0WzBdKSAmJiBGci5lcShwTGVmdFsxXSwgcFJpZ2h0WzFdKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBnaXZlbiBwdWJsaWMga2V5IGludG8gYSBwYWNrZWQgKGNvbXByZXNzZWQpIHN0cmluZyBmb3JtYXQgZm9yIGVmZmljaWVudCB0cmFuc21pc3Npb24gYW5kIHN0b3JhZ2UuXG4gKiBUaGlzIG1ldGhvZCBlbnN1cmVzIHRoZSBwdWJsaWMga2V5IGlzIHZhbGlkIGFuZCB3aXRoaW4gdGhlIEJhYnkgSnVianViIGN1cnZlIGJlZm9yZSBwYWNraW5nLlxuICogQHBhcmFtIHB1YmxpY0tleSBUaGUgcHVibGljIGtleSB0byBiZSBwYWNrZWQuXG4gKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcGFja2VkIHB1YmxpYyBrZXkuXG4gKi9cbmZ1bmN0aW9uIHBhY2tQdWJsaWNLZXkocHVibGljS2V5KSB7XG4gICAgaWYgKCFpc1BvaW50KHB1YmxpY0tleSkgfHwgIWluQ3VydmUocHVibGljS2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHB1YmxpYyBrZXlcIik7XG4gICAgfVxuICAgIC8vIENvbnZlcnQgdGhlIHB1YmxpYyBrZXkgdmFsdWVzIHRvIGJpZyBpbnRlZ2VycyBmb3IgY2FsY3VsYXRpb25zLlxuICAgIGNvbnN0IF9wdWJsaWNLZXkgPSBbQmlnSW50KHB1YmxpY0tleVswXSksIEJpZ0ludChwdWJsaWNLZXlbMV0pXTtcbiAgICByZXR1cm4gcGFja1BvaW50KF9wdWJsaWNLZXkpO1xufVxuLyoqXG4gKiBVbnBhY2tzIGEgcHVibGljIGtleSBmcm9tIGl0cyBwYWNrZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGJhY2sgdG8gaXRzIG9yaWdpbmFsIHBvaW50IGZvcm0gb24gdGhlIEJhYnkgSnVianViIGN1cnZlLlxuICogVGhpcyBmdW5jdGlvbiBjaGVja3MgZm9yIHRoZSB2YWxpZGl0eSBvZiB0aGUgaW5wdXQgZm9ybWF0IGJlZm9yZSBhdHRlbXB0aW5nIHRvIHVucGFjay5cbiAqIEBwYXJhbSBwdWJsaWNLZXkgVGhlIHBhY2tlZCBwdWJsaWMga2V5IGFzIGEgYmlnbnVtYmVyaXNoLlxuICogQHJldHVybnMgVGhlIHVucGFja2VkIHB1YmxpYyBrZXkgYXMgYSBwb2ludC5cbiAqL1xuZnVuY3Rpb24gdW5wYWNrUHVibGljS2V5KHB1YmxpY0tleSkge1xuICAgIHJlcXVpcmVCaWdOdW1iZXJpc2gocHVibGljS2V5LCBcInB1YmxpY0tleVwiKTtcbiAgICBjb25zdCB1bnBhY2tlZFB1YmxpY0tleSA9IHVucGFja1BvaW50KGJpZ051bWJlcmlzaFRvQmlnSW50KHB1YmxpY0tleSkpO1xuICAgIGlmICh1bnBhY2tlZFB1YmxpY0tleSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHB1YmxpYyBrZXlcIik7XG4gICAgfVxuICAgIHJldHVybiB1bnBhY2tlZFB1YmxpY0tleTtcbn1cbi8qKlxuICogUGFja3MgYW4gRWREU0Egc2lnbmF0dXJlIGludG8gYSBidWZmZXIgb2YgNjQgYnl0ZXMgZm9yIGVmZmljaWVudCBzdG9yYWdlLlxuICogVXNlIHtAbGluayB1bnBhY2tTaWduYXR1cmV9IHRvIHJldmVyc2UgdGhlIHByb2Nlc3Mgd2l0aG91dCBuZWVkaW5nIHRvIGtub3dcbiAqIHRoZSBkZXRhaWxzIG9mIHRoZSBmb3JtYXQuXG4gKlxuICogVGhlIGJ1ZmZlciBjb250YWlucyB0aGUgUjggcG9pbnQgcGFja2VkIGludCAzMiBieXRlcyAodmlhXG4gKiB7QGxpbmsgcGFja1NpZ25hdHVyZX0pIGZvbGxvd2VkIGJ5IHRoZSBTIHNjYWxhci4gIEFsbCBlbmNvZGluZ3MgYXJlXG4gKiBsaXR0bGUtZW5kaWFuLlxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgdGhlIHNpZ25hdHVyZSB0byBwYWNrXG4gKiBAcmV0dXJucyBhIDY0IGJ5dGUgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIHBhY2tlZCBzaWduYXR1cmVcbiAqL1xuZnVuY3Rpb24gcGFja1NpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgICBpZiAoIWlzU2lnbmF0dXJlKHNpZ25hdHVyZSkgfHwgIWluQ3VydmUoc2lnbmF0dXJlLlI4KSB8fCBCaWdJbnQoc2lnbmF0dXJlLlMpID49IHN1Yk9yZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2lnbmF0dXJlXCIpO1xuICAgIH1cbiAgICBjb25zdCBudW1lcmljU2lnbmF0dXJlID0ge1xuICAgICAgICBSODogc2lnbmF0dXJlLlI4Lm1hcCgoYykgPT4gQmlnSW50KGMpKSxcbiAgICAgICAgUzogQmlnSW50KHNpZ25hdHVyZS5TKVxuICAgIH07XG4gICAgY29uc3QgcGFja2VkUjggPSBwYWNrUG9pbnQobnVtZXJpY1NpZ25hdHVyZS5SOCk7XG4gICAgY29uc3QgcGFja2VkQnl0ZXMgPSBCdWZmZXIuYWxsb2MoNjQpO1xuICAgIHBhY2tlZEJ5dGVzLnNldChsZUJpZ0ludFRvQnVmZmVyKHBhY2tlZFI4LCAzMiksIDApO1xuICAgIHBhY2tlZEJ5dGVzLnNldChsZUJpZ0ludFRvQnVmZmVyKG51bWVyaWNTaWduYXR1cmUuUywgMzIpLCAzMik7XG4gICAgcmV0dXJuIHBhY2tlZEJ5dGVzO1xufVxuLyoqXG4gKiBVbnBhY2tzIGEgc2lnbmF0dXJlIHByb2R1Y2VkIGJ5IHtAbGluayBwYWNrU2lnbmF0dXJlfS4gIFNlZSB0aGF0IGZ1bmN0aW9uXG4gKiBmb3IgdGhlIGRldGFpbHMgb2YgdGhlIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0gcGFja2VkU2lnbmF0dXJlIHRoZSA2NCBieXRlIGJ1ZmZlciB0byB1bnBhY2tcbiAqIEByZXR1cm5zIGEgU2lnbmF0dXJlIHdpdGggbnVtYmVycyBpbiBzdHJpbmcgZm9ybVxuICovXG5mdW5jdGlvbiB1bnBhY2tTaWduYXR1cmUocGFja2VkU2lnbmF0dXJlKSB7XG4gICAgcmVxdWlyZUJ1ZmZlcihwYWNrZWRTaWduYXR1cmUsIFwicGFja2VkU2lnbmF0dXJlXCIpO1xuICAgIGlmIChwYWNrZWRTaWduYXR1cmUubGVuZ3RoICE9PSA2NCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYWNrZWQgc2lnbmF0dXJlIG11c3QgYmUgNjQgYnl0ZXNcIik7XG4gICAgfVxuICAgIGNvbnN0IHNsaWNlUjggPSBwYWNrZWRTaWduYXR1cmUuc3ViYXJyYXkoMCwgMzIpO1xuICAgIGNvbnN0IHNsaWNlUyA9IHBhY2tlZFNpZ25hdHVyZS5zdWJhcnJheSgzMiwgNjQpO1xuICAgIGNvbnN0IHVucGFja2VkUjggPSB1bnBhY2tQb2ludChsZUJ1ZmZlclRvQmlnSW50KHNsaWNlUjgpKTtcbiAgICBpZiAodW5wYWNrZWRSOCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGFja2VkIHNpZ25hdHVyZSBwb2ludCAke3NsaWNlUy50b1N0cmluZyhcImhleFwiKX0uYCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIFI4OiB1bnBhY2tlZFI4LFxuICAgICAgICBTOiBsZUJ1ZmZlclRvQmlnSW50KHNsaWNlUylcbiAgICB9O1xufVxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY3J5cHRvZ3JhcGhpYyBlbnRpdHkgY2FwYWJsZSBvZiBzaWduaW5nIG1lc3NhZ2VzIGFuZCB2ZXJpZnlpbmcgc2lnbmF0dXJlc1xuICogdXNpbmcgdGhlIEVkRFNBIHNjaGVtZSB3aXRoIFBvc2VpZG9uIGhhc2ggYW5kIHRoZSBCYWJ5IEp1Ymp1YiBlbGxpcHRpYyBjdXJ2ZS5cbiAqL1xuY2xhc3MgRWREU0FQb3NlaWRvbiB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2UsIGRlcml2aW5nIG5lY2Vzc2FyeSBjcnlwdG9ncmFwaGljIHBhcmFtZXRlcnMgZnJvbSB0aGUgcHJvdmlkZWQgcHJpdmF0ZSBrZXkuXG4gICAgICogSWYgdGhlIHByaXZhdGUga2V5IGlzIG5vdCBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIsIGEgcmFuZG9tIDMyLWJ5dGUgaGV4YWRlY2ltYWwga2V5IGlzIGdlbmVyYXRlZC5cbiAgICAgKlxuICAgICAqIFRoZSBwcml2YXRlIGtleSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEJ1ZmZlciwgVWludDhBcnJheSBvciBhIHN0cmluZy4gVGhlIGlucHV0IHdpbGwgYmUgdXNlZCB0b1xuICAgICAqIGdlbmVyYXRlIGVudHJvcHkgYW5kIHRoZXJlIGlzIG5vIGxpbWl0IGluIHNpemUuXG4gICAgICogVGhlIHN0cmluZyBpcyB1c2VkIGFzIGEgc2V0IG9mIHJhdyBieXRlcyAoaW4gVVRGLTgpIGFuZCBpcyB0eXBpY2FsbHkgdXNlZCB0byBwYXNzIHBhc3N3b3JkcyBvciBzZWNyZXQgbWVzc2FnZXMuXG4gICAgICogSWYgeW91IHdhbnQgdG8gcGFzcyBhIGJpZ2ludCwgYSBudW1iZXIgb3IgYSBoZXhhZGVjaW1hbCwgYmUgc3VyZSB0byBjb252ZXJ0IHRoZW0gdG8gb25lIG9mIHRoZSBzdXBwb3J0ZWQgdHlwZXMgZmlyc3QuXG4gICAgICogVGhlICdjb252ZXJzaW9ucycgbW9kdWxlIGluIEB6ay1raXQvdXRpbHMgcHJvdmlkZXMgYSBzZXQgb2YgZnVuY3Rpb25zIHRoYXQgbWF5IGJlIHVzZWZ1bCBpbiBjYXNlIHlvdSBuZWVkIHRvIGNvbnZlcnQgdHlwZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUtleSBUaGUgcHJpdmF0ZSBrZXkgdXNlZCBmb3Igc2lnbmluZyBhbmQgcHVibGljIGtleSBkZXJpdmF0aW9uLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByaXZhdGVLZXkgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKDMyKSkge1xuICAgICAgICB0aGlzLnByaXZhdGVLZXkgPSBwcml2YXRlS2V5O1xuICAgICAgICB0aGlzLnNlY3JldFNjYWxhciA9IGRlcml2ZVNlY3JldFNjYWxhcihwcml2YXRlS2V5KTtcbiAgICAgICAgdGhpcy5wdWJsaWNLZXkgPSBkZXJpdmVQdWJsaWNLZXkocHJpdmF0ZUtleSk7XG4gICAgICAgIHRoaXMucGFja2VkUHVibGljS2V5ID0gcGFja1B1YmxpY0tleSh0aGlzLnB1YmxpY0tleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ25zIGEgZ2l2ZW4gbWVzc2FnZSB1c2luZyB0aGUgcHJpdmF0ZSBrZXkgYW5kIHJldHVybnMgdGhlIHNpZ25hdHVyZS5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBiZSBzaWduZWQuXG4gICAgICogQHJldHVybnMgVGhlIHNpZ25hdHVyZSBvZiB0aGUgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBzaWduTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBzaWduTWVzc2FnZSh0aGlzLnByaXZhdGVLZXksIG1lc3NhZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIHNpZ25hdHVyZSBhZ2FpbnN0IGEgbWVzc2FnZSBhbmQgdGhlIHB1YmxpYyBrZXkgc3RvcmVkIGluIHRoaXMgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2Ugd2hvc2Ugc2lnbmF0dXJlIGlzIHRvIGJlIHZlcmlmaWVkLlxuICAgICAqIEBwYXJhbSBzaWduYXR1cmUgVGhlIHNpZ25hdHVyZSB0byBiZSB2ZXJpZmllZC5cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBzaWduYXR1cmUgaXMgdmFsaWQgZm9yIHRoZSBtZXNzYWdlIGFuZCBwdWJsaWMga2V5LCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgdmVyaWZ5U2lnbmF0dXJlKG1lc3NhZ2UsIHNpZ25hdHVyZSkge1xuICAgICAgICByZXR1cm4gdmVyaWZ5U2lnbmF0dXJlKG1lc3NhZ2UsIHNpZ25hdHVyZSwgdGhpcy5wdWJsaWNLZXkpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgRWREU0FQb3NlaWRvbiwgZGVyaXZlUHVibGljS2V5LCBkZXJpdmVTZWNyZXRTY2FsYXIsIHBhY2tQdWJsaWNLZXksIHBhY2tTaWduYXR1cmUsIHNpZ25NZXNzYWdlLCB1bnBhY2tQdWJsaWNLZXksIHVucGFja1NpZ25hdHVyZSwgdmVyaWZ5U2lnbmF0dXJlIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@zk-kit/eddsa-poseidon/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@zk-kit/eddsa-poseidon/node_modules/@zk-kit/utils/dist/index.node.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@zk-kit/eddsa-poseidon/node_modules/@zk-kit/utils/dist/index.node.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Buffer: () => (/* reexport safe */ buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer),\n/* harmony export */   F1Field: () => (/* binding */ F1Field),\n/* harmony export */   base64ToBuffer: () => (/* binding */ base64ToBuffer),\n/* harmony export */   base64ToText: () => (/* binding */ base64ToText),\n/* harmony export */   beBigIntToBuffer: () => (/* binding */ beBigIntToBuffer),\n/* harmony export */   beBufferToBigInt: () => (/* binding */ beBufferToBigInt),\n/* harmony export */   bigIntToBuffer: () => (/* binding */ bigIntToBuffer),\n/* harmony export */   bigIntToHexadecimal: () => (/* binding */ bigIntToHexadecimal),\n/* harmony export */   bigNumberishToBigInt: () => (/* binding */ bigNumberishToBigInt),\n/* harmony export */   bigNumberishToBuffer: () => (/* binding */ bigNumberishToBuffer),\n/* harmony export */   bufferToBase64: () => (/* binding */ bufferToBase64),\n/* harmony export */   bufferToBigInt: () => (/* binding */ bufferToBigInt),\n/* harmony export */   bufferToHexadecimal: () => (/* binding */ bufferToHexadecimal),\n/* harmony export */   conversions: () => (/* binding */ conversions),\n/* harmony export */   crypto: () => (/* binding */ crypto_node),\n/* harmony export */   errorHandlers: () => (/* binding */ errorHandlers),\n/* harmony export */   hexadecimalToBigInt: () => (/* binding */ hexadecimalToBigInt),\n/* harmony export */   hexadecimalToBuffer: () => (/* binding */ hexadecimalToBuffer),\n/* harmony export */   isArray: () => (/* binding */ isArray),\n/* harmony export */   isBigInt: () => (/* binding */ isBigInt),\n/* harmony export */   isBigNumber: () => (/* binding */ isBigNumber),\n/* harmony export */   isBigNumberish: () => (/* binding */ isBigNumberish),\n/* harmony export */   isBuffer: () => (/* binding */ isBuffer),\n/* harmony export */   isDefined: () => (/* binding */ isDefined),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isHexadecimal: () => (/* binding */ isHexadecimal),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   isStringifiedBigInt: () => (/* binding */ isStringifiedBigInt),\n/* harmony export */   isSupportedType: () => (/* binding */ isSupportedType),\n/* harmony export */   isType: () => (/* binding */ isType),\n/* harmony export */   isUint8Array: () => (/* binding */ isUint8Array),\n/* harmony export */   leBigIntToBuffer: () => (/* binding */ leBigIntToBuffer),\n/* harmony export */   leBufferToBigInt: () => (/* binding */ leBufferToBigInt),\n/* harmony export */   packGroth16Proof: () => (/* binding */ packGroth16Proof),\n/* harmony export */   packing: () => (/* binding */ proofPacking),\n/* harmony export */   requireArray: () => (/* binding */ requireArray),\n/* harmony export */   requireBigInt: () => (/* binding */ requireBigInt),\n/* harmony export */   requireBigNumber: () => (/* binding */ requireBigNumber),\n/* harmony export */   requireBigNumberish: () => (/* binding */ requireBigNumberish),\n/* harmony export */   requireBuffer: () => (/* binding */ requireBuffer),\n/* harmony export */   requireDefined: () => (/* binding */ requireDefined),\n/* harmony export */   requireFunction: () => (/* binding */ requireFunction),\n/* harmony export */   requireHexadecimal: () => (/* binding */ requireHexadecimal),\n/* harmony export */   requireNumber: () => (/* binding */ requireNumber),\n/* harmony export */   requireObject: () => (/* binding */ requireObject),\n/* harmony export */   requireString: () => (/* binding */ requireString),\n/* harmony export */   requireStringifiedBigInt: () => (/* binding */ requireStringifiedBigInt),\n/* harmony export */   requireTypes: () => (/* binding */ requireTypes),\n/* harmony export */   requireUint8Array: () => (/* binding */ requireUint8Array),\n/* harmony export */   scalar: () => (/* binding */ scalar),\n/* harmony export */   supportedTypes: () => (/* binding */ supportedTypes),\n/* harmony export */   textToBase64: () => (/* binding */ textToBase64),\n/* harmony export */   typeChecks: () => (/* binding */ typeChecks),\n/* harmony export */   unpackGroth16Proof: () => (/* binding */ unpackGroth16Proof)\n/* harmony export */ });\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! crypto */ \"crypto\");\n/**\n * @module @zk-kit/utils\n * @version 1.2.1\n * @file Essential zero-knowledge utility library for JavaScript developers.\n * @copyright Ethereum Foundation 2024\n * @license MIT\n * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/utils}\n*/\n\n\n\n\n/**\n * @module TypeChecks\n * This module provides utility functions to check data types.\n * It defines a set of supported types and includes functions to check if\n * a value is defined and if it matches a supported type. These functions\n * are useful for type checking and validation in the other libraries,\n * enhancing code robustness and reliability.\n */\n/** @internal */\nconst supportedTypes = [\n    \"number\",\n    \"string\",\n    \"function\",\n    \"Array\",\n    \"Uint8Array\",\n    \"Buffer\",\n    \"object\",\n    \"bigint\",\n    \"stringified-bigint\",\n    \"hexadecimal\",\n    \"bignumber\",\n    \"bignumberish\"\n];\n/**\n * Returns true if the value is defined, false otherwise.\n * @param value The value to be checked.\n */\nfunction isDefined(value) {\n    return typeof value !== \"undefined\";\n}\n/**\n * Returns true if the value is a number, false otherwise.\n * @param value The value to be checked.\n */\nfunction isNumber(value) {\n    return typeof value === \"number\";\n}\n/**\n * Returns true if the value is a string, false otherwise.\n * @param value The value to be checked.\n */\nfunction isString(value) {\n    return typeof value === \"string\";\n}\n/**\n * Returns true if the value is a function, false otherwise.\n * @param value The value to be checked.\n */\nfunction isFunction(value) {\n    return typeof value === \"function\";\n}\n/**\n * Returns true if the value is an object, false otherwise.\n * Please, note that arrays are also objects in JavaScript.\n * @param value The value to be checked.\n */\nfunction isObject(value) {\n    return typeof value === \"object\";\n}\n/**\n * Returns true if the value is an Array instance, false otherwise.\n * @param value The value to be checked.\n */\nfunction isArray(value) {\n    return isObject(value) && Array.isArray(value);\n}\n/**\n * Returns true if the value is a Uint8Array instance, false otherwise.\n * @param value The value to be checked.\n */\nfunction isUint8Array(value) {\n    return value instanceof Uint8Array;\n}\n/**\n * Returns true if the value is a Buffer instance, false otherwise.\n * @param value The value to be checked.\n */\nfunction isBuffer(value) {\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.isBuffer(value);\n}\n/**\n * Returns true if the value is a bigint, false otherwise.\n * @param value The value to be checked.\n */\nfunction isBigInt(value) {\n    return typeof value === \"bigint\";\n}\n/**\n * Checks if the given value is a string that represents a valid bigint.\n * @param value The value to be checked if it's a stringified bigint.\n */\nfunction isStringifiedBigInt(value) {\n    // Check if value is a string first.\n    if (!isString(value)) {\n        return false;\n    }\n    try {\n        // Attempt to convert the string to BigInt.\n        BigInt(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Checks if a string is a valid hexadecimal string representation.\n * If 'prefix' is 'true', the string must start with '0x' or '0X' followed by one or more\n * hexadecimal digits (0-9, a-f, A-F), otherwise no prefix is expected. 'prefix' is optional and\n * if its value it is not explicitly defined it will be set to 'true' by default.\n * @param value The string to be tested.\n * @param prefix A boolean to include or not a '0x' or '0X' prefix.\n */\nfunction isHexadecimal(value, prefix = true) {\n    if (!isString(value)) {\n        return false;\n    }\n    if (prefix) {\n        return /^(0x|0X)[0-9a-fA-F]+$/.test(value);\n    }\n    return /^[0-9a-fA-F]+$/.test(value);\n}\n/**\n * Checks if the given value can be considered as BigNumber.\n * A value is considered a BigNumber if it is a bigint or a string\n * that can be converted to a bigint (via `Bigint(s)`).\n * @param value The value to check.\n */\nfunction isBigNumber(value) {\n    return isBigInt(value) || isStringifiedBigInt(value);\n}\n/**\n * Checks if the given value can be considered as BigNumberish.\n * A value is considered BigNumberish if it meets\n * any of the following conditions: it's a number, a bigint, a string\n * that can be converted to a bigint, a hexadecimal\n * string, or a Buffer object.\n * @param value The value to check.\n */\nfunction isBigNumberish(value) {\n    return (isNumber(value) ||\n        isBigInt(value) ||\n        isStringifiedBigInt(value) ||\n        isHexadecimal(value) ||\n        isBuffer(value) ||\n        isUint8Array(value));\n}\n/**\n * Returns true if the value type is the same as the type passed\n * as the second parameter, false otherwise.\n * @param value\n * @param type The expected type.\n */\nfunction isType(value, type) {\n    switch (type) {\n        case \"number\":\n            return isNumber(value);\n        case \"string\":\n            return isString(value);\n        case \"function\":\n            return isFunction(value);\n        case \"Array\":\n            return isArray(value);\n        case \"Uint8Array\":\n            return isUint8Array(value);\n        case \"Buffer\":\n            return isBuffer(value);\n        case \"object\":\n            return isObject(value);\n        case \"bigint\":\n            return isBigInt(value);\n        case \"stringified-bigint\":\n            return isStringifiedBigInt(value);\n        case \"hexadecimal\":\n            return isHexadecimal(value);\n        case \"bignumber\":\n            return isBigNumber(value);\n        case \"bignumberish\":\n            return isBigNumberish(value);\n        default:\n            return false;\n    }\n}\n/**\n * Returns true if the type is being supported by this utility\n * functions, false otherwise.\n * @param type The type to be checked.\n */\nfunction isSupportedType(type) {\n    return supportedTypes.includes(type);\n}\n\nvar typeChecks = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    isArray: isArray,\n    isBigInt: isBigInt,\n    isBigNumber: isBigNumber,\n    isBigNumberish: isBigNumberish,\n    isBuffer: isBuffer,\n    isDefined: isDefined,\n    isFunction: isFunction,\n    isHexadecimal: isHexadecimal,\n    isNumber: isNumber,\n    isObject: isObject,\n    isString: isString,\n    isStringifiedBigInt: isStringifiedBigInt,\n    isSupportedType: isSupportedType,\n    isType: isType,\n    isUint8Array: isUint8Array,\n    supportedTypes: supportedTypes\n});\n\n/**\n * @module ErrorHandlers\n * This module is designed to provide utility functions for validating\n * function parameters. It includes functions that throw type errors if\n * the parameters do not meet specified criteria, such as being defined,\n * a number, a string, a function, or an array. This module helps ensure\n * that functions receive the correct types of inputs, enhancing code\n * reliability and reducing runtime errors.\n */\n/**\n * @throws Throws a type error if the parameter value has not been defined.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireDefined(parameterValue, parameterName) {\n    if (!isDefined(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not defined`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a number.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireNumber(parameterValue, parameterName) {\n    if (!isNumber(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a number, received type: ${typeof parameterValue}`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a string.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireString(parameterValue, parameterName) {\n    if (!isString(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a string, received type: ${typeof parameterValue}`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a function.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireFunction(parameterValue, parameterName) {\n    if (!isFunction(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a function, received type: ${typeof parameterValue}`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not an Array.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireArray(parameterValue, parameterName) {\n    if (!isArray(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not an Array instance`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a Uint8Array.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireUint8Array(parameterValue, parameterName) {\n    if (!isUint8Array(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a Uint8Array instance`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a Buffer.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireBuffer(parameterValue, parameterName) {\n    if (!isBuffer(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a Buffer instance`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not an object.\n * Please, note that arrays are also objects in JavaScript.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireObject(parameterValue, parameterName) {\n    if (!isObject(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not an object, received type: ${typeof parameterValue}`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a bigint.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireBigInt(parameterValue, parameterName) {\n    if (!isBigInt(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a bigint, received type: ${typeof parameterValue}`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a stringified bigint.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireStringifiedBigInt(parameterValue, parameterName) {\n    if (!isStringifiedBigInt(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a stringified bigint`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a hexadecimal string.\n * If 'prefix' is 'true', the string must start with '0x' or '0X' followed by one or more\n * hexadecimal digits (0-9, a-f, A-F), otherwise no prefix is expected. 'prefix' is optional and\n * if its value it is not explicitly defined it will be set to 'true' by default.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n * @param prefix A boolean to include or not a '0x' or '0X' prefix.\n */\nfunction requireHexadecimal(parameterValue, parameterName, prefix = true) {\n    if (!isHexadecimal(parameterValue, prefix)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a hexadecimal string`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a bignumber.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireBigNumber(parameterValue, parameterName) {\n    if (!isBigNumber(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a bignumber`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a bignumber-ish.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireBigNumberish(parameterValue, parameterName) {\n    if (!isBigNumberish(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a bignumber-ish`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value type is not part of the list of types.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireTypes(parameterValue, parameterName, types) {\n    for (const type of types) {\n        if (!isSupportedType(type)) {\n            throw new Error(`Type '${type}' is not supported`);\n        }\n    }\n    for (const type of types) {\n        if (isType(parameterValue, type)) {\n            return;\n        }\n    }\n    throw new TypeError(`Parameter '${parameterName}' is none of the following types: ${types.join(\", \")}`);\n}\n\nvar errorHandlers = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    requireArray: requireArray,\n    requireBigInt: requireBigInt,\n    requireBigNumber: requireBigNumber,\n    requireBigNumberish: requireBigNumberish,\n    requireBuffer: requireBuffer,\n    requireDefined: requireDefined,\n    requireFunction: requireFunction,\n    requireHexadecimal: requireHexadecimal,\n    requireNumber: requireNumber,\n    requireObject: requireObject,\n    requireString: requireString,\n    requireStringifiedBigInt: requireStringifiedBigInt,\n    requireTypes: requireTypes,\n    requireUint8Array: requireUint8Array\n});\n\n/**\n * @module Conversions\n * This module provides a collection of utility functions for converting\n * between different numerical formats, particularly focusing on\n * conversions involving bigints, hexadecimals and buffers.\n * The module is structured with clear function naming to indicate\n * the conversion direction (e.g., `bigIntToHexadecimal` for BigInt\n * to hexadecimal, `bufferToBigInt` for buffer to bigint) and employs\n * type checks to ensure the correct handling of various input types.\n * It also includes variations for both big-endian (`be`) and little-endian\n * (`le`) conversions. It is important to note that when there is no prefix,\n * the order of bytes is always big-endian.\n */\n/**\n * Converts a bigint to a hexadecimal string.\n * @param value The bigint value to convert.\n * @returns The hexadecimal representation of the bigint.\n */\nfunction bigIntToHexadecimal(value) {\n    requireBigInt(value, \"value\");\n    let hex = value.toString(16);\n    // Ensure even length.\n    if (hex.length % 2 !== 0) {\n        hex = `0${hex}`;\n    }\n    return hex;\n}\n/**\n * Converts a hexadecimal string to a bigint. The input is interpreted as hexadecimal\n * with or without a '0x' prefix. It uses big-endian byte order.\n * @param value The hexadecimal string to convert.\n * @returns The bigint representation of the hexadecimal string.\n */\nfunction hexadecimalToBigInt(value) {\n    if (!isHexadecimal(value) && !isHexadecimal(value, false)) {\n        throw new TypeError(`Parameter 'value' is not a hexadecimal string`);\n    }\n    // Ensure the hex string starts with '0x'.\n    const formattedHexString = value.startsWith(\"0x\") ? value : `0x${value}`;\n    return BigInt(formattedHexString);\n}\n/**\n * Converts a buffer of bytes to a bigint using big-endian byte order.\n * It accepts 'Buffer' or 'Uint8Array'.\n * @param value The buffer to convert.\n * @returns The bigint representation of the buffer's contents.\n */\nfunction beBufferToBigInt(value) {\n    requireTypes(value, \"value\", [\"Buffer\", \"Uint8Array\"]);\n    return BigInt(`0x${buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value).toString(\"hex\")}`);\n}\n/**\n * Converts a buffer to a bigint using little-endian byte order.\n * It accepts 'Buffer' or 'Uint8Array'.\n * @param value The buffer to convert.\n * @returns The bigint representation of the buffer's contents in little-endian.\n */\nfunction leBufferToBigInt(value) {\n    requireTypes(value, \"value\", [\"Buffer\", \"Uint8Array\"]);\n    return BigInt(`0x${buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value).reverse().toString(\"hex\")}`);\n}\n/**\n * Converts a buffer to a bigint. Alias for beBufferToBigInt.\n * @param value The buffer to convert.\n * @returns The bigint representation of the buffer's contents.\n */\nfunction bufferToBigInt(value) {\n    return beBufferToBigInt(value);\n}\n/**\n * Converts a bigint to a buffer and fills with zeros if a valid\n * size (i.e. number of bytes) is specified. If the size is not defined,\n * it gets the size from the given bigint. If the specified size is smaller than\n * the size of the bigint (i.e. `minSize`), an error is thrown.\n * It uses big-endian byte order.\n * @param value The bigint to convert.\n * @param size The number of bytes of the buffer to return.\n * @returns The buffer representation of the bigint.\n */\nfunction beBigIntToBuffer(value, size) {\n    const hex = bigIntToHexadecimal(value);\n    // Calculate the minimum buffer size required to represent 'n' in bytes.\n    // Each hexadecimal character represents 4 bits, so 2 characters are 1 byte.\n    const minSize = Math.ceil(hex.length / 2);\n    if (!size) {\n        size = minSize;\n    }\n    else if (size < minSize) {\n        throw Error(`Size ${size} is too small, need at least ${minSize} bytes`);\n    }\n    // Allocate buffer of the desired size, filled with zeros.\n    const buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(size, 0);\n    const fromHex = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(hex, \"hex\");\n    fromHex.copy(buffer, size - fromHex.length);\n    return buffer;\n}\n/**\n * Converts a bigint to a buffer and fills with zeros if a valid\n * size (i.e. number of bytes) is specified. If the size is not defined,\n * it gets the size from the given bigint. If the specified size is smaller than\n * the size of the bigint (i.e. `minSize`), an error is thrown.\n * It uses little-endian byte order.\n * @param value The bigint to convert.\n * @param size The number of bytes of the buffer to return.\n * @returns The buffer representation of the bigint in little-endian.\n */\nfunction leBigIntToBuffer(value, size) {\n    const hex = bigIntToHexadecimal(value);\n    // Calculate the minimum buffer size required to represent 'n' in bytes.\n    // Each hexadecimal character represents 4 bits, so 2 characters are 1 byte.\n    const minSize = Math.ceil(hex.length / 2);\n    if (!size) {\n        size = minSize;\n    }\n    else if (size < minSize) {\n        throw Error(`Size ${size} is too small, need at least ${minSize} bytes`);\n    }\n    // Allocate buffer of the desired size, filled with zeros.\n    const buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(size, 0);\n    const fromHex = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(hex, \"hex\").reverse();\n    fromHex.copy(buffer, 0);\n    return buffer;\n}\n/**\n * Converts a bigint to a buffer. Alias for beBigIntToBuffer.\n * @param value The bigint to convert.\n * @returns The buffer representation of the bigint.\n */\nfunction bigIntToBuffer(value) {\n    return beBigIntToBuffer(value);\n}\n/**\n * Converts a BigNumberish type to a bigint. If the input is already a bigint,\n * the return value will be the bigint itself, otherwise it will be converted\n * to a bigint using big-endian byte order.\n * @param value The BigNumberish value to convert.\n * @returns The bigint representation of the BigNumberish value.\n */\nfunction bigNumberishToBigInt(value) {\n    requireBigNumberish(value, \"value\");\n    if (isBuffer(value) || isUint8Array(value)) {\n        return bufferToBigInt(value);\n    }\n    return BigInt(value);\n}\n/**\n * Converts a BigNumberish type to a buffer. If the input is already a buffer,\n * the return value will be the buffer itself, otherwise it will be converted\n * to a buffer using big-endian byte order.\n * @param value The BigNumberish value to convert.\n * @returns The buffer representation of the BigNumberish value.\n */\nfunction bigNumberishToBuffer(value) {\n    requireBigNumberish(value, \"value\");\n    if (isBuffer(value) || isUint8Array(value)) {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value);\n    }\n    return bigIntToBuffer(bigNumberishToBigInt(value));\n}\n/**\n * Converts an hexadecimal string to a buffer. The hexadecimal string\n * should not start with '0x' or '0X'. It keeps the bytes in the same order.\n * @param value The hexadecimal string to convert.\n * @returns The buffer representation of the hexadecimal string.\n */\nfunction hexadecimalToBuffer(value) {\n    requireHexadecimal(value, \"value\", false);\n    // Ensure even length before converting to buffer.\n    if (value.length % 2 !== 0) {\n        value = `0${value}`;\n    }\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value, \"hex\");\n}\n/**\n * Converts a buffer to a hexadecimal string. It accepts 'Buffer' or 'Uint8Array'.\n * The hexadecimal string will not start with '0x' or '0X'. It keeps the bytes in the same order.\n * @param value The buffer to convert.\n * @returns The converted hexadecimal string.\n */\nfunction bufferToHexadecimal(value) {\n    requireTypes(value, \"value\", [\"Buffer\", \"Uint8Array\"]);\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value).toString(\"hex\");\n}\n/**\n * Converts bytes to a base64 string. It accepts 'Buffer' or 'Uint8Array'.\n * @param value The bytes to convert.\n * @returns The converted base64 string.\n */\nfunction bufferToBase64(value) {\n    requireTypes(value, \"value\", [\"Buffer\", \"Uint8Array\"]);\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value).toString(\"base64\");\n}\n/**\n * Converts a base64 string to bytes (i.e. a buffer). This function does not check\n * if the input value is a valid base64 string. If there are unsupported characters\n * they will be ignored.\n * @param value The base64 string to convert.\n * @returns The converted buffer.\n */\nfunction base64ToBuffer(value) {\n    requireString(value, \"value\");\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value, \"base64\");\n}\n/**\n * Converts text (utf8) to a base64 string.\n * @param value The text to convert.\n * @returns The converted base64 string.\n */\nfunction textToBase64(value) {\n    requireString(value, \"value\");\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value, \"utf8\").toString(\"base64\");\n}\n/**\n * Converts a base64 string to text (utf8). This function does not check\n * if the input value is a valid base64 string. If there are unsupported characters\n * they could be ignored and the result may be unexpected.\n * @param value The base64 string to convert.\n * @returns The converted text.\n */\nfunction base64ToText(value) {\n    requireString(value, \"value\");\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value, \"base64\").toString(\"utf8\");\n}\n\nvar conversions = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    base64ToBuffer: base64ToBuffer,\n    base64ToText: base64ToText,\n    beBigIntToBuffer: beBigIntToBuffer,\n    beBufferToBigInt: beBufferToBigInt,\n    bigIntToBuffer: bigIntToBuffer,\n    bigIntToHexadecimal: bigIntToHexadecimal,\n    bigNumberishToBigInt: bigNumberishToBigInt,\n    bigNumberishToBuffer: bigNumberishToBuffer,\n    bufferToBase64: bufferToBase64,\n    bufferToBigInt: bufferToBigInt,\n    bufferToHexadecimal: bufferToHexadecimal,\n    hexadecimalToBigInt: hexadecimalToBigInt,\n    hexadecimalToBuffer: hexadecimalToBuffer,\n    leBigIntToBuffer: leBigIntToBuffer,\n    leBufferToBigInt: leBufferToBigInt,\n    textToBase64: textToBase64\n});\n\n/**\n * Generates a random sequence of bytes securely using Node.js's crypto module.\n * @param size The number of bytes to generate.\n * @returns A Uint8Array containing the generated random bytes.\n */\n/* eslint-disable import/prefer-default-export */\nfunction getRandomValues(size) {\n    if (size <= 0)\n        throw Error(`size ${size} is too small, need at least 1`);\n    const buffer = (0,crypto__WEBPACK_IMPORTED_MODULE_1__.randomBytes)(size);\n    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n}\n\nvar crypto_node = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    getRandomValues: getRandomValues\n});\n\n/**\n * @module Scalar\n * This module provides utility functions for performing scalar operations\n * within a field, especially designed to handle operations on bigints.\n * The operations include scalar inversion (`inv`), scalar exponentiation (`pow`),\n * and modular reduction. Functions are carefully implemented to ensure\n * mathematical correctness and efficiency, supporting both positive and\n * negative bigint values. The module aims to provide robust tools for\n * cryptographic calculations and other applications requiring high-precision\n * arithmetic in fields.\n */\n/**\n * Checks if a bigint scalar value is zero.\n * @param a The bigint scalar value to check.\n * @returns True if 'a' is zero, false otherwise.\n */\nfunction isZero(a) {\n    return !a;\n}\n/**\n * Determines whether a bigint scalar value is odd.\n * @param a The bigint scalar value to check.\n * @returns True if 'a' is odd, false if it is even.\n */\nfunction isOdd(a) {\n    return (a & BigInt(1)) === BigInt(1);\n}\n/**\n * Performs a bitwise right shift on a bigint scalar value.\n * This operation is equivalent to dividing by 2^n, but it operates directly\n * on the binary representation, making it efficient for certain types of calculations.\n * @param a The bigint scalar value to shift.\n * @param n The number of bits to shift 'a' by.\n * @returns The result of shifting 'a' right by 'n' bits.\n */\nfunction shiftRight(a, n) {\n    return a >> n;\n}\n/**\n * Multiplies two bigint scalar values.\n * @param a The first bigint scalar value.\n * @param b The second bigint scalar value.\n * @returns The product of 'a' and 'b'.\n */\nfunction mul(a, b) {\n    return a * b;\n}\n/**\n * Compares two bigint scalar values to determine if the first is greater than the second.\n * @param a The first bigint scalar value to compare.\n * @param b The second bigint scalar value to compare.\n * @returns True if 'a' is greater than 'b', false otherwise.\n */\nfunction gt(a, b) {\n    return a > b;\n}\n/**\n * Converts a bigint scalar value into an array of bits, represented as numbers.\n * This function is particularly useful for examining the binary structure of bigints,\n * which can be necessary for bit manipulation and understanding the representation\n * of numbers at a lower level.\n * @param n The bigint scalar value to convert into bits.\n * @returns An array of numbers representing the bits of 'n', starting from the least significant bit.\n */\nfunction bits(n) {\n    const res = [];\n    let E = n;\n    while (E) {\n        if (E & BigInt(1)) {\n            res.push(1);\n        }\n        else {\n            res.push(0);\n        }\n        E >>= BigInt(1);\n    }\n    return res;\n}\n\nvar scalar = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    bits: bits,\n    gt: gt,\n    isOdd: isOdd,\n    isZero: isZero,\n    mul: mul,\n    shiftRight: shiftRight\n});\n\n/**\n * @class F1Field\n * Represents a finite field of order 'order' providing arithmetic operations under modulus.\n * This class includes operations such as addition, subtraction, multiplication, division,\n * and inversion, all performed modulo the field's order. It's designed to work with bigints,\n * supporting large numbers for cryptographic purposes and other applications requiring\n * modular arithmetic.\n * Note that the outputs of the functions will always be within the field if and only if\n * the input values are within the field. Devs need to make sure of that.\n *\n * @property one Represents the scalar value 1 in the field.\n * @property zero Represents the scalar value 0 in the field.\n * @property _order The order of the finite field (i.e., the modulus).\n * @property _half Half the order of the field, used for certain comparisons.\n * @property _negone The scalar value -1 in the field, represented positively.\n */\nclass F1Field {\n    constructor(order) {\n        this.one = 1n;\n        this.zero = 0n;\n        this._order = order;\n        this._half = order >> this.one;\n        this._negone = this._order - this.one;\n    }\n    /**\n     * Ensures a given result falls within the field by applying modular reduction.\n     * This method also handles negative inputs, correctly mapping them into the field.\n     * @param res The result to be normalized to the field.\n     * @returns The equivalent value within the field.\n     */\n    e(res) {\n        res %= this._order;\n        return res < 0 ? res + this._order : res;\n    }\n    /**\n     * Performs modular multiplication of two bigint values within the field.\n     * @param a The first value.\n     * @param b The second value.\n     * @returns The product of 'a' and 'b' modulo the field's order.\n     */\n    mul(a, b) {\n        return (a * b) % this._order;\n    }\n    /**\n     * Subtracts one bigint from another under modulus.\n     * It ensures the result is within the field if and only if the input values are within the field.\n     * @param a The value from which to subtract.\n     * @param b The value to be subtracted.\n     * @returns The difference of 'a' and 'b' modulo the field's order.\n     */\n    sub(a, b) {\n        return a >= b ? a - b : this._order - b + a;\n    }\n    /**\n     * Adds two bigint values together under modulus.\n     * It ensures the result is within the field if and only if the input values are within the field.\n     * @param a The first value.\n     * @param b The second value.\n     * @returns The sum of 'a' and 'b' modulo the field's order.\n     */\n    add(a, b) {\n        const res = a + b;\n        return res >= this._order ? res - this._order : res;\n    }\n    /**\n     * Computes the multiplicative inverse of a given value within the field.\n     * This method uses the Extended Euclidean Algorithm to find the inverse,\n     * ensuring the result is always a positive value less than the field's order.\n     * If the input value is zero, which has no inverse, an error is thrown.\n     * @param a The value for which to compute the inverse.\n     * @returns The multiplicative inverse of 'a' modulo the field's order.\n     * @throws if 'a' is zero.\n     */\n    inv(a) {\n        if (a === this.zero) {\n            throw new Error(\"Zero has no inverse\");\n        }\n        let t = this.zero;\n        let r = this._order;\n        let newt = this.one;\n        let newr = a % this._order;\n        while (newr) {\n            const q = r / newr;\n            [t, newt] = [newt, t - q * newt];\n            [r, newr] = [newr, r - q * newr];\n        }\n        if (t < this.zero) {\n            t += this._order;\n        }\n        return t;\n    }\n    /**\n     * Divides one bigint by another within the field by multiplying the first value\n     * by the multiplicative inverse of the second.\n     * @param a The dividend.\n     * @param b The divisor.\n     * @returns The result of the division of 'a' by 'b' modulo the field's order.\n     */\n    div(a, b) {\n        return this.mul(a, this.inv(b));\n    }\n    /**\n     * Checks if two bigint values are equal within the context of the field.\n     * It ensures the result is within the field if and only if the input values are within the field.\n     * @param a The first value to compare.\n     * @param b The second value to compare.\n     * @returns True if 'a' equals 'b', false otherwise.\n     */\n    eq(a, b) {\n        return a === b;\n    }\n    /**\n     * Squares a bigint value within the field.\n     * This is a specific case of multiplication where the value is multiplied by itself,\n     * optimized for performance where applicable.\n     * It ensures the result is within the field if and only if the input values are within the field.\n     * @param a The value to square.\n     * @returns The square of 'a' modulo the field's order.\n     */\n    square(a) {\n        return (a * a) % this._order;\n    }\n    /**\n     * Compares two bigint values to determine if the first is less than the second,\n     * taking into account the field's order for modular comparison.\n     * It ensures the result is within the field if and only if the input values are within the field.\n     * @param a The first value to compare.\n     * @param b The second value to compare.\n     * @returns True if 'a' is less than 'b', false otherwise.\n     */\n    lt(a, b) {\n        const aa = a > this._half ? a - this._order : a;\n        const bb = b > this._half ? b - this._order : b;\n        return aa < bb;\n    }\n    /**\n     * Compares two bigint values to determine if the first is greater than or equal to the second,\n     * considering the field's modular context.\n     * It ensures the result is within the field if and only if the input values are within the field.\n     * @param a The first value to compare.\n     * @param b The second value to compare.\n     * @returns True if 'a' is greater than or equal to 'b', false otherwise.\n     */\n    geq(a, b) {\n        const aa = a > this._half ? a - this._order : a;\n        const bb = b > this._half ? b - this._order : b;\n        return aa >= bb;\n    }\n    /**\n     * Computes the negation of a bigint value within the field.\n     * The result is the modular additive inverse that, when added to the original value,\n     * yields zero in the field's modulus.\n     * It ensures the result is within the field if and only if the input values are within the field.\n     * @param a The value to negate.\n     * @returns The negation of 'a' modulo the field's order.\n     */\n    neg(a) {\n        return a ? this._order - a : a;\n    }\n    /**\n     * Checks if a bigint value is zero within the context of the field.\n     * @param a The value to check.\n     * @returns True if 'a' is zero, false otherwise.\n     */\n    isZero(a) {\n        return a === this.zero;\n    }\n    /**\n     * Raises a base to an exponent within the field, efficiently computing\n     * scalar exponentiation using the square-and-multiply algorithm.\n     * Supports both positive and negative exponents through the use of the `inv` method for negatives.\n     * @param base The base to be exponentiated.\n     * @param e The exponent.\n     * @returns The result of raising 'base' to the power 'e' modulo the field's order.\n     */\n    pow(base, e) {\n        if (isZero(e)) {\n            return this.one;\n        }\n        if (e < 0n) {\n            base = this.inv(base);\n            e = -e;\n        }\n        const n = bits(e);\n        if (n.length === 0) {\n            return this.one;\n        }\n        let res = base;\n        for (let i = n.length - 2; i >= 0; i -= 1) {\n            res = this.square(res);\n            if (n[i]) {\n                res = this.mul(res, base);\n            }\n        }\n        return res;\n    }\n}\n\n/**\n * @module ProofPacking\n *\n * This module provides utility functions to pack and unpack\n * various types of objects, making it easier to export or use\n * them externally.\n */\n/**\n * Packs a Snarkjs Groth16 proof into a single list usable as calldata in Solidity (public signals are not included).\n * @param proof The Groth16 proof generated with SnarkJS.\n * @returns Solidity calldata.\n */\nfunction packGroth16Proof(proof) {\n    return [\n        proof.pi_a[0],\n        proof.pi_a[1],\n        proof.pi_b[0][1],\n        proof.pi_b[0][0],\n        proof.pi_b[1][1],\n        proof.pi_b[1][0],\n        proof.pi_c[0],\n        proof.pi_c[1]\n    ];\n}\n/**\n * Unpacks a PackedGroth16Proof Solidity calldata into its original form which is a SnarkJS Groth16 proof.\n * @param proof Solidity calldata.\n * @returns The Groth16 proof compatible with SnarkJS.\n */\nfunction unpackGroth16Proof(proof) {\n    return {\n        pi_a: [proof[0], proof[1]],\n        pi_b: [\n            [proof[3], proof[2]],\n            [proof[5], proof[4]]\n        ],\n        pi_c: [proof[6], proof[7]],\n        protocol: \"groth16\",\n        curve: \"bn128\"\n    };\n}\n\nvar proofPacking = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    packGroth16Proof: packGroth16Proof,\n    unpackGroth16Proof: unpackGroth16Proof\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHprLWtpdC9lZGRzYS1wb3NlaWRvbi9ub2RlX21vZHVsZXMvQHprLWtpdC91dGlscy9kaXN0L2luZGV4Lm5vZGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNnQztBQUNBO0FBQ0s7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMENBQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxjQUFjLG9DQUFvQyxzQkFBc0I7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGNBQWMsb0NBQW9DLHNCQUFzQjtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsY0FBYyxzQ0FBc0Msc0JBQXNCO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGNBQWMscUNBQXFDLHNCQUFzQjtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsY0FBYyxvQ0FBb0Msc0JBQXNCO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsS0FBSztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxjQUFjLG9DQUFvQyxpQkFBaUI7QUFDekc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsSUFBSTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLE1BQU07QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMENBQU0sNkJBQTZCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQ0FBTSx1Q0FBdUM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTSw4QkFBOEIsU0FBUztBQUN6RTtBQUNBO0FBQ0EsbUJBQW1CLDBDQUFNO0FBQ3pCLG9CQUFvQiwwQ0FBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixNQUFNLDhCQUE4QixTQUFTO0FBQ3pFO0FBQ0E7QUFDQSxtQkFBbUIsMENBQU07QUFDekIsb0JBQW9CLDBDQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBDQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQSxXQUFXLDBDQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMENBQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMENBQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBDQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBDQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQ0FBTTtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQyxtQkFBbUIsbURBQVc7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFczNCIiwic291cmNlcyI6WyIvVXNlcnMvY2hhbmNlbWNhbGxpc3Rlci9Qcm9qZWN0cy96dXBhc3NodW50L25vZGVfbW9kdWxlcy9Aemsta2l0L2VkZHNhLXBvc2VpZG9uL25vZGVfbW9kdWxlcy9Aemsta2l0L3V0aWxzL2Rpc3QvaW5kZXgubm9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgQHprLWtpdC91dGlsc1xuICogQHZlcnNpb24gMS4yLjFcbiAqIEBmaWxlIEVzc2VudGlhbCB6ZXJvLWtub3dsZWRnZSB1dGlsaXR5IGxpYnJhcnkgZm9yIEphdmFTY3JpcHQgZGV2ZWxvcGVycy5cbiAqIEBjb3B5cmlnaHQgRXRoZXJldW0gRm91bmRhdGlvbiAyMDI0XG4gKiBAbGljZW5zZSBNSVRcbiAqIEBzZWUgW0dpdGh1Yl17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3ByaXZhY3ktc2NhbGluZy1leHBsb3JhdGlvbnMvemsta2l0L3RyZWUvbWFpbi9wYWNrYWdlcy91dGlsc31cbiovXG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXInO1xuZXhwb3J0IHsgQnVmZmVyIH0gZnJvbSAnYnVmZmVyJztcbmltcG9ydCB7IHJhbmRvbUJ5dGVzIH0gZnJvbSAnY3J5cHRvJztcblxuLyoqXG4gKiBAbW9kdWxlIFR5cGVDaGVja3NcbiAqIFRoaXMgbW9kdWxlIHByb3ZpZGVzIHV0aWxpdHkgZnVuY3Rpb25zIHRvIGNoZWNrIGRhdGEgdHlwZXMuXG4gKiBJdCBkZWZpbmVzIGEgc2V0IG9mIHN1cHBvcnRlZCB0eXBlcyBhbmQgaW5jbHVkZXMgZnVuY3Rpb25zIHRvIGNoZWNrIGlmXG4gKiBhIHZhbHVlIGlzIGRlZmluZWQgYW5kIGlmIGl0IG1hdGNoZXMgYSBzdXBwb3J0ZWQgdHlwZS4gVGhlc2UgZnVuY3Rpb25zXG4gKiBhcmUgdXNlZnVsIGZvciB0eXBlIGNoZWNraW5nIGFuZCB2YWxpZGF0aW9uIGluIHRoZSBvdGhlciBsaWJyYXJpZXMsXG4gKiBlbmhhbmNpbmcgY29kZSByb2J1c3RuZXNzIGFuZCByZWxpYWJpbGl0eS5cbiAqL1xuLyoqIEBpbnRlcm5hbCAqL1xuY29uc3Qgc3VwcG9ydGVkVHlwZXMgPSBbXG4gICAgXCJudW1iZXJcIixcbiAgICBcInN0cmluZ1wiLFxuICAgIFwiZnVuY3Rpb25cIixcbiAgICBcIkFycmF5XCIsXG4gICAgXCJVaW50OEFycmF5XCIsXG4gICAgXCJCdWZmZXJcIixcbiAgICBcIm9iamVjdFwiLFxuICAgIFwiYmlnaW50XCIsXG4gICAgXCJzdHJpbmdpZmllZC1iaWdpbnRcIixcbiAgICBcImhleGFkZWNpbWFsXCIsXG4gICAgXCJiaWdudW1iZXJcIixcbiAgICBcImJpZ251bWJlcmlzaFwiXG5dO1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGlzIGRlZmluZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqL1xuZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIjtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhIG51bWJlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICovXG5mdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCI7XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmcsIGZhbHNlIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGZhbHNlIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QsIGZhbHNlIG90aGVyd2lzZS5cbiAqIFBsZWFzZSwgbm90ZSB0aGF0IGFycmF5cyBhcmUgYWxzbyBvYmplY3RzIGluIEphdmFTY3JpcHQuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhbiBBcnJheSBpbnN0YW5jZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICovXG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhIFVpbnQ4QXJyYXkgaW5zdGFuY2UsIGZhbHNlIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqL1xuZnVuY3Rpb24gaXNVaW50OEFycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhIEJ1ZmZlciBpbnN0YW5jZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICovXG5mdW5jdGlvbiBpc0J1ZmZlcih2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuaXNCdWZmZXIodmFsdWUpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGlzIGEgYmlnaW50LCBmYWxzZSBvdGhlcndpc2UuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKi9cbmZ1bmN0aW9uIGlzQmlnSW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIjtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSB2YWxpZCBiaWdpbnQuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGNoZWNrZWQgaWYgaXQncyBhIHN0cmluZ2lmaWVkIGJpZ2ludC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmdpZmllZEJpZ0ludCh2YWx1ZSkge1xuICAgIC8vIENoZWNrIGlmIHZhbHVlIGlzIGEgc3RyaW5nIGZpcnN0LlxuICAgIGlmICghaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gQXR0ZW1wdCB0byBjb252ZXJ0IHRoZSBzdHJpbmcgdG8gQmlnSW50LlxuICAgICAgICBCaWdJbnQodmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdHJpbmcgaXMgYSB2YWxpZCBoZXhhZGVjaW1hbCBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gKiBJZiAncHJlZml4JyBpcyAndHJ1ZScsIHRoZSBzdHJpbmcgbXVzdCBzdGFydCB3aXRoICcweCcgb3IgJzBYJyBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZVxuICogaGV4YWRlY2ltYWwgZGlnaXRzICgwLTksIGEtZiwgQS1GKSwgb3RoZXJ3aXNlIG5vIHByZWZpeCBpcyBleHBlY3RlZC4gJ3ByZWZpeCcgaXMgb3B0aW9uYWwgYW5kXG4gKiBpZiBpdHMgdmFsdWUgaXQgaXMgbm90IGV4cGxpY2l0bHkgZGVmaW5lZCBpdCB3aWxsIGJlIHNldCB0byAndHJ1ZScgYnkgZGVmYXVsdC5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgc3RyaW5nIHRvIGJlIHRlc3RlZC5cbiAqIEBwYXJhbSBwcmVmaXggQSBib29sZWFuIHRvIGluY2x1ZGUgb3Igbm90IGEgJzB4JyBvciAnMFgnIHByZWZpeC5cbiAqL1xuZnVuY3Rpb24gaXNIZXhhZGVjaW1hbCh2YWx1ZSwgcHJlZml4ID0gdHJ1ZSkge1xuICAgIGlmICghaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gL14oMHh8MFgpWzAtOWEtZkEtRl0rJC8udGVzdCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiAvXlswLTlhLWZBLUZdKyQvLnRlc3QodmFsdWUpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbHVlIGNhbiBiZSBjb25zaWRlcmVkIGFzIEJpZ051bWJlci5cbiAqIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhIEJpZ051bWJlciBpZiBpdCBpcyBhIGJpZ2ludCBvciBhIHN0cmluZ1xuICogdGhhdCBjYW4gYmUgY29udmVydGVkIHRvIGEgYmlnaW50ICh2aWEgYEJpZ2ludChzKWApLlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqL1xuZnVuY3Rpb24gaXNCaWdOdW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gaXNCaWdJbnQodmFsdWUpIHx8IGlzU3RyaW5naWZpZWRCaWdJbnQodmFsdWUpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbHVlIGNhbiBiZSBjb25zaWRlcmVkIGFzIEJpZ051bWJlcmlzaC5cbiAqIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBCaWdOdW1iZXJpc2ggaWYgaXQgbWVldHNcbiAqIGFueSBvZiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6IGl0J3MgYSBudW1iZXIsIGEgYmlnaW50LCBhIHN0cmluZ1xuICogdGhhdCBjYW4gYmUgY29udmVydGVkIHRvIGEgYmlnaW50LCBhIGhleGFkZWNpbWFsXG4gKiBzdHJpbmcsIG9yIGEgQnVmZmVyIG9iamVjdC5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKi9cbmZ1bmN0aW9uIGlzQmlnTnVtYmVyaXNoKHZhbHVlKSB7XG4gICAgcmV0dXJuIChpc051bWJlcih2YWx1ZSkgfHxcbiAgICAgICAgaXNCaWdJbnQodmFsdWUpIHx8XG4gICAgICAgIGlzU3RyaW5naWZpZWRCaWdJbnQodmFsdWUpIHx8XG4gICAgICAgIGlzSGV4YWRlY2ltYWwodmFsdWUpIHx8XG4gICAgICAgIGlzQnVmZmVyKHZhbHVlKSB8fFxuICAgICAgICBpc1VpbnQ4QXJyYXkodmFsdWUpKTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSB0eXBlIGlzIHRoZSBzYW1lIGFzIHRoZSB0eXBlIHBhc3NlZFxuICogYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB2YWx1ZVxuICogQHBhcmFtIHR5cGUgVGhlIGV4cGVjdGVkIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzVHlwZSh2YWx1ZSwgdHlwZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICByZXR1cm4gaXNOdW1iZXIodmFsdWUpO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4gaXNTdHJpbmcodmFsdWUpO1xuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKHZhbHVlKTtcbiAgICAgICAgY2FzZSBcIkFycmF5XCI6XG4gICAgICAgICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJVaW50OEFycmF5XCI6XG4gICAgICAgICAgICByZXR1cm4gaXNVaW50OEFycmF5KHZhbHVlKTtcbiAgICAgICAgY2FzZSBcIkJ1ZmZlclwiOlxuICAgICAgICAgICAgcmV0dXJuIGlzQnVmZmVyKHZhbHVlKTtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICAgICAgcmV0dXJuIGlzQmlnSW50KHZhbHVlKTtcbiAgICAgICAgY2FzZSBcInN0cmluZ2lmaWVkLWJpZ2ludFwiOlxuICAgICAgICAgICAgcmV0dXJuIGlzU3RyaW5naWZpZWRCaWdJbnQodmFsdWUpO1xuICAgICAgICBjYXNlIFwiaGV4YWRlY2ltYWxcIjpcbiAgICAgICAgICAgIHJldHVybiBpc0hleGFkZWNpbWFsKHZhbHVlKTtcbiAgICAgICAgY2FzZSBcImJpZ251bWJlclwiOlxuICAgICAgICAgICAgcmV0dXJuIGlzQmlnTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgY2FzZSBcImJpZ251bWJlcmlzaFwiOlxuICAgICAgICAgICAgcmV0dXJuIGlzQmlnTnVtYmVyaXNoKHZhbHVlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHlwZSBpcyBiZWluZyBzdXBwb3J0ZWQgYnkgdGhpcyB1dGlsaXR5XG4gKiBmdW5jdGlvbnMsIGZhbHNlIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIHRvIGJlIGNoZWNrZWQuXG4gKi9cbmZ1bmN0aW9uIGlzU3VwcG9ydGVkVHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuIHN1cHBvcnRlZFR5cGVzLmluY2x1ZGVzKHR5cGUpO1xufVxuXG52YXIgdHlwZUNoZWNrcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgaXNBcnJheTogaXNBcnJheSxcbiAgICBpc0JpZ0ludDogaXNCaWdJbnQsXG4gICAgaXNCaWdOdW1iZXI6IGlzQmlnTnVtYmVyLFxuICAgIGlzQmlnTnVtYmVyaXNoOiBpc0JpZ051bWJlcmlzaCxcbiAgICBpc0J1ZmZlcjogaXNCdWZmZXIsXG4gICAgaXNEZWZpbmVkOiBpc0RlZmluZWQsXG4gICAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgICBpc0hleGFkZWNpbWFsOiBpc0hleGFkZWNpbWFsLFxuICAgIGlzTnVtYmVyOiBpc051bWJlcixcbiAgICBpc09iamVjdDogaXNPYmplY3QsXG4gICAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICAgIGlzU3RyaW5naWZpZWRCaWdJbnQ6IGlzU3RyaW5naWZpZWRCaWdJbnQsXG4gICAgaXNTdXBwb3J0ZWRUeXBlOiBpc1N1cHBvcnRlZFR5cGUsXG4gICAgaXNUeXBlOiBpc1R5cGUsXG4gICAgaXNVaW50OEFycmF5OiBpc1VpbnQ4QXJyYXksXG4gICAgc3VwcG9ydGVkVHlwZXM6IHN1cHBvcnRlZFR5cGVzXG59KTtcblxuLyoqXG4gKiBAbW9kdWxlIEVycm9ySGFuZGxlcnNcbiAqIFRoaXMgbW9kdWxlIGlzIGRlc2lnbmVkIHRvIHByb3ZpZGUgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIHZhbGlkYXRpbmdcbiAqIGZ1bmN0aW9uIHBhcmFtZXRlcnMuIEl0IGluY2x1ZGVzIGZ1bmN0aW9ucyB0aGF0IHRocm93IHR5cGUgZXJyb3JzIGlmXG4gKiB0aGUgcGFyYW1ldGVycyBkbyBub3QgbWVldCBzcGVjaWZpZWQgY3JpdGVyaWEsIHN1Y2ggYXMgYmVpbmcgZGVmaW5lZCxcbiAqIGEgbnVtYmVyLCBhIHN0cmluZywgYSBmdW5jdGlvbiwgb3IgYW4gYXJyYXkuIFRoaXMgbW9kdWxlIGhlbHBzIGVuc3VyZVxuICogdGhhdCBmdW5jdGlvbnMgcmVjZWl2ZSB0aGUgY29ycmVjdCB0eXBlcyBvZiBpbnB1dHMsIGVuaGFuY2luZyBjb2RlXG4gKiByZWxpYWJpbGl0eSBhbmQgcmVkdWNpbmcgcnVudGltZSBlcnJvcnMuXG4gKi9cbi8qKlxuICogQHRocm93cyBUaHJvd3MgYSB0eXBlIGVycm9yIGlmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgaGFzIG5vdCBiZWVuIGRlZmluZWQuXG4gKiBAcGFyYW0gcGFyYW1ldGVyVmFsdWUgVGhlIHBhcmFtZXRlciB2YWx1ZS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJOYW1lIFRoZSBwYXJhbWV0ZXIgbmFtZS5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZURlZmluZWQocGFyYW1ldGVyVmFsdWUsIHBhcmFtZXRlck5hbWUpIHtcbiAgICBpZiAoIWlzRGVmaW5lZChwYXJhbWV0ZXJWYWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGFyYW1ldGVyICcke3BhcmFtZXRlck5hbWV9JyBpcyBub3QgZGVmaW5lZGApO1xuICAgIH1cbn1cbi8qKlxuICogQHRocm93cyBUaHJvd3MgYSB0eXBlIGVycm9yIGlmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgaXMgbm90IGEgbnVtYmVyLlxuICogQHBhcmFtIHBhcmFtZXRlclZhbHVlIFRoZSBwYXJhbWV0ZXIgdmFsdWUuXG4gKiBAcGFyYW0gcGFyYW1ldGVyTmFtZSBUaGUgcGFyYW1ldGVyIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVOdW1iZXIocGFyYW1ldGVyVmFsdWUsIHBhcmFtZXRlck5hbWUpIHtcbiAgICBpZiAoIWlzTnVtYmVyKHBhcmFtZXRlclZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJyR7cGFyYW1ldGVyTmFtZX0nIGlzIG5vdCBhIG51bWJlciwgcmVjZWl2ZWQgdHlwZTogJHt0eXBlb2YgcGFyYW1ldGVyVmFsdWV9YCk7XG4gICAgfVxufVxuLyoqXG4gKiBAdGhyb3dzIFRocm93cyBhIHR5cGUgZXJyb3IgaWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBpcyBub3QgYSBzdHJpbmcuXG4gKiBAcGFyYW0gcGFyYW1ldGVyVmFsdWUgVGhlIHBhcmFtZXRlciB2YWx1ZS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJOYW1lIFRoZSBwYXJhbWV0ZXIgbmFtZS5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZVN0cmluZyhwYXJhbWV0ZXJWYWx1ZSwgcGFyYW1ldGVyTmFtZSkge1xuICAgIGlmICghaXNTdHJpbmcocGFyYW1ldGVyVmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAnJHtwYXJhbWV0ZXJOYW1lfScgaXMgbm90IGEgc3RyaW5nLCByZWNlaXZlZCB0eXBlOiAke3R5cGVvZiBwYXJhbWV0ZXJWYWx1ZX1gKTtcbiAgICB9XG59XG4vKipcbiAqIEB0aHJvd3MgVGhyb3dzIGEgdHlwZSBlcnJvciBpZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIG5vdCBhIGZ1bmN0aW9uLlxuICogQHBhcmFtIHBhcmFtZXRlclZhbHVlIFRoZSBwYXJhbWV0ZXIgdmFsdWUuXG4gKiBAcGFyYW0gcGFyYW1ldGVyTmFtZSBUaGUgcGFyYW1ldGVyIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVGdW5jdGlvbihwYXJhbWV0ZXJWYWx1ZSwgcGFyYW1ldGVyTmFtZSkge1xuICAgIGlmICghaXNGdW5jdGlvbihwYXJhbWV0ZXJWYWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGFyYW1ldGVyICcke3BhcmFtZXRlck5hbWV9JyBpcyBub3QgYSBmdW5jdGlvbiwgcmVjZWl2ZWQgdHlwZTogJHt0eXBlb2YgcGFyYW1ldGVyVmFsdWV9YCk7XG4gICAgfVxufVxuLyoqXG4gKiBAdGhyb3dzIFRocm93cyBhIHR5cGUgZXJyb3IgaWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBpcyBub3QgYW4gQXJyYXkuXG4gKiBAcGFyYW0gcGFyYW1ldGVyVmFsdWUgVGhlIHBhcmFtZXRlciB2YWx1ZS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJOYW1lIFRoZSBwYXJhbWV0ZXIgbmFtZS5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZUFycmF5KHBhcmFtZXRlclZhbHVlLCBwYXJhbWV0ZXJOYW1lKSB7XG4gICAgaWYgKCFpc0FycmF5KHBhcmFtZXRlclZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJyR7cGFyYW1ldGVyTmFtZX0nIGlzIG5vdCBhbiBBcnJheSBpbnN0YW5jZWApO1xuICAgIH1cbn1cbi8qKlxuICogQHRocm93cyBUaHJvd3MgYSB0eXBlIGVycm9yIGlmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgaXMgbm90IGEgVWludDhBcnJheS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJWYWx1ZSBUaGUgcGFyYW1ldGVyIHZhbHVlLlxuICogQHBhcmFtIHBhcmFtZXRlck5hbWUgVGhlIHBhcmFtZXRlciBuYW1lLlxuICovXG5mdW5jdGlvbiByZXF1aXJlVWludDhBcnJheShwYXJhbWV0ZXJWYWx1ZSwgcGFyYW1ldGVyTmFtZSkge1xuICAgIGlmICghaXNVaW50OEFycmF5KHBhcmFtZXRlclZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJyR7cGFyYW1ldGVyTmFtZX0nIGlzIG5vdCBhIFVpbnQ4QXJyYXkgaW5zdGFuY2VgKTtcbiAgICB9XG59XG4vKipcbiAqIEB0aHJvd3MgVGhyb3dzIGEgdHlwZSBlcnJvciBpZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIG5vdCBhIEJ1ZmZlci5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJWYWx1ZSBUaGUgcGFyYW1ldGVyIHZhbHVlLlxuICogQHBhcmFtIHBhcmFtZXRlck5hbWUgVGhlIHBhcmFtZXRlciBuYW1lLlxuICovXG5mdW5jdGlvbiByZXF1aXJlQnVmZmVyKHBhcmFtZXRlclZhbHVlLCBwYXJhbWV0ZXJOYW1lKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihwYXJhbWV0ZXJWYWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGFyYW1ldGVyICcke3BhcmFtZXRlck5hbWV9JyBpcyBub3QgYSBCdWZmZXIgaW5zdGFuY2VgKTtcbiAgICB9XG59XG4vKipcbiAqIEB0aHJvd3MgVGhyb3dzIGEgdHlwZSBlcnJvciBpZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIG5vdCBhbiBvYmplY3QuXG4gKiBQbGVhc2UsIG5vdGUgdGhhdCBhcnJheXMgYXJlIGFsc28gb2JqZWN0cyBpbiBKYXZhU2NyaXB0LlxuICogQHBhcmFtIHBhcmFtZXRlclZhbHVlIFRoZSBwYXJhbWV0ZXIgdmFsdWUuXG4gKiBAcGFyYW0gcGFyYW1ldGVyTmFtZSBUaGUgcGFyYW1ldGVyIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVPYmplY3QocGFyYW1ldGVyVmFsdWUsIHBhcmFtZXRlck5hbWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHBhcmFtZXRlclZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJyR7cGFyYW1ldGVyTmFtZX0nIGlzIG5vdCBhbiBvYmplY3QsIHJlY2VpdmVkIHR5cGU6ICR7dHlwZW9mIHBhcmFtZXRlclZhbHVlfWApO1xuICAgIH1cbn1cbi8qKlxuICogQHRocm93cyBUaHJvd3MgYSB0eXBlIGVycm9yIGlmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgaXMgbm90IGEgYmlnaW50LlxuICogQHBhcmFtIHBhcmFtZXRlclZhbHVlIFRoZSBwYXJhbWV0ZXIgdmFsdWUuXG4gKiBAcGFyYW0gcGFyYW1ldGVyTmFtZSBUaGUgcGFyYW1ldGVyIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVCaWdJbnQocGFyYW1ldGVyVmFsdWUsIHBhcmFtZXRlck5hbWUpIHtcbiAgICBpZiAoIWlzQmlnSW50KHBhcmFtZXRlclZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJyR7cGFyYW1ldGVyTmFtZX0nIGlzIG5vdCBhIGJpZ2ludCwgcmVjZWl2ZWQgdHlwZTogJHt0eXBlb2YgcGFyYW1ldGVyVmFsdWV9YCk7XG4gICAgfVxufVxuLyoqXG4gKiBAdGhyb3dzIFRocm93cyBhIHR5cGUgZXJyb3IgaWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBpcyBub3QgYSBzdHJpbmdpZmllZCBiaWdpbnQuXG4gKiBAcGFyYW0gcGFyYW1ldGVyVmFsdWUgVGhlIHBhcmFtZXRlciB2YWx1ZS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJOYW1lIFRoZSBwYXJhbWV0ZXIgbmFtZS5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZVN0cmluZ2lmaWVkQmlnSW50KHBhcmFtZXRlclZhbHVlLCBwYXJhbWV0ZXJOYW1lKSB7XG4gICAgaWYgKCFpc1N0cmluZ2lmaWVkQmlnSW50KHBhcmFtZXRlclZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJyR7cGFyYW1ldGVyTmFtZX0nIGlzIG5vdCBhIHN0cmluZ2lmaWVkIGJpZ2ludGApO1xuICAgIH1cbn1cbi8qKlxuICogQHRocm93cyBUaHJvd3MgYSB0eXBlIGVycm9yIGlmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgaXMgbm90IGEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICogSWYgJ3ByZWZpeCcgaXMgJ3RydWUnLCB0aGUgc3RyaW5nIG11c3Qgc3RhcnQgd2l0aCAnMHgnIG9yICcwWCcgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmVcbiAqIGhleGFkZWNpbWFsIGRpZ2l0cyAoMC05LCBhLWYsIEEtRiksIG90aGVyd2lzZSBubyBwcmVmaXggaXMgZXhwZWN0ZWQuICdwcmVmaXgnIGlzIG9wdGlvbmFsIGFuZFxuICogaWYgaXRzIHZhbHVlIGl0IGlzIG5vdCBleHBsaWNpdGx5IGRlZmluZWQgaXQgd2lsbCBiZSBzZXQgdG8gJ3RydWUnIGJ5IGRlZmF1bHQuXG4gKiBAcGFyYW0gcGFyYW1ldGVyVmFsdWUgVGhlIHBhcmFtZXRlciB2YWx1ZS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJOYW1lIFRoZSBwYXJhbWV0ZXIgbmFtZS5cbiAqIEBwYXJhbSBwcmVmaXggQSBib29sZWFuIHRvIGluY2x1ZGUgb3Igbm90IGEgJzB4JyBvciAnMFgnIHByZWZpeC5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZUhleGFkZWNpbWFsKHBhcmFtZXRlclZhbHVlLCBwYXJhbWV0ZXJOYW1lLCBwcmVmaXggPSB0cnVlKSB7XG4gICAgaWYgKCFpc0hleGFkZWNpbWFsKHBhcmFtZXRlclZhbHVlLCBwcmVmaXgpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAnJHtwYXJhbWV0ZXJOYW1lfScgaXMgbm90IGEgaGV4YWRlY2ltYWwgc3RyaW5nYCk7XG4gICAgfVxufVxuLyoqXG4gKiBAdGhyb3dzIFRocm93cyBhIHR5cGUgZXJyb3IgaWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBpcyBub3QgYSBiaWdudW1iZXIuXG4gKiBAcGFyYW0gcGFyYW1ldGVyVmFsdWUgVGhlIHBhcmFtZXRlciB2YWx1ZS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJOYW1lIFRoZSBwYXJhbWV0ZXIgbmFtZS5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZUJpZ051bWJlcihwYXJhbWV0ZXJWYWx1ZSwgcGFyYW1ldGVyTmFtZSkge1xuICAgIGlmICghaXNCaWdOdW1iZXIocGFyYW1ldGVyVmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAnJHtwYXJhbWV0ZXJOYW1lfScgaXMgbm90IGEgYmlnbnVtYmVyYCk7XG4gICAgfVxufVxuLyoqXG4gKiBAdGhyb3dzIFRocm93cyBhIHR5cGUgZXJyb3IgaWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBpcyBub3QgYSBiaWdudW1iZXItaXNoLlxuICogQHBhcmFtIHBhcmFtZXRlclZhbHVlIFRoZSBwYXJhbWV0ZXIgdmFsdWUuXG4gKiBAcGFyYW0gcGFyYW1ldGVyTmFtZSBUaGUgcGFyYW1ldGVyIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVCaWdOdW1iZXJpc2gocGFyYW1ldGVyVmFsdWUsIHBhcmFtZXRlck5hbWUpIHtcbiAgICBpZiAoIWlzQmlnTnVtYmVyaXNoKHBhcmFtZXRlclZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJyR7cGFyYW1ldGVyTmFtZX0nIGlzIG5vdCBhIGJpZ251bWJlci1pc2hgKTtcbiAgICB9XG59XG4vKipcbiAqIEB0aHJvd3MgVGhyb3dzIGEgdHlwZSBlcnJvciBpZiB0aGUgcGFyYW1ldGVyIHZhbHVlIHR5cGUgaXMgbm90IHBhcnQgb2YgdGhlIGxpc3Qgb2YgdHlwZXMuXG4gKiBAcGFyYW0gcGFyYW1ldGVyVmFsdWUgVGhlIHBhcmFtZXRlciB2YWx1ZS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJOYW1lIFRoZSBwYXJhbWV0ZXIgbmFtZS5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZVR5cGVzKHBhcmFtZXRlclZhbHVlLCBwYXJhbWV0ZXJOYW1lLCB0eXBlcykge1xuICAgIGZvciAoY29uc3QgdHlwZSBvZiB0eXBlcykge1xuICAgICAgICBpZiAoIWlzU3VwcG9ydGVkVHlwZSh0eXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUeXBlICcke3R5cGV9JyBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCB0eXBlIG9mIHR5cGVzKSB7XG4gICAgICAgIGlmIChpc1R5cGUocGFyYW1ldGVyVmFsdWUsIHR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGFyYW1ldGVyICcke3BhcmFtZXRlck5hbWV9JyBpcyBub25lIG9mIHRoZSBmb2xsb3dpbmcgdHlwZXM6ICR7dHlwZXMuam9pbihcIiwgXCIpfWApO1xufVxuXG52YXIgZXJyb3JIYW5kbGVycyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgcmVxdWlyZUFycmF5OiByZXF1aXJlQXJyYXksXG4gICAgcmVxdWlyZUJpZ0ludDogcmVxdWlyZUJpZ0ludCxcbiAgICByZXF1aXJlQmlnTnVtYmVyOiByZXF1aXJlQmlnTnVtYmVyLFxuICAgIHJlcXVpcmVCaWdOdW1iZXJpc2g6IHJlcXVpcmVCaWdOdW1iZXJpc2gsXG4gICAgcmVxdWlyZUJ1ZmZlcjogcmVxdWlyZUJ1ZmZlcixcbiAgICByZXF1aXJlRGVmaW5lZDogcmVxdWlyZURlZmluZWQsXG4gICAgcmVxdWlyZUZ1bmN0aW9uOiByZXF1aXJlRnVuY3Rpb24sXG4gICAgcmVxdWlyZUhleGFkZWNpbWFsOiByZXF1aXJlSGV4YWRlY2ltYWwsXG4gICAgcmVxdWlyZU51bWJlcjogcmVxdWlyZU51bWJlcixcbiAgICByZXF1aXJlT2JqZWN0OiByZXF1aXJlT2JqZWN0LFxuICAgIHJlcXVpcmVTdHJpbmc6IHJlcXVpcmVTdHJpbmcsXG4gICAgcmVxdWlyZVN0cmluZ2lmaWVkQmlnSW50OiByZXF1aXJlU3RyaW5naWZpZWRCaWdJbnQsXG4gICAgcmVxdWlyZVR5cGVzOiByZXF1aXJlVHlwZXMsXG4gICAgcmVxdWlyZVVpbnQ4QXJyYXk6IHJlcXVpcmVVaW50OEFycmF5XG59KTtcblxuLyoqXG4gKiBAbW9kdWxlIENvbnZlcnNpb25zXG4gKiBUaGlzIG1vZHVsZSBwcm92aWRlcyBhIGNvbGxlY3Rpb24gb2YgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIGNvbnZlcnRpbmdcbiAqIGJldHdlZW4gZGlmZmVyZW50IG51bWVyaWNhbCBmb3JtYXRzLCBwYXJ0aWN1bGFybHkgZm9jdXNpbmcgb25cbiAqIGNvbnZlcnNpb25zIGludm9sdmluZyBiaWdpbnRzLCBoZXhhZGVjaW1hbHMgYW5kIGJ1ZmZlcnMuXG4gKiBUaGUgbW9kdWxlIGlzIHN0cnVjdHVyZWQgd2l0aCBjbGVhciBmdW5jdGlvbiBuYW1pbmcgdG8gaW5kaWNhdGVcbiAqIHRoZSBjb252ZXJzaW9uIGRpcmVjdGlvbiAoZS5nLiwgYGJpZ0ludFRvSGV4YWRlY2ltYWxgIGZvciBCaWdJbnRcbiAqIHRvIGhleGFkZWNpbWFsLCBgYnVmZmVyVG9CaWdJbnRgIGZvciBidWZmZXIgdG8gYmlnaW50KSBhbmQgZW1wbG95c1xuICogdHlwZSBjaGVja3MgdG8gZW5zdXJlIHRoZSBjb3JyZWN0IGhhbmRsaW5nIG9mIHZhcmlvdXMgaW5wdXQgdHlwZXMuXG4gKiBJdCBhbHNvIGluY2x1ZGVzIHZhcmlhdGlvbnMgZm9yIGJvdGggYmlnLWVuZGlhbiAoYGJlYCkgYW5kIGxpdHRsZS1lbmRpYW5cbiAqIChgbGVgKSBjb252ZXJzaW9ucy4gSXQgaXMgaW1wb3J0YW50IHRvIG5vdGUgdGhhdCB3aGVuIHRoZXJlIGlzIG5vIHByZWZpeCxcbiAqIHRoZSBvcmRlciBvZiBieXRlcyBpcyBhbHdheXMgYmlnLWVuZGlhbi5cbiAqL1xuLyoqXG4gKiBDb252ZXJ0cyBhIGJpZ2ludCB0byBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgYmlnaW50IHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgaGV4YWRlY2ltYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGJpZ2ludC5cbiAqL1xuZnVuY3Rpb24gYmlnSW50VG9IZXhhZGVjaW1hbCh2YWx1ZSkge1xuICAgIHJlcXVpcmVCaWdJbnQodmFsdWUsIFwidmFsdWVcIik7XG4gICAgbGV0IGhleCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICAvLyBFbnN1cmUgZXZlbiBsZW5ndGguXG4gICAgaWYgKGhleC5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgIGhleCA9IGAwJHtoZXh9YDtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8qKlxuICogQ29udmVydHMgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBiaWdpbnQuIFRoZSBpbnB1dCBpcyBpbnRlcnByZXRlZCBhcyBoZXhhZGVjaW1hbFxuICogd2l0aCBvciB3aXRob3V0IGEgJzB4JyBwcmVmaXguIEl0IHVzZXMgYmlnLWVuZGlhbiBieXRlIG9yZGVyLlxuICogQHBhcmFtIHZhbHVlIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBiaWdpbnQgcmVwcmVzZW50YXRpb24gb2YgdGhlIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gaGV4YWRlY2ltYWxUb0JpZ0ludCh2YWx1ZSkge1xuICAgIGlmICghaXNIZXhhZGVjaW1hbCh2YWx1ZSkgJiYgIWlzSGV4YWRlY2ltYWwodmFsdWUsIGZhbHNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJ3ZhbHVlJyBpcyBub3QgYSBoZXhhZGVjaW1hbCBzdHJpbmdgKTtcbiAgICB9XG4gICAgLy8gRW5zdXJlIHRoZSBoZXggc3RyaW5nIHN0YXJ0cyB3aXRoICcweCcuXG4gICAgY29uc3QgZm9ybWF0dGVkSGV4U3RyaW5nID0gdmFsdWUuc3RhcnRzV2l0aChcIjB4XCIpID8gdmFsdWUgOiBgMHgke3ZhbHVlfWA7XG4gICAgcmV0dXJuIEJpZ0ludChmb3JtYXR0ZWRIZXhTdHJpbmcpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGJ1ZmZlciBvZiBieXRlcyB0byBhIGJpZ2ludCB1c2luZyBiaWctZW5kaWFuIGJ5dGUgb3JkZXIuXG4gKiBJdCBhY2NlcHRzICdCdWZmZXInIG9yICdVaW50OEFycmF5Jy5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgYnVmZmVyIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgYmlnaW50IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBidWZmZXIncyBjb250ZW50cy5cbiAqL1xuZnVuY3Rpb24gYmVCdWZmZXJUb0JpZ0ludCh2YWx1ZSkge1xuICAgIHJlcXVpcmVUeXBlcyh2YWx1ZSwgXCJ2YWx1ZVwiLCBbXCJCdWZmZXJcIiwgXCJVaW50OEFycmF5XCJdKTtcbiAgICByZXR1cm4gQmlnSW50KGAweCR7QnVmZmVyLmZyb20odmFsdWUpLnRvU3RyaW5nKFwiaGV4XCIpfWApO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGJ1ZmZlciB0byBhIGJpZ2ludCB1c2luZyBsaXR0bGUtZW5kaWFuIGJ5dGUgb3JkZXIuXG4gKiBJdCBhY2NlcHRzICdCdWZmZXInIG9yICdVaW50OEFycmF5Jy5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgYnVmZmVyIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgYmlnaW50IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBidWZmZXIncyBjb250ZW50cyBpbiBsaXR0bGUtZW5kaWFuLlxuICovXG5mdW5jdGlvbiBsZUJ1ZmZlclRvQmlnSW50KHZhbHVlKSB7XG4gICAgcmVxdWlyZVR5cGVzKHZhbHVlLCBcInZhbHVlXCIsIFtcIkJ1ZmZlclwiLCBcIlVpbnQ4QXJyYXlcIl0pO1xuICAgIHJldHVybiBCaWdJbnQoYDB4JHtCdWZmZXIuZnJvbSh2YWx1ZSkucmV2ZXJzZSgpLnRvU3RyaW5nKFwiaGV4XCIpfWApO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGJ1ZmZlciB0byBhIGJpZ2ludC4gQWxpYXMgZm9yIGJlQnVmZmVyVG9CaWdJbnQuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIGJ1ZmZlciB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGJpZ2ludCByZXByZXNlbnRhdGlvbiBvZiB0aGUgYnVmZmVyJ3MgY29udGVudHMuXG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlclRvQmlnSW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIGJlQnVmZmVyVG9CaWdJbnQodmFsdWUpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGJpZ2ludCB0byBhIGJ1ZmZlciBhbmQgZmlsbHMgd2l0aCB6ZXJvcyBpZiBhIHZhbGlkXG4gKiBzaXplIChpLmUuIG51bWJlciBvZiBieXRlcykgaXMgc3BlY2lmaWVkLiBJZiB0aGUgc2l6ZSBpcyBub3QgZGVmaW5lZCxcbiAqIGl0IGdldHMgdGhlIHNpemUgZnJvbSB0aGUgZ2l2ZW4gYmlnaW50LiBJZiB0aGUgc3BlY2lmaWVkIHNpemUgaXMgc21hbGxlciB0aGFuXG4gKiB0aGUgc2l6ZSBvZiB0aGUgYmlnaW50IChpLmUuIGBtaW5TaXplYCksIGFuIGVycm9yIGlzIHRocm93bi5cbiAqIEl0IHVzZXMgYmlnLWVuZGlhbiBieXRlIG9yZGVyLlxuICogQHBhcmFtIHZhbHVlIFRoZSBiaWdpbnQgdG8gY29udmVydC5cbiAqIEBwYXJhbSBzaXplIFRoZSBudW1iZXIgb2YgYnl0ZXMgb2YgdGhlIGJ1ZmZlciB0byByZXR1cm4uXG4gKiBAcmV0dXJucyBUaGUgYnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBiaWdpbnQuXG4gKi9cbmZ1bmN0aW9uIGJlQmlnSW50VG9CdWZmZXIodmFsdWUsIHNpemUpIHtcbiAgICBjb25zdCBoZXggPSBiaWdJbnRUb0hleGFkZWNpbWFsKHZhbHVlKTtcbiAgICAvLyBDYWxjdWxhdGUgdGhlIG1pbmltdW0gYnVmZmVyIHNpemUgcmVxdWlyZWQgdG8gcmVwcmVzZW50ICduJyBpbiBieXRlcy5cbiAgICAvLyBFYWNoIGhleGFkZWNpbWFsIGNoYXJhY3RlciByZXByZXNlbnRzIDQgYml0cywgc28gMiBjaGFyYWN0ZXJzIGFyZSAxIGJ5dGUuXG4gICAgY29uc3QgbWluU2l6ZSA9IE1hdGguY2VpbChoZXgubGVuZ3RoIC8gMik7XG4gICAgaWYgKCFzaXplKSB7XG4gICAgICAgIHNpemUgPSBtaW5TaXplO1xuICAgIH1cbiAgICBlbHNlIGlmIChzaXplIDwgbWluU2l6ZSkge1xuICAgICAgICB0aHJvdyBFcnJvcihgU2l6ZSAke3NpemV9IGlzIHRvbyBzbWFsbCwgbmVlZCBhdCBsZWFzdCAke21pblNpemV9IGJ5dGVzYCk7XG4gICAgfVxuICAgIC8vIEFsbG9jYXRlIGJ1ZmZlciBvZiB0aGUgZGVzaXJlZCBzaXplLCBmaWxsZWQgd2l0aCB6ZXJvcy5cbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2Moc2l6ZSwgMCk7XG4gICAgY29uc3QgZnJvbUhleCA9IEJ1ZmZlci5mcm9tKGhleCwgXCJoZXhcIik7XG4gICAgZnJvbUhleC5jb3B5KGJ1ZmZlciwgc2l6ZSAtIGZyb21IZXgubGVuZ3RoKTtcbiAgICByZXR1cm4gYnVmZmVyO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGJpZ2ludCB0byBhIGJ1ZmZlciBhbmQgZmlsbHMgd2l0aCB6ZXJvcyBpZiBhIHZhbGlkXG4gKiBzaXplIChpLmUuIG51bWJlciBvZiBieXRlcykgaXMgc3BlY2lmaWVkLiBJZiB0aGUgc2l6ZSBpcyBub3QgZGVmaW5lZCxcbiAqIGl0IGdldHMgdGhlIHNpemUgZnJvbSB0aGUgZ2l2ZW4gYmlnaW50LiBJZiB0aGUgc3BlY2lmaWVkIHNpemUgaXMgc21hbGxlciB0aGFuXG4gKiB0aGUgc2l6ZSBvZiB0aGUgYmlnaW50IChpLmUuIGBtaW5TaXplYCksIGFuIGVycm9yIGlzIHRocm93bi5cbiAqIEl0IHVzZXMgbGl0dGxlLWVuZGlhbiBieXRlIG9yZGVyLlxuICogQHBhcmFtIHZhbHVlIFRoZSBiaWdpbnQgdG8gY29udmVydC5cbiAqIEBwYXJhbSBzaXplIFRoZSBudW1iZXIgb2YgYnl0ZXMgb2YgdGhlIGJ1ZmZlciB0byByZXR1cm4uXG4gKiBAcmV0dXJucyBUaGUgYnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBiaWdpbnQgaW4gbGl0dGxlLWVuZGlhbi5cbiAqL1xuZnVuY3Rpb24gbGVCaWdJbnRUb0J1ZmZlcih2YWx1ZSwgc2l6ZSkge1xuICAgIGNvbnN0IGhleCA9IGJpZ0ludFRvSGV4YWRlY2ltYWwodmFsdWUpO1xuICAgIC8vIENhbGN1bGF0ZSB0aGUgbWluaW11bSBidWZmZXIgc2l6ZSByZXF1aXJlZCB0byByZXByZXNlbnQgJ24nIGluIGJ5dGVzLlxuICAgIC8vIEVhY2ggaGV4YWRlY2ltYWwgY2hhcmFjdGVyIHJlcHJlc2VudHMgNCBiaXRzLCBzbyAyIGNoYXJhY3RlcnMgYXJlIDEgYnl0ZS5cbiAgICBjb25zdCBtaW5TaXplID0gTWF0aC5jZWlsKGhleC5sZW5ndGggLyAyKTtcbiAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgc2l6ZSA9IG1pblNpemU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNpemUgPCBtaW5TaXplKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBTaXplICR7c2l6ZX0gaXMgdG9vIHNtYWxsLCBuZWVkIGF0IGxlYXN0ICR7bWluU2l6ZX0gYnl0ZXNgKTtcbiAgICB9XG4gICAgLy8gQWxsb2NhdGUgYnVmZmVyIG9mIHRoZSBkZXNpcmVkIHNpemUsIGZpbGxlZCB3aXRoIHplcm9zLlxuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhzaXplLCAwKTtcbiAgICBjb25zdCBmcm9tSGV4ID0gQnVmZmVyLmZyb20oaGV4LCBcImhleFwiKS5yZXZlcnNlKCk7XG4gICAgZnJvbUhleC5jb3B5KGJ1ZmZlciwgMCk7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cbi8qKlxuICogQ29udmVydHMgYSBiaWdpbnQgdG8gYSBidWZmZXIuIEFsaWFzIGZvciBiZUJpZ0ludFRvQnVmZmVyLlxuICogQHBhcmFtIHZhbHVlIFRoZSBiaWdpbnQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBidWZmZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIGJpZ2ludC5cbiAqL1xuZnVuY3Rpb24gYmlnSW50VG9CdWZmZXIodmFsdWUpIHtcbiAgICByZXR1cm4gYmVCaWdJbnRUb0J1ZmZlcih2YWx1ZSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgQmlnTnVtYmVyaXNoIHR5cGUgdG8gYSBiaWdpbnQuIElmIHRoZSBpbnB1dCBpcyBhbHJlYWR5IGEgYmlnaW50LFxuICogdGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIHRoZSBiaWdpbnQgaXRzZWxmLCBvdGhlcndpc2UgaXQgd2lsbCBiZSBjb252ZXJ0ZWRcbiAqIHRvIGEgYmlnaW50IHVzaW5nIGJpZy1lbmRpYW4gYnl0ZSBvcmRlci5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgQmlnTnVtYmVyaXNoIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgYmlnaW50IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBCaWdOdW1iZXJpc2ggdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJpZ051bWJlcmlzaFRvQmlnSW50KHZhbHVlKSB7XG4gICAgcmVxdWlyZUJpZ051bWJlcmlzaCh2YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICBpZiAoaXNCdWZmZXIodmFsdWUpIHx8IGlzVWludDhBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlclRvQmlnSW50KHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgQmlnTnVtYmVyaXNoIHR5cGUgdG8gYSBidWZmZXIuIElmIHRoZSBpbnB1dCBpcyBhbHJlYWR5IGEgYnVmZmVyLFxuICogdGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIHRoZSBidWZmZXIgaXRzZWxmLCBvdGhlcndpc2UgaXQgd2lsbCBiZSBjb252ZXJ0ZWRcbiAqIHRvIGEgYnVmZmVyIHVzaW5nIGJpZy1lbmRpYW4gYnl0ZSBvcmRlci5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgQmlnTnVtYmVyaXNoIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgYnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBCaWdOdW1iZXJpc2ggdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJpZ051bWJlcmlzaFRvQnVmZmVyKHZhbHVlKSB7XG4gICAgcmVxdWlyZUJpZ051bWJlcmlzaCh2YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICBpZiAoaXNCdWZmZXIodmFsdWUpIHx8IGlzVWludDhBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGJpZ0ludFRvQnVmZmVyKGJpZ051bWJlcmlzaFRvQmlnSW50KHZhbHVlKSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIGhleGFkZWNpbWFsIHN0cmluZyB0byBhIGJ1ZmZlci4gVGhlIGhleGFkZWNpbWFsIHN0cmluZ1xuICogc2hvdWxkIG5vdCBzdGFydCB3aXRoICcweCcgb3IgJzBYJy4gSXQga2VlcHMgdGhlIGJ5dGVzIGluIHRoZSBzYW1lIG9yZGVyLlxuICogQHBhcmFtIHZhbHVlIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBidWZmZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gaGV4YWRlY2ltYWxUb0J1ZmZlcih2YWx1ZSkge1xuICAgIHJlcXVpcmVIZXhhZGVjaW1hbCh2YWx1ZSwgXCJ2YWx1ZVwiLCBmYWxzZSk7XG4gICAgLy8gRW5zdXJlIGV2ZW4gbGVuZ3RoIGJlZm9yZSBjb252ZXJ0aW5nIHRvIGJ1ZmZlci5cbiAgICBpZiAodmFsdWUubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICB2YWx1ZSA9IGAwJHt2YWx1ZX1gO1xuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUsIFwiaGV4XCIpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGJ1ZmZlciB0byBhIGhleGFkZWNpbWFsIHN0cmluZy4gSXQgYWNjZXB0cyAnQnVmZmVyJyBvciAnVWludDhBcnJheScuXG4gKiBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHdpbGwgbm90IHN0YXJ0IHdpdGggJzB4JyBvciAnMFgnLiBJdCBrZWVwcyB0aGUgYnl0ZXMgaW4gdGhlIHNhbWUgb3JkZXIuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIGJ1ZmZlciB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlclRvSGV4YWRlY2ltYWwodmFsdWUpIHtcbiAgICByZXF1aXJlVHlwZXModmFsdWUsIFwidmFsdWVcIiwgW1wiQnVmZmVyXCIsIFwiVWludDhBcnJheVwiXSk7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlKS50b1N0cmluZyhcImhleFwiKTtcbn1cbi8qKlxuICogQ29udmVydHMgYnl0ZXMgdG8gYSBiYXNlNjQgc3RyaW5nLiBJdCBhY2NlcHRzICdCdWZmZXInIG9yICdVaW50OEFycmF5Jy5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgYnl0ZXMgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBjb252ZXJ0ZWQgYmFzZTY0IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYnVmZmVyVG9CYXNlNjQodmFsdWUpIHtcbiAgICByZXF1aXJlVHlwZXModmFsdWUsIFwidmFsdWVcIiwgW1wiQnVmZmVyXCIsIFwiVWludDhBcnJheVwiXSk7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBiYXNlNjQgc3RyaW5nIHRvIGJ5dGVzIChpLmUuIGEgYnVmZmVyKS4gVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBjaGVja1xuICogaWYgdGhlIGlucHV0IHZhbHVlIGlzIGEgdmFsaWQgYmFzZTY0IHN0cmluZy4gSWYgdGhlcmUgYXJlIHVuc3VwcG9ydGVkIGNoYXJhY3RlcnNcbiAqIHRoZXkgd2lsbCBiZSBpZ25vcmVkLlxuICogQHBhcmFtIHZhbHVlIFRoZSBiYXNlNjQgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgY29udmVydGVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gYmFzZTY0VG9CdWZmZXIodmFsdWUpIHtcbiAgICByZXF1aXJlU3RyaW5nKHZhbHVlLCBcInZhbHVlXCIpO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZSwgXCJiYXNlNjRcIik7XG59XG4vKipcbiAqIENvbnZlcnRzIHRleHQgKHV0ZjgpIHRvIGEgYmFzZTY0IHN0cmluZy5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdGV4dCB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCBiYXNlNjQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB0ZXh0VG9CYXNlNjQodmFsdWUpIHtcbiAgICByZXF1aXJlU3RyaW5nKHZhbHVlLCBcInZhbHVlXCIpO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZSwgXCJ1dGY4XCIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGJhc2U2NCBzdHJpbmcgdG8gdGV4dCAodXRmOCkuIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgY2hlY2tcbiAqIGlmIHRoZSBpbnB1dCB2YWx1ZSBpcyBhIHZhbGlkIGJhc2U2NCBzdHJpbmcuIElmIHRoZXJlIGFyZSB1bnN1cHBvcnRlZCBjaGFyYWN0ZXJzXG4gKiB0aGV5IGNvdWxkIGJlIGlnbm9yZWQgYW5kIHRoZSByZXN1bHQgbWF5IGJlIHVuZXhwZWN0ZWQuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIGJhc2U2NCBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBjb252ZXJ0ZWQgdGV4dC5cbiAqL1xuZnVuY3Rpb24gYmFzZTY0VG9UZXh0KHZhbHVlKSB7XG4gICAgcmVxdWlyZVN0cmluZyh2YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKFwidXRmOFwiKTtcbn1cblxudmFyIGNvbnZlcnNpb25zID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBiYXNlNjRUb0J1ZmZlcjogYmFzZTY0VG9CdWZmZXIsXG4gICAgYmFzZTY0VG9UZXh0OiBiYXNlNjRUb1RleHQsXG4gICAgYmVCaWdJbnRUb0J1ZmZlcjogYmVCaWdJbnRUb0J1ZmZlcixcbiAgICBiZUJ1ZmZlclRvQmlnSW50OiBiZUJ1ZmZlclRvQmlnSW50LFxuICAgIGJpZ0ludFRvQnVmZmVyOiBiaWdJbnRUb0J1ZmZlcixcbiAgICBiaWdJbnRUb0hleGFkZWNpbWFsOiBiaWdJbnRUb0hleGFkZWNpbWFsLFxuICAgIGJpZ051bWJlcmlzaFRvQmlnSW50OiBiaWdOdW1iZXJpc2hUb0JpZ0ludCxcbiAgICBiaWdOdW1iZXJpc2hUb0J1ZmZlcjogYmlnTnVtYmVyaXNoVG9CdWZmZXIsXG4gICAgYnVmZmVyVG9CYXNlNjQ6IGJ1ZmZlclRvQmFzZTY0LFxuICAgIGJ1ZmZlclRvQmlnSW50OiBidWZmZXJUb0JpZ0ludCxcbiAgICBidWZmZXJUb0hleGFkZWNpbWFsOiBidWZmZXJUb0hleGFkZWNpbWFsLFxuICAgIGhleGFkZWNpbWFsVG9CaWdJbnQ6IGhleGFkZWNpbWFsVG9CaWdJbnQsXG4gICAgaGV4YWRlY2ltYWxUb0J1ZmZlcjogaGV4YWRlY2ltYWxUb0J1ZmZlcixcbiAgICBsZUJpZ0ludFRvQnVmZmVyOiBsZUJpZ0ludFRvQnVmZmVyLFxuICAgIGxlQnVmZmVyVG9CaWdJbnQ6IGxlQnVmZmVyVG9CaWdJbnQsXG4gICAgdGV4dFRvQmFzZTY0OiB0ZXh0VG9CYXNlNjRcbn0pO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSBzZXF1ZW5jZSBvZiBieXRlcyBzZWN1cmVseSB1c2luZyBOb2RlLmpzJ3MgY3J5cHRvIG1vZHVsZS5cbiAqIEBwYXJhbSBzaXplIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gZ2VuZXJhdGUuXG4gKiBAcmV0dXJucyBBIFVpbnQ4QXJyYXkgY29udGFpbmluZyB0aGUgZ2VuZXJhdGVkIHJhbmRvbSBieXRlcy5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L3ByZWZlci1kZWZhdWx0LWV4cG9ydCAqL1xuZnVuY3Rpb24gZ2V0UmFuZG9tVmFsdWVzKHNpemUpIHtcbiAgICBpZiAoc2l6ZSA8PSAwKVxuICAgICAgICB0aHJvdyBFcnJvcihgc2l6ZSAke3NpemV9IGlzIHRvbyBzbWFsbCwgbmVlZCBhdCBsZWFzdCAxYCk7XG4gICAgY29uc3QgYnVmZmVyID0gcmFuZG9tQnl0ZXMoc2l6ZSk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlci5idWZmZXIsIGJ1ZmZlci5ieXRlT2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aCk7XG59XG5cbnZhciBjcnlwdG9fbm9kZSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZ2V0UmFuZG9tVmFsdWVzOiBnZXRSYW5kb21WYWx1ZXNcbn0pO1xuXG4vKipcbiAqIEBtb2R1bGUgU2NhbGFyXG4gKiBUaGlzIG1vZHVsZSBwcm92aWRlcyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgcGVyZm9ybWluZyBzY2FsYXIgb3BlcmF0aW9uc1xuICogd2l0aGluIGEgZmllbGQsIGVzcGVjaWFsbHkgZGVzaWduZWQgdG8gaGFuZGxlIG9wZXJhdGlvbnMgb24gYmlnaW50cy5cbiAqIFRoZSBvcGVyYXRpb25zIGluY2x1ZGUgc2NhbGFyIGludmVyc2lvbiAoYGludmApLCBzY2FsYXIgZXhwb25lbnRpYXRpb24gKGBwb3dgKSxcbiAqIGFuZCBtb2R1bGFyIHJlZHVjdGlvbi4gRnVuY3Rpb25zIGFyZSBjYXJlZnVsbHkgaW1wbGVtZW50ZWQgdG8gZW5zdXJlXG4gKiBtYXRoZW1hdGljYWwgY29ycmVjdG5lc3MgYW5kIGVmZmljaWVuY3ksIHN1cHBvcnRpbmcgYm90aCBwb3NpdGl2ZSBhbmRcbiAqIG5lZ2F0aXZlIGJpZ2ludCB2YWx1ZXMuIFRoZSBtb2R1bGUgYWltcyB0byBwcm92aWRlIHJvYnVzdCB0b29scyBmb3JcbiAqIGNyeXB0b2dyYXBoaWMgY2FsY3VsYXRpb25zIGFuZCBvdGhlciBhcHBsaWNhdGlvbnMgcmVxdWlyaW5nIGhpZ2gtcHJlY2lzaW9uXG4gKiBhcml0aG1ldGljIGluIGZpZWxkcy5cbiAqL1xuLyoqXG4gKiBDaGVja3MgaWYgYSBiaWdpbnQgc2NhbGFyIHZhbHVlIGlzIHplcm8uXG4gKiBAcGFyYW0gYSBUaGUgYmlnaW50IHNjYWxhciB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFRydWUgaWYgJ2EnIGlzIHplcm8sIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNaZXJvKGEpIHtcbiAgICByZXR1cm4gIWE7XG59XG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhIGJpZ2ludCBzY2FsYXIgdmFsdWUgaXMgb2RkLlxuICogQHBhcmFtIGEgVGhlIGJpZ2ludCBzY2FsYXIgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBUcnVlIGlmICdhJyBpcyBvZGQsIGZhbHNlIGlmIGl0IGlzIGV2ZW4uXG4gKi9cbmZ1bmN0aW9uIGlzT2RkKGEpIHtcbiAgICByZXR1cm4gKGEgJiBCaWdJbnQoMSkpID09PSBCaWdJbnQoMSk7XG59XG4vKipcbiAqIFBlcmZvcm1zIGEgYml0d2lzZSByaWdodCBzaGlmdCBvbiBhIGJpZ2ludCBzY2FsYXIgdmFsdWUuXG4gKiBUaGlzIG9wZXJhdGlvbiBpcyBlcXVpdmFsZW50IHRvIGRpdmlkaW5nIGJ5IDJebiwgYnV0IGl0IG9wZXJhdGVzIGRpcmVjdGx5XG4gKiBvbiB0aGUgYmluYXJ5IHJlcHJlc2VudGF0aW9uLCBtYWtpbmcgaXQgZWZmaWNpZW50IGZvciBjZXJ0YWluIHR5cGVzIG9mIGNhbGN1bGF0aW9ucy5cbiAqIEBwYXJhbSBhIFRoZSBiaWdpbnQgc2NhbGFyIHZhbHVlIHRvIHNoaWZ0LlxuICogQHBhcmFtIG4gVGhlIG51bWJlciBvZiBiaXRzIHRvIHNoaWZ0ICdhJyBieS5cbiAqIEByZXR1cm5zIFRoZSByZXN1bHQgb2Ygc2hpZnRpbmcgJ2EnIHJpZ2h0IGJ5ICduJyBiaXRzLlxuICovXG5mdW5jdGlvbiBzaGlmdFJpZ2h0KGEsIG4pIHtcbiAgICByZXR1cm4gYSA+PiBuO1xufVxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBiaWdpbnQgc2NhbGFyIHZhbHVlcy5cbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCBiaWdpbnQgc2NhbGFyIHZhbHVlLlxuICogQHBhcmFtIGIgVGhlIHNlY29uZCBiaWdpbnQgc2NhbGFyIHZhbHVlLlxuICogQHJldHVybnMgVGhlIHByb2R1Y3Qgb2YgJ2EnIGFuZCAnYicuXG4gKi9cbmZ1bmN0aW9uIG11bChhLCBiKSB7XG4gICAgcmV0dXJuIGEgKiBiO1xufVxuLyoqXG4gKiBDb21wYXJlcyB0d28gYmlnaW50IHNjYWxhciB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZSBmaXJzdCBpcyBncmVhdGVyIHRoYW4gdGhlIHNlY29uZC5cbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCBiaWdpbnQgc2NhbGFyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0gYiBUaGUgc2Vjb25kIGJpZ2ludCBzY2FsYXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIFRydWUgaWYgJ2EnIGlzIGdyZWF0ZXIgdGhhbiAnYicsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gZ3QoYSwgYikge1xuICAgIHJldHVybiBhID4gYjtcbn1cbi8qKlxuICogQ29udmVydHMgYSBiaWdpbnQgc2NhbGFyIHZhbHVlIGludG8gYW4gYXJyYXkgb2YgYml0cywgcmVwcmVzZW50ZWQgYXMgbnVtYmVycy5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3IgZXhhbWluaW5nIHRoZSBiaW5hcnkgc3RydWN0dXJlIG9mIGJpZ2ludHMsXG4gKiB3aGljaCBjYW4gYmUgbmVjZXNzYXJ5IGZvciBiaXQgbWFuaXB1bGF0aW9uIGFuZCB1bmRlcnN0YW5kaW5nIHRoZSByZXByZXNlbnRhdGlvblxuICogb2YgbnVtYmVycyBhdCBhIGxvd2VyIGxldmVsLlxuICogQHBhcmFtIG4gVGhlIGJpZ2ludCBzY2FsYXIgdmFsdWUgdG8gY29udmVydCBpbnRvIGJpdHMuXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBudW1iZXJzIHJlcHJlc2VudGluZyB0aGUgYml0cyBvZiAnbicsIHN0YXJ0aW5nIGZyb20gdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdC5cbiAqL1xuZnVuY3Rpb24gYml0cyhuKSB7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgbGV0IEUgPSBuO1xuICAgIHdoaWxlIChFKSB7XG4gICAgICAgIGlmIChFICYgQmlnSW50KDEpKSB7XG4gICAgICAgICAgICByZXMucHVzaCgxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICAgIEUgPj49IEJpZ0ludCgxKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxudmFyIHNjYWxhciA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgYml0czogYml0cyxcbiAgICBndDogZ3QsXG4gICAgaXNPZGQ6IGlzT2RkLFxuICAgIGlzWmVybzogaXNaZXJvLFxuICAgIG11bDogbXVsLFxuICAgIHNoaWZ0UmlnaHQ6IHNoaWZ0UmlnaHRcbn0pO1xuXG4vKipcbiAqIEBjbGFzcyBGMUZpZWxkXG4gKiBSZXByZXNlbnRzIGEgZmluaXRlIGZpZWxkIG9mIG9yZGVyICdvcmRlcicgcHJvdmlkaW5nIGFyaXRobWV0aWMgb3BlcmF0aW9ucyB1bmRlciBtb2R1bHVzLlxuICogVGhpcyBjbGFzcyBpbmNsdWRlcyBvcGVyYXRpb25zIHN1Y2ggYXMgYWRkaXRpb24sIHN1YnRyYWN0aW9uLCBtdWx0aXBsaWNhdGlvbiwgZGl2aXNpb24sXG4gKiBhbmQgaW52ZXJzaW9uLCBhbGwgcGVyZm9ybWVkIG1vZHVsbyB0aGUgZmllbGQncyBvcmRlci4gSXQncyBkZXNpZ25lZCB0byB3b3JrIHdpdGggYmlnaW50cyxcbiAqIHN1cHBvcnRpbmcgbGFyZ2UgbnVtYmVycyBmb3IgY3J5cHRvZ3JhcGhpYyBwdXJwb3NlcyBhbmQgb3RoZXIgYXBwbGljYXRpb25zIHJlcXVpcmluZ1xuICogbW9kdWxhciBhcml0aG1ldGljLlxuICogTm90ZSB0aGF0IHRoZSBvdXRwdXRzIG9mIHRoZSBmdW5jdGlvbnMgd2lsbCBhbHdheXMgYmUgd2l0aGluIHRoZSBmaWVsZCBpZiBhbmQgb25seSBpZlxuICogdGhlIGlucHV0IHZhbHVlcyBhcmUgd2l0aGluIHRoZSBmaWVsZC4gRGV2cyBuZWVkIHRvIG1ha2Ugc3VyZSBvZiB0aGF0LlxuICpcbiAqIEBwcm9wZXJ0eSBvbmUgUmVwcmVzZW50cyB0aGUgc2NhbGFyIHZhbHVlIDEgaW4gdGhlIGZpZWxkLlxuICogQHByb3BlcnR5IHplcm8gUmVwcmVzZW50cyB0aGUgc2NhbGFyIHZhbHVlIDAgaW4gdGhlIGZpZWxkLlxuICogQHByb3BlcnR5IF9vcmRlciBUaGUgb3JkZXIgb2YgdGhlIGZpbml0ZSBmaWVsZCAoaS5lLiwgdGhlIG1vZHVsdXMpLlxuICogQHByb3BlcnR5IF9oYWxmIEhhbGYgdGhlIG9yZGVyIG9mIHRoZSBmaWVsZCwgdXNlZCBmb3IgY2VydGFpbiBjb21wYXJpc29ucy5cbiAqIEBwcm9wZXJ0eSBfbmVnb25lIFRoZSBzY2FsYXIgdmFsdWUgLTEgaW4gdGhlIGZpZWxkLCByZXByZXNlbnRlZCBwb3NpdGl2ZWx5LlxuICovXG5jbGFzcyBGMUZpZWxkIHtcbiAgICBjb25zdHJ1Y3RvcihvcmRlcikge1xuICAgICAgICB0aGlzLm9uZSA9IDFuO1xuICAgICAgICB0aGlzLnplcm8gPSAwbjtcbiAgICAgICAgdGhpcy5fb3JkZXIgPSBvcmRlcjtcbiAgICAgICAgdGhpcy5faGFsZiA9IG9yZGVyID4+IHRoaXMub25lO1xuICAgICAgICB0aGlzLl9uZWdvbmUgPSB0aGlzLl9vcmRlciAtIHRoaXMub25lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmVzIGEgZ2l2ZW4gcmVzdWx0IGZhbGxzIHdpdGhpbiB0aGUgZmllbGQgYnkgYXBwbHlpbmcgbW9kdWxhciByZWR1Y3Rpb24uXG4gICAgICogVGhpcyBtZXRob2QgYWxzbyBoYW5kbGVzIG5lZ2F0aXZlIGlucHV0cywgY29ycmVjdGx5IG1hcHBpbmcgdGhlbSBpbnRvIHRoZSBmaWVsZC5cbiAgICAgKiBAcGFyYW0gcmVzIFRoZSByZXN1bHQgdG8gYmUgbm9ybWFsaXplZCB0byB0aGUgZmllbGQuXG4gICAgICogQHJldHVybnMgVGhlIGVxdWl2YWxlbnQgdmFsdWUgd2l0aGluIHRoZSBmaWVsZC5cbiAgICAgKi9cbiAgICBlKHJlcykge1xuICAgICAgICByZXMgJT0gdGhpcy5fb3JkZXI7XG4gICAgICAgIHJldHVybiByZXMgPCAwID8gcmVzICsgdGhpcy5fb3JkZXIgOiByZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIG1vZHVsYXIgbXVsdGlwbGljYXRpb24gb2YgdHdvIGJpZ2ludCB2YWx1ZXMgd2l0aGluIHRoZSBmaWVsZC5cbiAgICAgKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmFsdWUuXG4gICAgICogQHBhcmFtIGIgVGhlIHNlY29uZCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgcHJvZHVjdCBvZiAnYScgYW5kICdiJyBtb2R1bG8gdGhlIGZpZWxkJ3Mgb3JkZXIuXG4gICAgICovXG4gICAgbXVsKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIChhICogYikgJSB0aGlzLl9vcmRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIG9uZSBiaWdpbnQgZnJvbSBhbm90aGVyIHVuZGVyIG1vZHVsdXMuXG4gICAgICogSXQgZW5zdXJlcyB0aGUgcmVzdWx0IGlzIHdpdGhpbiB0aGUgZmllbGQgaWYgYW5kIG9ubHkgaWYgdGhlIGlucHV0IHZhbHVlcyBhcmUgd2l0aGluIHRoZSBmaWVsZC5cbiAgICAgKiBAcGFyYW0gYSBUaGUgdmFsdWUgZnJvbSB3aGljaCB0byBzdWJ0cmFjdC5cbiAgICAgKiBAcGFyYW0gYiBUaGUgdmFsdWUgdG8gYmUgc3VidHJhY3RlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgZGlmZmVyZW5jZSBvZiAnYScgYW5kICdiJyBtb2R1bG8gdGhlIGZpZWxkJ3Mgb3JkZXIuXG4gICAgICovXG4gICAgc3ViKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPj0gYiA/IGEgLSBiIDogdGhpcy5fb3JkZXIgLSBiICsgYTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyB0d28gYmlnaW50IHZhbHVlcyB0b2dldGhlciB1bmRlciBtb2R1bHVzLlxuICAgICAqIEl0IGVuc3VyZXMgdGhlIHJlc3VsdCBpcyB3aXRoaW4gdGhlIGZpZWxkIGlmIGFuZCBvbmx5IGlmIHRoZSBpbnB1dCB2YWx1ZXMgYXJlIHdpdGhpbiB0aGUgZmllbGQuXG4gICAgICogQHBhcmFtIGEgVGhlIGZpcnN0IHZhbHVlLlxuICAgICAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmFsdWUuXG4gICAgICogQHJldHVybnMgVGhlIHN1bSBvZiAnYScgYW5kICdiJyBtb2R1bG8gdGhlIGZpZWxkJ3Mgb3JkZXIuXG4gICAgICovXG4gICAgYWRkKGEsIGIpIHtcbiAgICAgICAgY29uc3QgcmVzID0gYSArIGI7XG4gICAgICAgIHJldHVybiByZXMgPj0gdGhpcy5fb3JkZXIgPyByZXMgLSB0aGlzLl9vcmRlciA6IHJlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG11bHRpcGxpY2F0aXZlIGludmVyc2Ugb2YgYSBnaXZlbiB2YWx1ZSB3aXRoaW4gdGhlIGZpZWxkLlxuICAgICAqIFRoaXMgbWV0aG9kIHVzZXMgdGhlIEV4dGVuZGVkIEV1Y2xpZGVhbiBBbGdvcml0aG0gdG8gZmluZCB0aGUgaW52ZXJzZSxcbiAgICAgKiBlbnN1cmluZyB0aGUgcmVzdWx0IGlzIGFsd2F5cyBhIHBvc2l0aXZlIHZhbHVlIGxlc3MgdGhhbiB0aGUgZmllbGQncyBvcmRlci5cbiAgICAgKiBJZiB0aGUgaW5wdXQgdmFsdWUgaXMgemVybywgd2hpY2ggaGFzIG5vIGludmVyc2UsIGFuIGVycm9yIGlzIHRocm93bi5cbiAgICAgKiBAcGFyYW0gYSBUaGUgdmFsdWUgZm9yIHdoaWNoIHRvIGNvbXB1dGUgdGhlIGludmVyc2UuXG4gICAgICogQHJldHVybnMgVGhlIG11bHRpcGxpY2F0aXZlIGludmVyc2Ugb2YgJ2EnIG1vZHVsbyB0aGUgZmllbGQncyBvcmRlci5cbiAgICAgKiBAdGhyb3dzIGlmICdhJyBpcyB6ZXJvLlxuICAgICAqL1xuICAgIGludihhKSB7XG4gICAgICAgIGlmIChhID09PSB0aGlzLnplcm8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlplcm8gaGFzIG5vIGludmVyc2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHQgPSB0aGlzLnplcm87XG4gICAgICAgIGxldCByID0gdGhpcy5fb3JkZXI7XG4gICAgICAgIGxldCBuZXd0ID0gdGhpcy5vbmU7XG4gICAgICAgIGxldCBuZXdyID0gYSAlIHRoaXMuX29yZGVyO1xuICAgICAgICB3aGlsZSAobmV3cikge1xuICAgICAgICAgICAgY29uc3QgcSA9IHIgLyBuZXdyO1xuICAgICAgICAgICAgW3QsIG5ld3RdID0gW25ld3QsIHQgLSBxICogbmV3dF07XG4gICAgICAgICAgICBbciwgbmV3cl0gPSBbbmV3ciwgciAtIHEgKiBuZXdyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodCA8IHRoaXMuemVybykge1xuICAgICAgICAgICAgdCArPSB0aGlzLl9vcmRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBvbmUgYmlnaW50IGJ5IGFub3RoZXIgd2l0aGluIHRoZSBmaWVsZCBieSBtdWx0aXBseWluZyB0aGUgZmlyc3QgdmFsdWVcbiAgICAgKiBieSB0aGUgbXVsdGlwbGljYXRpdmUgaW52ZXJzZSBvZiB0aGUgc2Vjb25kLlxuICAgICAqIEBwYXJhbSBhIFRoZSBkaXZpZGVuZC5cbiAgICAgKiBAcGFyYW0gYiBUaGUgZGl2aXNvci5cbiAgICAgKiBAcmV0dXJucyBUaGUgcmVzdWx0IG9mIHRoZSBkaXZpc2lvbiBvZiAnYScgYnkgJ2InIG1vZHVsbyB0aGUgZmllbGQncyBvcmRlci5cbiAgICAgKi9cbiAgICBkaXYoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5tdWwoYSwgdGhpcy5pbnYoYikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdHdvIGJpZ2ludCB2YWx1ZXMgYXJlIGVxdWFsIHdpdGhpbiB0aGUgY29udGV4dCBvZiB0aGUgZmllbGQuXG4gICAgICogSXQgZW5zdXJlcyB0aGUgcmVzdWx0IGlzIHdpdGhpbiB0aGUgZmllbGQgaWYgYW5kIG9ubHkgaWYgdGhlIGlucHV0IHZhbHVlcyBhcmUgd2l0aGluIHRoZSBmaWVsZC5cbiAgICAgKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiAnYScgZXF1YWxzICdiJywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGVxKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNxdWFyZXMgYSBiaWdpbnQgdmFsdWUgd2l0aGluIHRoZSBmaWVsZC5cbiAgICAgKiBUaGlzIGlzIGEgc3BlY2lmaWMgY2FzZSBvZiBtdWx0aXBsaWNhdGlvbiB3aGVyZSB0aGUgdmFsdWUgaXMgbXVsdGlwbGllZCBieSBpdHNlbGYsXG4gICAgICogb3B0aW1pemVkIGZvciBwZXJmb3JtYW5jZSB3aGVyZSBhcHBsaWNhYmxlLlxuICAgICAqIEl0IGVuc3VyZXMgdGhlIHJlc3VsdCBpcyB3aXRoaW4gdGhlIGZpZWxkIGlmIGFuZCBvbmx5IGlmIHRoZSBpbnB1dCB2YWx1ZXMgYXJlIHdpdGhpbiB0aGUgZmllbGQuXG4gICAgICogQHBhcmFtIGEgVGhlIHZhbHVlIHRvIHNxdWFyZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgc3F1YXJlIG9mICdhJyBtb2R1bG8gdGhlIGZpZWxkJ3Mgb3JkZXIuXG4gICAgICovXG4gICAgc3F1YXJlKGEpIHtcbiAgICAgICAgcmV0dXJuIChhICogYSkgJSB0aGlzLl9vcmRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdHdvIGJpZ2ludCB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZSBmaXJzdCBpcyBsZXNzIHRoYW4gdGhlIHNlY29uZCxcbiAgICAgKiB0YWtpbmcgaW50byBhY2NvdW50IHRoZSBmaWVsZCdzIG9yZGVyIGZvciBtb2R1bGFyIGNvbXBhcmlzb24uXG4gICAgICogSXQgZW5zdXJlcyB0aGUgcmVzdWx0IGlzIHdpdGhpbiB0aGUgZmllbGQgaWYgYW5kIG9ubHkgaWYgdGhlIGlucHV0IHZhbHVlcyBhcmUgd2l0aGluIHRoZSBmaWVsZC5cbiAgICAgKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiAnYScgaXMgbGVzcyB0aGFuICdiJywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGx0KGEsIGIpIHtcbiAgICAgICAgY29uc3QgYWEgPSBhID4gdGhpcy5faGFsZiA/IGEgLSB0aGlzLl9vcmRlciA6IGE7XG4gICAgICAgIGNvbnN0IGJiID0gYiA+IHRoaXMuX2hhbGYgPyBiIC0gdGhpcy5fb3JkZXIgOiBiO1xuICAgICAgICByZXR1cm4gYWEgPCBiYjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdHdvIGJpZ2ludCB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZSBmaXJzdCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHNlY29uZCxcbiAgICAgKiBjb25zaWRlcmluZyB0aGUgZmllbGQncyBtb2R1bGFyIGNvbnRleHQuXG4gICAgICogSXQgZW5zdXJlcyB0aGUgcmVzdWx0IGlzIHdpdGhpbiB0aGUgZmllbGQgaWYgYW5kIG9ubHkgaWYgdGhlIGlucHV0IHZhbHVlcyBhcmUgd2l0aGluIHRoZSBmaWVsZC5cbiAgICAgKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiAnYScgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICdiJywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGdlcShhLCBiKSB7XG4gICAgICAgIGNvbnN0IGFhID0gYSA+IHRoaXMuX2hhbGYgPyBhIC0gdGhpcy5fb3JkZXIgOiBhO1xuICAgICAgICBjb25zdCBiYiA9IGIgPiB0aGlzLl9oYWxmID8gYiAtIHRoaXMuX29yZGVyIDogYjtcbiAgICAgICAgcmV0dXJuIGFhID49IGJiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbmVnYXRpb24gb2YgYSBiaWdpbnQgdmFsdWUgd2l0aGluIHRoZSBmaWVsZC5cbiAgICAgKiBUaGUgcmVzdWx0IGlzIHRoZSBtb2R1bGFyIGFkZGl0aXZlIGludmVyc2UgdGhhdCwgd2hlbiBhZGRlZCB0byB0aGUgb3JpZ2luYWwgdmFsdWUsXG4gICAgICogeWllbGRzIHplcm8gaW4gdGhlIGZpZWxkJ3MgbW9kdWx1cy5cbiAgICAgKiBJdCBlbnN1cmVzIHRoZSByZXN1bHQgaXMgd2l0aGluIHRoZSBmaWVsZCBpZiBhbmQgb25seSBpZiB0aGUgaW5wdXQgdmFsdWVzIGFyZSB3aXRoaW4gdGhlIGZpZWxkLlxuICAgICAqIEBwYXJhbSBhIFRoZSB2YWx1ZSB0byBuZWdhdGUuXG4gICAgICogQHJldHVybnMgVGhlIG5lZ2F0aW9uIG9mICdhJyBtb2R1bG8gdGhlIGZpZWxkJ3Mgb3JkZXIuXG4gICAgICovXG4gICAgbmVnKGEpIHtcbiAgICAgICAgcmV0dXJuIGEgPyB0aGlzLl9vcmRlciAtIGEgOiBhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBiaWdpbnQgdmFsdWUgaXMgemVybyB3aXRoaW4gdGhlIGNvbnRleHQgb2YgdGhlIGZpZWxkLlxuICAgICAqIEBwYXJhbSBhIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmICdhJyBpcyB6ZXJvLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNaZXJvKGEpIHtcbiAgICAgICAgcmV0dXJuIGEgPT09IHRoaXMuemVybztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmFpc2VzIGEgYmFzZSB0byBhbiBleHBvbmVudCB3aXRoaW4gdGhlIGZpZWxkLCBlZmZpY2llbnRseSBjb21wdXRpbmdcbiAgICAgKiBzY2FsYXIgZXhwb25lbnRpYXRpb24gdXNpbmcgdGhlIHNxdWFyZS1hbmQtbXVsdGlwbHkgYWxnb3JpdGhtLlxuICAgICAqIFN1cHBvcnRzIGJvdGggcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIGV4cG9uZW50cyB0aHJvdWdoIHRoZSB1c2Ugb2YgdGhlIGBpbnZgIG1ldGhvZCBmb3IgbmVnYXRpdmVzLlxuICAgICAqIEBwYXJhbSBiYXNlIFRoZSBiYXNlIHRvIGJlIGV4cG9uZW50aWF0ZWQuXG4gICAgICogQHBhcmFtIGUgVGhlIGV4cG9uZW50LlxuICAgICAqIEByZXR1cm5zIFRoZSByZXN1bHQgb2YgcmFpc2luZyAnYmFzZScgdG8gdGhlIHBvd2VyICdlJyBtb2R1bG8gdGhlIGZpZWxkJ3Mgb3JkZXIuXG4gICAgICovXG4gICAgcG93KGJhc2UsIGUpIHtcbiAgICAgICAgaWYgKGlzWmVybyhlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub25lO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlIDwgMG4pIHtcbiAgICAgICAgICAgIGJhc2UgPSB0aGlzLmludihiYXNlKTtcbiAgICAgICAgICAgIGUgPSAtZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuID0gYml0cyhlKTtcbiAgICAgICAgaWYgKG4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbmU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlcyA9IGJhc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSBuLmxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgICByZXMgPSB0aGlzLnNxdWFyZShyZXMpO1xuICAgICAgICAgICAgaWYgKG5baV0pIHtcbiAgICAgICAgICAgICAgICByZXMgPSB0aGlzLm11bChyZXMsIGJhc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuXG4vKipcbiAqIEBtb2R1bGUgUHJvb2ZQYWNraW5nXG4gKlxuICogVGhpcyBtb2R1bGUgcHJvdmlkZXMgdXRpbGl0eSBmdW5jdGlvbnMgdG8gcGFjayBhbmQgdW5wYWNrXG4gKiB2YXJpb3VzIHR5cGVzIG9mIG9iamVjdHMsIG1ha2luZyBpdCBlYXNpZXIgdG8gZXhwb3J0IG9yIHVzZVxuICogdGhlbSBleHRlcm5hbGx5LlxuICovXG4vKipcbiAqIFBhY2tzIGEgU25hcmtqcyBHcm90aDE2IHByb29mIGludG8gYSBzaW5nbGUgbGlzdCB1c2FibGUgYXMgY2FsbGRhdGEgaW4gU29saWRpdHkgKHB1YmxpYyBzaWduYWxzIGFyZSBub3QgaW5jbHVkZWQpLlxuICogQHBhcmFtIHByb29mIFRoZSBHcm90aDE2IHByb29mIGdlbmVyYXRlZCB3aXRoIFNuYXJrSlMuXG4gKiBAcmV0dXJucyBTb2xpZGl0eSBjYWxsZGF0YS5cbiAqL1xuZnVuY3Rpb24gcGFja0dyb3RoMTZQcm9vZihwcm9vZikge1xuICAgIHJldHVybiBbXG4gICAgICAgIHByb29mLnBpX2FbMF0sXG4gICAgICAgIHByb29mLnBpX2FbMV0sXG4gICAgICAgIHByb29mLnBpX2JbMF1bMV0sXG4gICAgICAgIHByb29mLnBpX2JbMF1bMF0sXG4gICAgICAgIHByb29mLnBpX2JbMV1bMV0sXG4gICAgICAgIHByb29mLnBpX2JbMV1bMF0sXG4gICAgICAgIHByb29mLnBpX2NbMF0sXG4gICAgICAgIHByb29mLnBpX2NbMV1cbiAgICBdO1xufVxuLyoqXG4gKiBVbnBhY2tzIGEgUGFja2VkR3JvdGgxNlByb29mIFNvbGlkaXR5IGNhbGxkYXRhIGludG8gaXRzIG9yaWdpbmFsIGZvcm0gd2hpY2ggaXMgYSBTbmFya0pTIEdyb3RoMTYgcHJvb2YuXG4gKiBAcGFyYW0gcHJvb2YgU29saWRpdHkgY2FsbGRhdGEuXG4gKiBAcmV0dXJucyBUaGUgR3JvdGgxNiBwcm9vZiBjb21wYXRpYmxlIHdpdGggU25hcmtKUy5cbiAqL1xuZnVuY3Rpb24gdW5wYWNrR3JvdGgxNlByb29mKHByb29mKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGlfYTogW3Byb29mWzBdLCBwcm9vZlsxXV0sXG4gICAgICAgIHBpX2I6IFtcbiAgICAgICAgICAgIFtwcm9vZlszXSwgcHJvb2ZbMl1dLFxuICAgICAgICAgICAgW3Byb29mWzVdLCBwcm9vZls0XV1cbiAgICAgICAgXSxcbiAgICAgICAgcGlfYzogW3Byb29mWzZdLCBwcm9vZls3XV0sXG4gICAgICAgIHByb3RvY29sOiBcImdyb3RoMTZcIixcbiAgICAgICAgY3VydmU6IFwiYm4xMjhcIlxuICAgIH07XG59XG5cbnZhciBwcm9vZlBhY2tpbmcgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIHBhY2tHcm90aDE2UHJvb2Y6IHBhY2tHcm90aDE2UHJvb2YsXG4gICAgdW5wYWNrR3JvdGgxNlByb29mOiB1bnBhY2tHcm90aDE2UHJvb2Zcbn0pO1xuXG5leHBvcnQgeyBGMUZpZWxkLCBiYXNlNjRUb0J1ZmZlciwgYmFzZTY0VG9UZXh0LCBiZUJpZ0ludFRvQnVmZmVyLCBiZUJ1ZmZlclRvQmlnSW50LCBiaWdJbnRUb0J1ZmZlciwgYmlnSW50VG9IZXhhZGVjaW1hbCwgYmlnTnVtYmVyaXNoVG9CaWdJbnQsIGJpZ051bWJlcmlzaFRvQnVmZmVyLCBidWZmZXJUb0Jhc2U2NCwgYnVmZmVyVG9CaWdJbnQsIGJ1ZmZlclRvSGV4YWRlY2ltYWwsIGNvbnZlcnNpb25zLCBjcnlwdG9fbm9kZSBhcyBjcnlwdG8sIGVycm9ySGFuZGxlcnMsIGhleGFkZWNpbWFsVG9CaWdJbnQsIGhleGFkZWNpbWFsVG9CdWZmZXIsIGlzQXJyYXksIGlzQmlnSW50LCBpc0JpZ051bWJlciwgaXNCaWdOdW1iZXJpc2gsIGlzQnVmZmVyLCBpc0RlZmluZWQsIGlzRnVuY3Rpb24sIGlzSGV4YWRlY2ltYWwsIGlzTnVtYmVyLCBpc09iamVjdCwgaXNTdHJpbmcsIGlzU3RyaW5naWZpZWRCaWdJbnQsIGlzU3VwcG9ydGVkVHlwZSwgaXNUeXBlLCBpc1VpbnQ4QXJyYXksIGxlQmlnSW50VG9CdWZmZXIsIGxlQnVmZmVyVG9CaWdJbnQsIHBhY2tHcm90aDE2UHJvb2YsIHByb29mUGFja2luZyBhcyBwYWNraW5nLCByZXF1aXJlQXJyYXksIHJlcXVpcmVCaWdJbnQsIHJlcXVpcmVCaWdOdW1iZXIsIHJlcXVpcmVCaWdOdW1iZXJpc2gsIHJlcXVpcmVCdWZmZXIsIHJlcXVpcmVEZWZpbmVkLCByZXF1aXJlRnVuY3Rpb24sIHJlcXVpcmVIZXhhZGVjaW1hbCwgcmVxdWlyZU51bWJlciwgcmVxdWlyZU9iamVjdCwgcmVxdWlyZVN0cmluZywgcmVxdWlyZVN0cmluZ2lmaWVkQmlnSW50LCByZXF1aXJlVHlwZXMsIHJlcXVpcmVVaW50OEFycmF5LCBzY2FsYXIsIHN1cHBvcnRlZFR5cGVzLCB0ZXh0VG9CYXNlNjQsIHR5cGVDaGVja3MsIHVucGFja0dyb3RoMTZQcm9vZiB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@zk-kit/eddsa-poseidon/node_modules/@zk-kit/utils/dist/index.node.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@zk-kit/eddsa-poseidon/node_modules/@zk-kit/utils/dist/lib.esm/conversions.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@zk-kit/eddsa-poseidon/node_modules/@zk-kit/utils/dist/lib.esm/conversions.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base64ToBuffer: () => (/* binding */ base64ToBuffer),\n/* harmony export */   base64ToText: () => (/* binding */ base64ToText),\n/* harmony export */   beBigIntToBuffer: () => (/* binding */ beBigIntToBuffer),\n/* harmony export */   beBufferToBigInt: () => (/* binding */ beBufferToBigInt),\n/* harmony export */   bigIntToBuffer: () => (/* binding */ bigIntToBuffer),\n/* harmony export */   bigIntToHexadecimal: () => (/* binding */ bigIntToHexadecimal),\n/* harmony export */   bigNumberishToBigInt: () => (/* binding */ bigNumberishToBigInt),\n/* harmony export */   bigNumberishToBuffer: () => (/* binding */ bigNumberishToBuffer),\n/* harmony export */   bufferToBase64: () => (/* binding */ bufferToBase64),\n/* harmony export */   bufferToBigInt: () => (/* binding */ bufferToBigInt),\n/* harmony export */   bufferToHexadecimal: () => (/* binding */ bufferToHexadecimal),\n/* harmony export */   hexadecimalToBigInt: () => (/* binding */ hexadecimalToBigInt),\n/* harmony export */   hexadecimalToBuffer: () => (/* binding */ hexadecimalToBuffer),\n/* harmony export */   leBigIntToBuffer: () => (/* binding */ leBigIntToBuffer),\n/* harmony export */   leBufferToBigInt: () => (/* binding */ leBufferToBigInt),\n/* harmony export */   textToBase64: () => (/* binding */ textToBase64)\n/* harmony export */ });\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var _error_handlers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./error-handlers.js */ \"(ssr)/./node_modules/@zk-kit/eddsa-poseidon/node_modules/@zk-kit/utils/dist/lib.esm/error-handlers.js\");\n/* harmony import */ var _type_checks_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./type-checks.js */ \"(ssr)/./node_modules/@zk-kit/eddsa-poseidon/node_modules/@zk-kit/utils/dist/lib.esm/type-checks.js\");\n/**\n * @module @zk-kit/utils\n * @version 1.2.1\n * @file Essential zero-knowledge utility library for JavaScript developers.\n * @copyright Ethereum Foundation 2024\n * @license MIT\n * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/utils}\n*/\n\n\n\n\n/**\n * @module Conversions\n * This module provides a collection of utility functions for converting\n * between different numerical formats, particularly focusing on\n * conversions involving bigints, hexadecimals and buffers.\n * The module is structured with clear function naming to indicate\n * the conversion direction (e.g., `bigIntToHexadecimal` for BigInt\n * to hexadecimal, `bufferToBigInt` for buffer to bigint) and employs\n * type checks to ensure the correct handling of various input types.\n * It also includes variations for both big-endian (`be`) and little-endian\n * (`le`) conversions. It is important to note that when there is no prefix,\n * the order of bytes is always big-endian.\n */\n/**\n * Converts a bigint to a hexadecimal string.\n * @param value The bigint value to convert.\n * @returns The hexadecimal representation of the bigint.\n */\nfunction bigIntToHexadecimal(value) {\n    (0,_error_handlers_js__WEBPACK_IMPORTED_MODULE_1__.requireBigInt)(value, \"value\");\n    let hex = value.toString(16);\n    // Ensure even length.\n    if (hex.length % 2 !== 0) {\n        hex = `0${hex}`;\n    }\n    return hex;\n}\n/**\n * Converts a hexadecimal string to a bigint. The input is interpreted as hexadecimal\n * with or without a '0x' prefix. It uses big-endian byte order.\n * @param value The hexadecimal string to convert.\n * @returns The bigint representation of the hexadecimal string.\n */\nfunction hexadecimalToBigInt(value) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_2__.isHexadecimal)(value) && !(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_2__.isHexadecimal)(value, false)) {\n        throw new TypeError(`Parameter 'value' is not a hexadecimal string`);\n    }\n    // Ensure the hex string starts with '0x'.\n    const formattedHexString = value.startsWith(\"0x\") ? value : `0x${value}`;\n    return BigInt(formattedHexString);\n}\n/**\n * Converts a buffer of bytes to a bigint using big-endian byte order.\n * It accepts 'Buffer' or 'Uint8Array'.\n * @param value The buffer to convert.\n * @returns The bigint representation of the buffer's contents.\n */\nfunction beBufferToBigInt(value) {\n    (0,_error_handlers_js__WEBPACK_IMPORTED_MODULE_1__.requireTypes)(value, \"value\", [\"Buffer\", \"Uint8Array\"]);\n    return BigInt(`0x${buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value).toString(\"hex\")}`);\n}\n/**\n * Converts a buffer to a bigint using little-endian byte order.\n * It accepts 'Buffer' or 'Uint8Array'.\n * @param value The buffer to convert.\n * @returns The bigint representation of the buffer's contents in little-endian.\n */\nfunction leBufferToBigInt(value) {\n    (0,_error_handlers_js__WEBPACK_IMPORTED_MODULE_1__.requireTypes)(value, \"value\", [\"Buffer\", \"Uint8Array\"]);\n    return BigInt(`0x${buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value).reverse().toString(\"hex\")}`);\n}\n/**\n * Converts a buffer to a bigint. Alias for beBufferToBigInt.\n * @param value The buffer to convert.\n * @returns The bigint representation of the buffer's contents.\n */\nfunction bufferToBigInt(value) {\n    return beBufferToBigInt(value);\n}\n/**\n * Converts a bigint to a buffer and fills with zeros if a valid\n * size (i.e. number of bytes) is specified. If the size is not defined,\n * it gets the size from the given bigint. If the specified size is smaller than\n * the size of the bigint (i.e. `minSize`), an error is thrown.\n * It uses big-endian byte order.\n * @param value The bigint to convert.\n * @param size The number of bytes of the buffer to return.\n * @returns The buffer representation of the bigint.\n */\nfunction beBigIntToBuffer(value, size) {\n    const hex = bigIntToHexadecimal(value);\n    // Calculate the minimum buffer size required to represent 'n' in bytes.\n    // Each hexadecimal character represents 4 bits, so 2 characters are 1 byte.\n    const minSize = Math.ceil(hex.length / 2);\n    if (!size) {\n        size = minSize;\n    }\n    else if (size < minSize) {\n        throw Error(`Size ${size} is too small, need at least ${minSize} bytes`);\n    }\n    // Allocate buffer of the desired size, filled with zeros.\n    const buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(size, 0);\n    const fromHex = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(hex, \"hex\");\n    fromHex.copy(buffer, size - fromHex.length);\n    return buffer;\n}\n/**\n * Converts a bigint to a buffer and fills with zeros if a valid\n * size (i.e. number of bytes) is specified. If the size is not defined,\n * it gets the size from the given bigint. If the specified size is smaller than\n * the size of the bigint (i.e. `minSize`), an error is thrown.\n * It uses little-endian byte order.\n * @param value The bigint to convert.\n * @param size The number of bytes of the buffer to return.\n * @returns The buffer representation of the bigint in little-endian.\n */\nfunction leBigIntToBuffer(value, size) {\n    const hex = bigIntToHexadecimal(value);\n    // Calculate the minimum buffer size required to represent 'n' in bytes.\n    // Each hexadecimal character represents 4 bits, so 2 characters are 1 byte.\n    const minSize = Math.ceil(hex.length / 2);\n    if (!size) {\n        size = minSize;\n    }\n    else if (size < minSize) {\n        throw Error(`Size ${size} is too small, need at least ${minSize} bytes`);\n    }\n    // Allocate buffer of the desired size, filled with zeros.\n    const buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(size, 0);\n    const fromHex = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(hex, \"hex\").reverse();\n    fromHex.copy(buffer, 0);\n    return buffer;\n}\n/**\n * Converts a bigint to a buffer. Alias for beBigIntToBuffer.\n * @param value The bigint to convert.\n * @returns The buffer representation of the bigint.\n */\nfunction bigIntToBuffer(value) {\n    return beBigIntToBuffer(value);\n}\n/**\n * Converts a BigNumberish type to a bigint. If the input is already a bigint,\n * the return value will be the bigint itself, otherwise it will be converted\n * to a bigint using big-endian byte order.\n * @param value The BigNumberish value to convert.\n * @returns The bigint representation of the BigNumberish value.\n */\nfunction bigNumberishToBigInt(value) {\n    (0,_error_handlers_js__WEBPACK_IMPORTED_MODULE_1__.requireBigNumberish)(value, \"value\");\n    if ((0,_type_checks_js__WEBPACK_IMPORTED_MODULE_2__.isBuffer)(value) || (0,_type_checks_js__WEBPACK_IMPORTED_MODULE_2__.isUint8Array)(value)) {\n        return bufferToBigInt(value);\n    }\n    return BigInt(value);\n}\n/**\n * Converts a BigNumberish type to a buffer. If the input is already a buffer,\n * the return value will be the buffer itself, otherwise it will be converted\n * to a buffer using big-endian byte order.\n * @param value The BigNumberish value to convert.\n * @returns The buffer representation of the BigNumberish value.\n */\nfunction bigNumberishToBuffer(value) {\n    (0,_error_handlers_js__WEBPACK_IMPORTED_MODULE_1__.requireBigNumberish)(value, \"value\");\n    if ((0,_type_checks_js__WEBPACK_IMPORTED_MODULE_2__.isBuffer)(value) || (0,_type_checks_js__WEBPACK_IMPORTED_MODULE_2__.isUint8Array)(value)) {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value);\n    }\n    return bigIntToBuffer(bigNumberishToBigInt(value));\n}\n/**\n * Converts an hexadecimal string to a buffer. The hexadecimal string\n * should not start with '0x' or '0X'. It keeps the bytes in the same order.\n * @param value The hexadecimal string to convert.\n * @returns The buffer representation of the hexadecimal string.\n */\nfunction hexadecimalToBuffer(value) {\n    (0,_error_handlers_js__WEBPACK_IMPORTED_MODULE_1__.requireHexadecimal)(value, \"value\", false);\n    // Ensure even length before converting to buffer.\n    if (value.length % 2 !== 0) {\n        value = `0${value}`;\n    }\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value, \"hex\");\n}\n/**\n * Converts a buffer to a hexadecimal string. It accepts 'Buffer' or 'Uint8Array'.\n * The hexadecimal string will not start with '0x' or '0X'. It keeps the bytes in the same order.\n * @param value The buffer to convert.\n * @returns The converted hexadecimal string.\n */\nfunction bufferToHexadecimal(value) {\n    (0,_error_handlers_js__WEBPACK_IMPORTED_MODULE_1__.requireTypes)(value, \"value\", [\"Buffer\", \"Uint8Array\"]);\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value).toString(\"hex\");\n}\n/**\n * Converts bytes to a base64 string. It accepts 'Buffer' or 'Uint8Array'.\n * @param value The bytes to convert.\n * @returns The converted base64 string.\n */\nfunction bufferToBase64(value) {\n    (0,_error_handlers_js__WEBPACK_IMPORTED_MODULE_1__.requireTypes)(value, \"value\", [\"Buffer\", \"Uint8Array\"]);\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value).toString(\"base64\");\n}\n/**\n * Converts a base64 string to bytes (i.e. a buffer). This function does not check\n * if the input value is a valid base64 string. If there are unsupported characters\n * they will be ignored.\n * @param value The base64 string to convert.\n * @returns The converted buffer.\n */\nfunction base64ToBuffer(value) {\n    (0,_error_handlers_js__WEBPACK_IMPORTED_MODULE_1__.requireString)(value, \"value\");\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value, \"base64\");\n}\n/**\n * Converts text (utf8) to a base64 string.\n * @param value The text to convert.\n * @returns The converted base64 string.\n */\nfunction textToBase64(value) {\n    (0,_error_handlers_js__WEBPACK_IMPORTED_MODULE_1__.requireString)(value, \"value\");\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value, \"utf8\").toString(\"base64\");\n}\n/**\n * Converts a base64 string to text (utf8). This function does not check\n * if the input value is a valid base64 string. If there are unsupported characters\n * they could be ignored and the result may be unexpected.\n * @param value The base64 string to convert.\n * @returns The converted text.\n */\nfunction base64ToText(value) {\n    (0,_error_handlers_js__WEBPACK_IMPORTED_MODULE_1__.requireString)(value, \"value\");\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value, \"base64\").toString(\"utf8\");\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHprLWtpdC9lZGRzYS1wb3NlaWRvbi9ub2RlX21vZHVsZXMvQHprLWtpdC91dGlscy9kaXN0L2xpYi5lc20vY29udmVyc2lvbnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNnQztBQUMwRjtBQUNqRDs7QUFFekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlFQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixJQUFJO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4REFBYSxZQUFZLDhEQUFhO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxNQUFNO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0VBQVk7QUFDaEIsdUJBQXVCLDBDQUFNLDZCQUE2QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnRUFBWTtBQUNoQix1QkFBdUIsMENBQU0sdUNBQXVDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU0sOEJBQThCLFNBQVM7QUFDekU7QUFDQTtBQUNBLG1CQUFtQiwwQ0FBTTtBQUN6QixvQkFBb0IsMENBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTSw4QkFBOEIsU0FBUztBQUN6RTtBQUNBO0FBQ0EsbUJBQW1CLDBDQUFNO0FBQ3pCLG9CQUFvQiwwQ0FBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksdUVBQW1CO0FBQ3ZCLFFBQVEseURBQVEsV0FBVyw2REFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVFQUFtQjtBQUN2QixRQUFRLHlEQUFRLFdBQVcsNkRBQVk7QUFDdkMsZUFBZSwwQ0FBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksc0VBQWtCO0FBQ3RCO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBLFdBQVcsMENBQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0VBQVk7QUFDaEIsV0FBVywwQ0FBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0VBQVk7QUFDaEIsV0FBVywwQ0FBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlFQUFhO0FBQ2pCLFdBQVcsMENBQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlFQUFhO0FBQ2pCLFdBQVcsMENBQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpRUFBYTtBQUNqQixXQUFXLDBDQUFNO0FBQ2pCOztBQUU4UyIsInNvdXJjZXMiOlsiL1VzZXJzL2NoYW5jZW1jYWxsaXN0ZXIvUHJvamVjdHMvenVwYXNzaHVudC9ub2RlX21vZHVsZXMvQHprLWtpdC9lZGRzYS1wb3NlaWRvbi9ub2RlX21vZHVsZXMvQHprLWtpdC91dGlscy9kaXN0L2xpYi5lc20vY29udmVyc2lvbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIEB6ay1raXQvdXRpbHNcbiAqIEB2ZXJzaW9uIDEuMi4xXG4gKiBAZmlsZSBFc3NlbnRpYWwgemVyby1rbm93bGVkZ2UgdXRpbGl0eSBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0IGRldmVsb3BlcnMuXG4gKiBAY29weXJpZ2h0IEV0aGVyZXVtIEZvdW5kYXRpb24gMjAyNFxuICogQGxpY2Vuc2UgTUlUXG4gKiBAc2VlIFtHaXRodWJde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9wcml2YWN5LXNjYWxpbmctZXhwbG9yYXRpb25zL3prLWtpdC90cmVlL21haW4vcGFja2FnZXMvdXRpbHN9XG4qL1xuaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnYnVmZmVyJztcbmltcG9ydCB7IHJlcXVpcmVCaWdJbnQsIHJlcXVpcmVUeXBlcywgcmVxdWlyZUJpZ051bWJlcmlzaCwgcmVxdWlyZUhleGFkZWNpbWFsLCByZXF1aXJlU3RyaW5nIH0gZnJvbSAnLi9lcnJvci1oYW5kbGVycy5qcyc7XG5pbXBvcnQgeyBpc0hleGFkZWNpbWFsLCBpc0J1ZmZlciwgaXNVaW50OEFycmF5IH0gZnJvbSAnLi90eXBlLWNoZWNrcy5qcyc7XG5cbi8qKlxuICogQG1vZHVsZSBDb252ZXJzaW9uc1xuICogVGhpcyBtb2R1bGUgcHJvdmlkZXMgYSBjb2xsZWN0aW9uIG9mIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBjb252ZXJ0aW5nXG4gKiBiZXR3ZWVuIGRpZmZlcmVudCBudW1lcmljYWwgZm9ybWF0cywgcGFydGljdWxhcmx5IGZvY3VzaW5nIG9uXG4gKiBjb252ZXJzaW9ucyBpbnZvbHZpbmcgYmlnaW50cywgaGV4YWRlY2ltYWxzIGFuZCBidWZmZXJzLlxuICogVGhlIG1vZHVsZSBpcyBzdHJ1Y3R1cmVkIHdpdGggY2xlYXIgZnVuY3Rpb24gbmFtaW5nIHRvIGluZGljYXRlXG4gKiB0aGUgY29udmVyc2lvbiBkaXJlY3Rpb24gKGUuZy4sIGBiaWdJbnRUb0hleGFkZWNpbWFsYCBmb3IgQmlnSW50XG4gKiB0byBoZXhhZGVjaW1hbCwgYGJ1ZmZlclRvQmlnSW50YCBmb3IgYnVmZmVyIHRvIGJpZ2ludCkgYW5kIGVtcGxveXNcbiAqIHR5cGUgY2hlY2tzIHRvIGVuc3VyZSB0aGUgY29ycmVjdCBoYW5kbGluZyBvZiB2YXJpb3VzIGlucHV0IHR5cGVzLlxuICogSXQgYWxzbyBpbmNsdWRlcyB2YXJpYXRpb25zIGZvciBib3RoIGJpZy1lbmRpYW4gKGBiZWApIGFuZCBsaXR0bGUtZW5kaWFuXG4gKiAoYGxlYCkgY29udmVyc2lvbnMuIEl0IGlzIGltcG9ydGFudCB0byBub3RlIHRoYXQgd2hlbiB0aGVyZSBpcyBubyBwcmVmaXgsXG4gKiB0aGUgb3JkZXIgb2YgYnl0ZXMgaXMgYWx3YXlzIGJpZy1lbmRpYW4uXG4gKi9cbi8qKlxuICogQ29udmVydHMgYSBiaWdpbnQgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIGJpZ2ludCB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGhleGFkZWNpbWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBiaWdpbnQuXG4gKi9cbmZ1bmN0aW9uIGJpZ0ludFRvSGV4YWRlY2ltYWwodmFsdWUpIHtcbiAgICByZXF1aXJlQmlnSW50KHZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGxldCBoZXggPSB2YWx1ZS50b1N0cmluZygxNik7XG4gICAgLy8gRW5zdXJlIGV2ZW4gbGVuZ3RoLlxuICAgIGlmIChoZXgubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICBoZXggPSBgMCR7aGV4fWA7XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGEgYmlnaW50LiBUaGUgaW5wdXQgaXMgaW50ZXJwcmV0ZWQgYXMgaGV4YWRlY2ltYWxcbiAqIHdpdGggb3Igd2l0aG91dCBhICcweCcgcHJlZml4LiBJdCB1c2VzIGJpZy1lbmRpYW4gYnl0ZSBvcmRlci5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgYmlnaW50IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGhleGFkZWNpbWFsVG9CaWdJbnQodmFsdWUpIHtcbiAgICBpZiAoIWlzSGV4YWRlY2ltYWwodmFsdWUpICYmICFpc0hleGFkZWNpbWFsKHZhbHVlLCBmYWxzZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGFyYW1ldGVyICd2YWx1ZScgaXMgbm90IGEgaGV4YWRlY2ltYWwgc3RyaW5nYCk7XG4gICAgfVxuICAgIC8vIEVuc3VyZSB0aGUgaGV4IHN0cmluZyBzdGFydHMgd2l0aCAnMHgnLlxuICAgIGNvbnN0IGZvcm1hdHRlZEhleFN0cmluZyA9IHZhbHVlLnN0YXJ0c1dpdGgoXCIweFwiKSA/IHZhbHVlIDogYDB4JHt2YWx1ZX1gO1xuICAgIHJldHVybiBCaWdJbnQoZm9ybWF0dGVkSGV4U3RyaW5nKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBidWZmZXIgb2YgYnl0ZXMgdG8gYSBiaWdpbnQgdXNpbmcgYmlnLWVuZGlhbiBieXRlIG9yZGVyLlxuICogSXQgYWNjZXB0cyAnQnVmZmVyJyBvciAnVWludDhBcnJheScuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIGJ1ZmZlciB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGJpZ2ludCByZXByZXNlbnRhdGlvbiBvZiB0aGUgYnVmZmVyJ3MgY29udGVudHMuXG4gKi9cbmZ1bmN0aW9uIGJlQnVmZmVyVG9CaWdJbnQodmFsdWUpIHtcbiAgICByZXF1aXJlVHlwZXModmFsdWUsIFwidmFsdWVcIiwgW1wiQnVmZmVyXCIsIFwiVWludDhBcnJheVwiXSk7XG4gICAgcmV0dXJuIEJpZ0ludChgMHgke0J1ZmZlci5mcm9tKHZhbHVlKS50b1N0cmluZyhcImhleFwiKX1gKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBidWZmZXIgdG8gYSBiaWdpbnQgdXNpbmcgbGl0dGxlLWVuZGlhbiBieXRlIG9yZGVyLlxuICogSXQgYWNjZXB0cyAnQnVmZmVyJyBvciAnVWludDhBcnJheScuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIGJ1ZmZlciB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGJpZ2ludCByZXByZXNlbnRhdGlvbiBvZiB0aGUgYnVmZmVyJ3MgY29udGVudHMgaW4gbGl0dGxlLWVuZGlhbi5cbiAqL1xuZnVuY3Rpb24gbGVCdWZmZXJUb0JpZ0ludCh2YWx1ZSkge1xuICAgIHJlcXVpcmVUeXBlcyh2YWx1ZSwgXCJ2YWx1ZVwiLCBbXCJCdWZmZXJcIiwgXCJVaW50OEFycmF5XCJdKTtcbiAgICByZXR1cm4gQmlnSW50KGAweCR7QnVmZmVyLmZyb20odmFsdWUpLnJldmVyc2UoKS50b1N0cmluZyhcImhleFwiKX1gKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBidWZmZXIgdG8gYSBiaWdpbnQuIEFsaWFzIGZvciBiZUJ1ZmZlclRvQmlnSW50LlxuICogQHBhcmFtIHZhbHVlIFRoZSBidWZmZXIgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBiaWdpbnQgcmVwcmVzZW50YXRpb24gb2YgdGhlIGJ1ZmZlcidzIGNvbnRlbnRzLlxuICovXG5mdW5jdGlvbiBidWZmZXJUb0JpZ0ludCh2YWx1ZSkge1xuICAgIHJldHVybiBiZUJ1ZmZlclRvQmlnSW50KHZhbHVlKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBiaWdpbnQgdG8gYSBidWZmZXIgYW5kIGZpbGxzIHdpdGggemVyb3MgaWYgYSB2YWxpZFxuICogc2l6ZSAoaS5lLiBudW1iZXIgb2YgYnl0ZXMpIGlzIHNwZWNpZmllZC4gSWYgdGhlIHNpemUgaXMgbm90IGRlZmluZWQsXG4gKiBpdCBnZXRzIHRoZSBzaXplIGZyb20gdGhlIGdpdmVuIGJpZ2ludC4gSWYgdGhlIHNwZWNpZmllZCBzaXplIGlzIHNtYWxsZXIgdGhhblxuICogdGhlIHNpemUgb2YgdGhlIGJpZ2ludCAoaS5lLiBgbWluU2l6ZWApLCBhbiBlcnJvciBpcyB0aHJvd24uXG4gKiBJdCB1c2VzIGJpZy1lbmRpYW4gYnl0ZSBvcmRlci5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgYmlnaW50IHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gc2l6ZSBUaGUgbnVtYmVyIG9mIGJ5dGVzIG9mIHRoZSBidWZmZXIgdG8gcmV0dXJuLlxuICogQHJldHVybnMgVGhlIGJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiB0aGUgYmlnaW50LlxuICovXG5mdW5jdGlvbiBiZUJpZ0ludFRvQnVmZmVyKHZhbHVlLCBzaXplKSB7XG4gICAgY29uc3QgaGV4ID0gYmlnSW50VG9IZXhhZGVjaW1hbCh2YWx1ZSk7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBtaW5pbXVtIGJ1ZmZlciBzaXplIHJlcXVpcmVkIHRvIHJlcHJlc2VudCAnbicgaW4gYnl0ZXMuXG4gICAgLy8gRWFjaCBoZXhhZGVjaW1hbCBjaGFyYWN0ZXIgcmVwcmVzZW50cyA0IGJpdHMsIHNvIDIgY2hhcmFjdGVycyBhcmUgMSBieXRlLlxuICAgIGNvbnN0IG1pblNpemUgPSBNYXRoLmNlaWwoaGV4Lmxlbmd0aCAvIDIpO1xuICAgIGlmICghc2l6ZSkge1xuICAgICAgICBzaXplID0gbWluU2l6ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2l6ZSA8IG1pblNpemUpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYFNpemUgJHtzaXplfSBpcyB0b28gc21hbGwsIG5lZWQgYXQgbGVhc3QgJHttaW5TaXplfSBieXRlc2ApO1xuICAgIH1cbiAgICAvLyBBbGxvY2F0ZSBidWZmZXIgb2YgdGhlIGRlc2lyZWQgc2l6ZSwgZmlsbGVkIHdpdGggemVyb3MuXG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jKHNpemUsIDApO1xuICAgIGNvbnN0IGZyb21IZXggPSBCdWZmZXIuZnJvbShoZXgsIFwiaGV4XCIpO1xuICAgIGZyb21IZXguY29weShidWZmZXIsIHNpemUgLSBmcm9tSGV4Lmxlbmd0aCk7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cbi8qKlxuICogQ29udmVydHMgYSBiaWdpbnQgdG8gYSBidWZmZXIgYW5kIGZpbGxzIHdpdGggemVyb3MgaWYgYSB2YWxpZFxuICogc2l6ZSAoaS5lLiBudW1iZXIgb2YgYnl0ZXMpIGlzIHNwZWNpZmllZC4gSWYgdGhlIHNpemUgaXMgbm90IGRlZmluZWQsXG4gKiBpdCBnZXRzIHRoZSBzaXplIGZyb20gdGhlIGdpdmVuIGJpZ2ludC4gSWYgdGhlIHNwZWNpZmllZCBzaXplIGlzIHNtYWxsZXIgdGhhblxuICogdGhlIHNpemUgb2YgdGhlIGJpZ2ludCAoaS5lLiBgbWluU2l6ZWApLCBhbiBlcnJvciBpcyB0aHJvd24uXG4gKiBJdCB1c2VzIGxpdHRsZS1lbmRpYW4gYnl0ZSBvcmRlci5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgYmlnaW50IHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gc2l6ZSBUaGUgbnVtYmVyIG9mIGJ5dGVzIG9mIHRoZSBidWZmZXIgdG8gcmV0dXJuLlxuICogQHJldHVybnMgVGhlIGJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiB0aGUgYmlnaW50IGluIGxpdHRsZS1lbmRpYW4uXG4gKi9cbmZ1bmN0aW9uIGxlQmlnSW50VG9CdWZmZXIodmFsdWUsIHNpemUpIHtcbiAgICBjb25zdCBoZXggPSBiaWdJbnRUb0hleGFkZWNpbWFsKHZhbHVlKTtcbiAgICAvLyBDYWxjdWxhdGUgdGhlIG1pbmltdW0gYnVmZmVyIHNpemUgcmVxdWlyZWQgdG8gcmVwcmVzZW50ICduJyBpbiBieXRlcy5cbiAgICAvLyBFYWNoIGhleGFkZWNpbWFsIGNoYXJhY3RlciByZXByZXNlbnRzIDQgYml0cywgc28gMiBjaGFyYWN0ZXJzIGFyZSAxIGJ5dGUuXG4gICAgY29uc3QgbWluU2l6ZSA9IE1hdGguY2VpbChoZXgubGVuZ3RoIC8gMik7XG4gICAgaWYgKCFzaXplKSB7XG4gICAgICAgIHNpemUgPSBtaW5TaXplO1xuICAgIH1cbiAgICBlbHNlIGlmIChzaXplIDwgbWluU2l6ZSkge1xuICAgICAgICB0aHJvdyBFcnJvcihgU2l6ZSAke3NpemV9IGlzIHRvbyBzbWFsbCwgbmVlZCBhdCBsZWFzdCAke21pblNpemV9IGJ5dGVzYCk7XG4gICAgfVxuICAgIC8vIEFsbG9jYXRlIGJ1ZmZlciBvZiB0aGUgZGVzaXJlZCBzaXplLCBmaWxsZWQgd2l0aCB6ZXJvcy5cbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2Moc2l6ZSwgMCk7XG4gICAgY29uc3QgZnJvbUhleCA9IEJ1ZmZlci5mcm9tKGhleCwgXCJoZXhcIikucmV2ZXJzZSgpO1xuICAgIGZyb21IZXguY29weShidWZmZXIsIDApO1xuICAgIHJldHVybiBidWZmZXI7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgYmlnaW50IHRvIGEgYnVmZmVyLiBBbGlhcyBmb3IgYmVCaWdJbnRUb0J1ZmZlci5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgYmlnaW50IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgYnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBiaWdpbnQuXG4gKi9cbmZ1bmN0aW9uIGJpZ0ludFRvQnVmZmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIGJlQmlnSW50VG9CdWZmZXIodmFsdWUpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIEJpZ051bWJlcmlzaCB0eXBlIHRvIGEgYmlnaW50LiBJZiB0aGUgaW5wdXQgaXMgYWxyZWFkeSBhIGJpZ2ludCxcbiAqIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSB0aGUgYmlnaW50IGl0c2VsZiwgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgY29udmVydGVkXG4gKiB0byBhIGJpZ2ludCB1c2luZyBiaWctZW5kaWFuIGJ5dGUgb3JkZXIuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIEJpZ051bWJlcmlzaCB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGJpZ2ludCByZXByZXNlbnRhdGlvbiBvZiB0aGUgQmlnTnVtYmVyaXNoIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiaWdOdW1iZXJpc2hUb0JpZ0ludCh2YWx1ZSkge1xuICAgIHJlcXVpcmVCaWdOdW1iZXJpc2godmFsdWUsIFwidmFsdWVcIik7XG4gICAgaWYgKGlzQnVmZmVyKHZhbHVlKSB8fCBpc1VpbnQ4QXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBidWZmZXJUb0JpZ0ludCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBCaWdJbnQodmFsdWUpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIEJpZ051bWJlcmlzaCB0eXBlIHRvIGEgYnVmZmVyLiBJZiB0aGUgaW5wdXQgaXMgYWxyZWFkeSBhIGJ1ZmZlcixcbiAqIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSB0aGUgYnVmZmVyIGl0c2VsZiwgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgY29udmVydGVkXG4gKiB0byBhIGJ1ZmZlciB1c2luZyBiaWctZW5kaWFuIGJ5dGUgb3JkZXIuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIEJpZ051bWJlcmlzaCB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiB0aGUgQmlnTnVtYmVyaXNoIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiaWdOdW1iZXJpc2hUb0J1ZmZlcih2YWx1ZSkge1xuICAgIHJlcXVpcmVCaWdOdW1iZXJpc2godmFsdWUsIFwidmFsdWVcIik7XG4gICAgaWYgKGlzQnVmZmVyKHZhbHVlKSB8fCBpc1VpbnQ4QXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBiaWdJbnRUb0J1ZmZlcihiaWdOdW1iZXJpc2hUb0JpZ0ludCh2YWx1ZSkpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBidWZmZXIuIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmdcbiAqIHNob3VsZCBub3Qgc3RhcnQgd2l0aCAnMHgnIG9yICcwWCcuIEl0IGtlZXBzIHRoZSBieXRlcyBpbiB0aGUgc2FtZSBvcmRlci5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgYnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGhleGFkZWNpbWFsVG9CdWZmZXIodmFsdWUpIHtcbiAgICByZXF1aXJlSGV4YWRlY2ltYWwodmFsdWUsIFwidmFsdWVcIiwgZmFsc2UpO1xuICAgIC8vIEVuc3VyZSBldmVuIGxlbmd0aCBiZWZvcmUgY29udmVydGluZyB0byBidWZmZXIuXG4gICAgaWYgKHZhbHVlLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgdmFsdWUgPSBgMCR7dmFsdWV9YDtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlLCBcImhleFwiKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBidWZmZXIgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuIEl0IGFjY2VwdHMgJ0J1ZmZlcicgb3IgJ1VpbnQ4QXJyYXknLlxuICogVGhlIGhleGFkZWNpbWFsIHN0cmluZyB3aWxsIG5vdCBzdGFydCB3aXRoICcweCcgb3IgJzBYJy4gSXQga2VlcHMgdGhlIGJ5dGVzIGluIHRoZSBzYW1lIG9yZGVyLlxuICogQHBhcmFtIHZhbHVlIFRoZSBidWZmZXIgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBjb252ZXJ0ZWQgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBidWZmZXJUb0hleGFkZWNpbWFsKHZhbHVlKSB7XG4gICAgcmVxdWlyZVR5cGVzKHZhbHVlLCBcInZhbHVlXCIsIFtcIkJ1ZmZlclwiLCBcIlVpbnQ4QXJyYXlcIl0pO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZSkudG9TdHJpbmcoXCJoZXhcIik7XG59XG4vKipcbiAqIENvbnZlcnRzIGJ5dGVzIHRvIGEgYmFzZTY0IHN0cmluZy4gSXQgYWNjZXB0cyAnQnVmZmVyJyBvciAnVWludDhBcnJheScuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIGJ5dGVzIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgY29udmVydGVkIGJhc2U2NCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlclRvQmFzZTY0KHZhbHVlKSB7XG4gICAgcmVxdWlyZVR5cGVzKHZhbHVlLCBcInZhbHVlXCIsIFtcIkJ1ZmZlclwiLCBcIlVpbnQ4QXJyYXlcIl0pO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZSkudG9TdHJpbmcoXCJiYXNlNjRcIik7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgYmFzZTY0IHN0cmluZyB0byBieXRlcyAoaS5lLiBhIGJ1ZmZlcikuIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgY2hlY2tcbiAqIGlmIHRoZSBpbnB1dCB2YWx1ZSBpcyBhIHZhbGlkIGJhc2U2NCBzdHJpbmcuIElmIHRoZXJlIGFyZSB1bnN1cHBvcnRlZCBjaGFyYWN0ZXJzXG4gKiB0aGV5IHdpbGwgYmUgaWdub3JlZC5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgYmFzZTY0IHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGJhc2U2NFRvQnVmZmVyKHZhbHVlKSB7XG4gICAgcmVxdWlyZVN0cmluZyh2YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUsIFwiYmFzZTY0XCIpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyB0ZXh0ICh1dGY4KSB0byBhIGJhc2U2NCBzdHJpbmcuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHRleHQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBjb252ZXJ0ZWQgYmFzZTY0IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdGV4dFRvQmFzZTY0KHZhbHVlKSB7XG4gICAgcmVxdWlyZVN0cmluZyh2YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUsIFwidXRmOFwiKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBiYXNlNjQgc3RyaW5nIHRvIHRleHQgKHV0ZjgpLiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGNoZWNrXG4gKiBpZiB0aGUgaW5wdXQgdmFsdWUgaXMgYSB2YWxpZCBiYXNlNjQgc3RyaW5nLiBJZiB0aGVyZSBhcmUgdW5zdXBwb3J0ZWQgY2hhcmFjdGVyc1xuICogdGhleSBjb3VsZCBiZSBpZ25vcmVkIGFuZCB0aGUgcmVzdWx0IG1heSBiZSB1bmV4cGVjdGVkLlxuICogQHBhcmFtIHZhbHVlIFRoZSBiYXNlNjQgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgY29udmVydGVkIHRleHQuXG4gKi9cbmZ1bmN0aW9uIGJhc2U2NFRvVGV4dCh2YWx1ZSkge1xuICAgIHJlcXVpcmVTdHJpbmcodmFsdWUsIFwidmFsdWVcIik7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlLCBcImJhc2U2NFwiKS50b1N0cmluZyhcInV0ZjhcIik7XG59XG5cbmV4cG9ydCB7IGJhc2U2NFRvQnVmZmVyLCBiYXNlNjRUb1RleHQsIGJlQmlnSW50VG9CdWZmZXIsIGJlQnVmZmVyVG9CaWdJbnQsIGJpZ0ludFRvQnVmZmVyLCBiaWdJbnRUb0hleGFkZWNpbWFsLCBiaWdOdW1iZXJpc2hUb0JpZ0ludCwgYmlnTnVtYmVyaXNoVG9CdWZmZXIsIGJ1ZmZlclRvQmFzZTY0LCBidWZmZXJUb0JpZ0ludCwgYnVmZmVyVG9IZXhhZGVjaW1hbCwgaGV4YWRlY2ltYWxUb0JpZ0ludCwgaGV4YWRlY2ltYWxUb0J1ZmZlciwgbGVCaWdJbnRUb0J1ZmZlciwgbGVCdWZmZXJUb0JpZ0ludCwgdGV4dFRvQmFzZTY0IH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@zk-kit/eddsa-poseidon/node_modules/@zk-kit/utils/dist/lib.esm/conversions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@zk-kit/eddsa-poseidon/node_modules/@zk-kit/utils/dist/lib.esm/error-handlers.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@zk-kit/eddsa-poseidon/node_modules/@zk-kit/utils/dist/lib.esm/error-handlers.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   requireArray: () => (/* binding */ requireArray),\n/* harmony export */   requireBigInt: () => (/* binding */ requireBigInt),\n/* harmony export */   requireBigNumber: () => (/* binding */ requireBigNumber),\n/* harmony export */   requireBigNumberish: () => (/* binding */ requireBigNumberish),\n/* harmony export */   requireBuffer: () => (/* binding */ requireBuffer),\n/* harmony export */   requireDefined: () => (/* binding */ requireDefined),\n/* harmony export */   requireFunction: () => (/* binding */ requireFunction),\n/* harmony export */   requireHexadecimal: () => (/* binding */ requireHexadecimal),\n/* harmony export */   requireNumber: () => (/* binding */ requireNumber),\n/* harmony export */   requireObject: () => (/* binding */ requireObject),\n/* harmony export */   requireString: () => (/* binding */ requireString),\n/* harmony export */   requireStringifiedBigInt: () => (/* binding */ requireStringifiedBigInt),\n/* harmony export */   requireTypes: () => (/* binding */ requireTypes),\n/* harmony export */   requireUint8Array: () => (/* binding */ requireUint8Array)\n/* harmony export */ });\n/* harmony import */ var _type_checks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./type-checks.js */ \"(ssr)/./node_modules/@zk-kit/eddsa-poseidon/node_modules/@zk-kit/utils/dist/lib.esm/type-checks.js\");\n/**\n * @module @zk-kit/utils\n * @version 1.2.1\n * @file Essential zero-knowledge utility library for JavaScript developers.\n * @copyright Ethereum Foundation 2024\n * @license MIT\n * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/utils}\n*/\n\n\n/**\n * @module ErrorHandlers\n * This module is designed to provide utility functions for validating\n * function parameters. It includes functions that throw type errors if\n * the parameters do not meet specified criteria, such as being defined,\n * a number, a string, a function, or an array. This module helps ensure\n * that functions receive the correct types of inputs, enhancing code\n * reliability and reducing runtime errors.\n */\n/**\n * @throws Throws a type error if the parameter value has not been defined.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireDefined(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isDefined)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not defined`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a number.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireNumber(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isNumber)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a number, received type: ${typeof parameterValue}`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a string.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireString(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isString)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a string, received type: ${typeof parameterValue}`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a function.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireFunction(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a function, received type: ${typeof parameterValue}`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not an Array.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireArray(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not an Array instance`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a Uint8Array.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireUint8Array(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isUint8Array)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a Uint8Array instance`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a Buffer.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireBuffer(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isBuffer)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a Buffer instance`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not an object.\n * Please, note that arrays are also objects in JavaScript.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireObject(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not an object, received type: ${typeof parameterValue}`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a bigint.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireBigInt(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isBigInt)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a bigint, received type: ${typeof parameterValue}`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a stringified bigint.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireStringifiedBigInt(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isStringifiedBigInt)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a stringified bigint`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a hexadecimal string.\n * If 'prefix' is 'true', the string must start with '0x' or '0X' followed by one or more\n * hexadecimal digits (0-9, a-f, A-F), otherwise no prefix is expected. 'prefix' is optional and\n * if its value it is not explicitly defined it will be set to 'true' by default.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n * @param prefix A boolean to include or not a '0x' or '0X' prefix.\n */\nfunction requireHexadecimal(parameterValue, parameterName, prefix = true) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isHexadecimal)(parameterValue, prefix)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a hexadecimal string`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a bignumber.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireBigNumber(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isBigNumber)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a bignumber`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a bignumber-ish.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireBigNumberish(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isBigNumberish)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a bignumber-ish`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value type is not part of the list of types.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireTypes(parameterValue, parameterName, types) {\n    for (const type of types) {\n        if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isSupportedType)(type)) {\n            throw new Error(`Type '${type}' is not supported`);\n        }\n    }\n    for (const type of types) {\n        if ((0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isType)(parameterValue, type)) {\n            return;\n        }\n    }\n    throw new TypeError(`Parameter '${parameterName}' is none of the following types: ${types.join(\", \")}`);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHprLWtpdC9lZGRzYS1wb3NlaWRvbi9ub2RlX21vZHVsZXMvQHprLWtpdC91dGlscy9kaXN0L2xpYi5lc20vZXJyb3ItaGFuZGxlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQzROOztBQUU1TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDBEQUFTO0FBQ2xCLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHlEQUFRO0FBQ2pCLDBDQUEwQyxjQUFjLG9DQUFvQyxzQkFBc0I7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMseURBQVE7QUFDakIsMENBQTBDLGNBQWMsb0NBQW9DLHNCQUFzQjtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywyREFBVTtBQUNuQiwwQ0FBMEMsY0FBYyxzQ0FBc0Msc0JBQXNCO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHdEQUFPO0FBQ2hCLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZEQUFZO0FBQ3JCLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHlEQUFRO0FBQ2pCLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMseURBQVE7QUFDakIsMENBQTBDLGNBQWMscUNBQXFDLHNCQUFzQjtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx5REFBUTtBQUNqQiwwQ0FBMEMsY0FBYyxvQ0FBb0Msc0JBQXNCO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG9FQUFtQjtBQUM1QiwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhEQUFhO0FBQ3RCLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDREQUFXO0FBQ3BCLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLCtEQUFjO0FBQ3ZCLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0VBQWU7QUFDNUIscUNBQXFDLEtBQUs7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1REFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsY0FBYyxvQ0FBb0MsaUJBQWlCO0FBQ3pHOztBQUUwUCIsInNvdXJjZXMiOlsiL1VzZXJzL2NoYW5jZW1jYWxsaXN0ZXIvUHJvamVjdHMvenVwYXNzaHVudC9ub2RlX21vZHVsZXMvQHprLWtpdC9lZGRzYS1wb3NlaWRvbi9ub2RlX21vZHVsZXMvQHprLWtpdC91dGlscy9kaXN0L2xpYi5lc20vZXJyb3ItaGFuZGxlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIEB6ay1raXQvdXRpbHNcbiAqIEB2ZXJzaW9uIDEuMi4xXG4gKiBAZmlsZSBFc3NlbnRpYWwgemVyby1rbm93bGVkZ2UgdXRpbGl0eSBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0IGRldmVsb3BlcnMuXG4gKiBAY29weXJpZ2h0IEV0aGVyZXVtIEZvdW5kYXRpb24gMjAyNFxuICogQGxpY2Vuc2UgTUlUXG4gKiBAc2VlIFtHaXRodWJde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9wcml2YWN5LXNjYWxpbmctZXhwbG9yYXRpb25zL3prLWtpdC90cmVlL21haW4vcGFja2FnZXMvdXRpbHN9XG4qL1xuaW1wb3J0IHsgaXNEZWZpbmVkLCBpc051bWJlciwgaXNTdHJpbmcsIGlzRnVuY3Rpb24sIGlzQXJyYXksIGlzVWludDhBcnJheSwgaXNCdWZmZXIsIGlzT2JqZWN0LCBpc0JpZ0ludCwgaXNTdHJpbmdpZmllZEJpZ0ludCwgaXNIZXhhZGVjaW1hbCwgaXNCaWdOdW1iZXIsIGlzQmlnTnVtYmVyaXNoLCBpc1N1cHBvcnRlZFR5cGUsIGlzVHlwZSB9IGZyb20gJy4vdHlwZS1jaGVja3MuanMnO1xuXG4vKipcbiAqIEBtb2R1bGUgRXJyb3JIYW5kbGVyc1xuICogVGhpcyBtb2R1bGUgaXMgZGVzaWduZWQgdG8gcHJvdmlkZSB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgdmFsaWRhdGluZ1xuICogZnVuY3Rpb24gcGFyYW1ldGVycy4gSXQgaW5jbHVkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3cgdHlwZSBlcnJvcnMgaWZcbiAqIHRoZSBwYXJhbWV0ZXJzIGRvIG5vdCBtZWV0IHNwZWNpZmllZCBjcml0ZXJpYSwgc3VjaCBhcyBiZWluZyBkZWZpbmVkLFxuICogYSBudW1iZXIsIGEgc3RyaW5nLCBhIGZ1bmN0aW9uLCBvciBhbiBhcnJheS4gVGhpcyBtb2R1bGUgaGVscHMgZW5zdXJlXG4gKiB0aGF0IGZ1bmN0aW9ucyByZWNlaXZlIHRoZSBjb3JyZWN0IHR5cGVzIG9mIGlucHV0cywgZW5oYW5jaW5nIGNvZGVcbiAqIHJlbGlhYmlsaXR5IGFuZCByZWR1Y2luZyBydW50aW1lIGVycm9ycy5cbiAqL1xuLyoqXG4gKiBAdGhyb3dzIFRocm93cyBhIHR5cGUgZXJyb3IgaWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBoYXMgbm90IGJlZW4gZGVmaW5lZC5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJWYWx1ZSBUaGUgcGFyYW1ldGVyIHZhbHVlLlxuICogQHBhcmFtIHBhcmFtZXRlck5hbWUgVGhlIHBhcmFtZXRlciBuYW1lLlxuICovXG5mdW5jdGlvbiByZXF1aXJlRGVmaW5lZChwYXJhbWV0ZXJWYWx1ZSwgcGFyYW1ldGVyTmFtZSkge1xuICAgIGlmICghaXNEZWZpbmVkKHBhcmFtZXRlclZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJyR7cGFyYW1ldGVyTmFtZX0nIGlzIG5vdCBkZWZpbmVkYCk7XG4gICAgfVxufVxuLyoqXG4gKiBAdGhyb3dzIFRocm93cyBhIHR5cGUgZXJyb3IgaWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBpcyBub3QgYSBudW1iZXIuXG4gKiBAcGFyYW0gcGFyYW1ldGVyVmFsdWUgVGhlIHBhcmFtZXRlciB2YWx1ZS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJOYW1lIFRoZSBwYXJhbWV0ZXIgbmFtZS5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZU51bWJlcihwYXJhbWV0ZXJWYWx1ZSwgcGFyYW1ldGVyTmFtZSkge1xuICAgIGlmICghaXNOdW1iZXIocGFyYW1ldGVyVmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAnJHtwYXJhbWV0ZXJOYW1lfScgaXMgbm90IGEgbnVtYmVyLCByZWNlaXZlZCB0eXBlOiAke3R5cGVvZiBwYXJhbWV0ZXJWYWx1ZX1gKTtcbiAgICB9XG59XG4vKipcbiAqIEB0aHJvd3MgVGhyb3dzIGEgdHlwZSBlcnJvciBpZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIG5vdCBhIHN0cmluZy5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJWYWx1ZSBUaGUgcGFyYW1ldGVyIHZhbHVlLlxuICogQHBhcmFtIHBhcmFtZXRlck5hbWUgVGhlIHBhcmFtZXRlciBuYW1lLlxuICovXG5mdW5jdGlvbiByZXF1aXJlU3RyaW5nKHBhcmFtZXRlclZhbHVlLCBwYXJhbWV0ZXJOYW1lKSB7XG4gICAgaWYgKCFpc1N0cmluZyhwYXJhbWV0ZXJWYWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGFyYW1ldGVyICcke3BhcmFtZXRlck5hbWV9JyBpcyBub3QgYSBzdHJpbmcsIHJlY2VpdmVkIHR5cGU6ICR7dHlwZW9mIHBhcmFtZXRlclZhbHVlfWApO1xuICAgIH1cbn1cbi8qKlxuICogQHRocm93cyBUaHJvd3MgYSB0eXBlIGVycm9yIGlmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgaXMgbm90IGEgZnVuY3Rpb24uXG4gKiBAcGFyYW0gcGFyYW1ldGVyVmFsdWUgVGhlIHBhcmFtZXRlciB2YWx1ZS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJOYW1lIFRoZSBwYXJhbWV0ZXIgbmFtZS5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZUZ1bmN0aW9uKHBhcmFtZXRlclZhbHVlLCBwYXJhbWV0ZXJOYW1lKSB7XG4gICAgaWYgKCFpc0Z1bmN0aW9uKHBhcmFtZXRlclZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJyR7cGFyYW1ldGVyTmFtZX0nIGlzIG5vdCBhIGZ1bmN0aW9uLCByZWNlaXZlZCB0eXBlOiAke3R5cGVvZiBwYXJhbWV0ZXJWYWx1ZX1gKTtcbiAgICB9XG59XG4vKipcbiAqIEB0aHJvd3MgVGhyb3dzIGEgdHlwZSBlcnJvciBpZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIG5vdCBhbiBBcnJheS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJWYWx1ZSBUaGUgcGFyYW1ldGVyIHZhbHVlLlxuICogQHBhcmFtIHBhcmFtZXRlck5hbWUgVGhlIHBhcmFtZXRlciBuYW1lLlxuICovXG5mdW5jdGlvbiByZXF1aXJlQXJyYXkocGFyYW1ldGVyVmFsdWUsIHBhcmFtZXRlck5hbWUpIHtcbiAgICBpZiAoIWlzQXJyYXkocGFyYW1ldGVyVmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAnJHtwYXJhbWV0ZXJOYW1lfScgaXMgbm90IGFuIEFycmF5IGluc3RhbmNlYCk7XG4gICAgfVxufVxuLyoqXG4gKiBAdGhyb3dzIFRocm93cyBhIHR5cGUgZXJyb3IgaWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBpcyBub3QgYSBVaW50OEFycmF5LlxuICogQHBhcmFtIHBhcmFtZXRlclZhbHVlIFRoZSBwYXJhbWV0ZXIgdmFsdWUuXG4gKiBAcGFyYW0gcGFyYW1ldGVyTmFtZSBUaGUgcGFyYW1ldGVyIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVVaW50OEFycmF5KHBhcmFtZXRlclZhbHVlLCBwYXJhbWV0ZXJOYW1lKSB7XG4gICAgaWYgKCFpc1VpbnQ4QXJyYXkocGFyYW1ldGVyVmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAnJHtwYXJhbWV0ZXJOYW1lfScgaXMgbm90IGEgVWludDhBcnJheSBpbnN0YW5jZWApO1xuICAgIH1cbn1cbi8qKlxuICogQHRocm93cyBUaHJvd3MgYSB0eXBlIGVycm9yIGlmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgaXMgbm90IGEgQnVmZmVyLlxuICogQHBhcmFtIHBhcmFtZXRlclZhbHVlIFRoZSBwYXJhbWV0ZXIgdmFsdWUuXG4gKiBAcGFyYW0gcGFyYW1ldGVyTmFtZSBUaGUgcGFyYW1ldGVyIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVCdWZmZXIocGFyYW1ldGVyVmFsdWUsIHBhcmFtZXRlck5hbWUpIHtcbiAgICBpZiAoIWlzQnVmZmVyKHBhcmFtZXRlclZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJyR7cGFyYW1ldGVyTmFtZX0nIGlzIG5vdCBhIEJ1ZmZlciBpbnN0YW5jZWApO1xuICAgIH1cbn1cbi8qKlxuICogQHRocm93cyBUaHJvd3MgYSB0eXBlIGVycm9yIGlmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgaXMgbm90IGFuIG9iamVjdC5cbiAqIFBsZWFzZSwgbm90ZSB0aGF0IGFycmF5cyBhcmUgYWxzbyBvYmplY3RzIGluIEphdmFTY3JpcHQuXG4gKiBAcGFyYW0gcGFyYW1ldGVyVmFsdWUgVGhlIHBhcmFtZXRlciB2YWx1ZS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJOYW1lIFRoZSBwYXJhbWV0ZXIgbmFtZS5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZU9iamVjdChwYXJhbWV0ZXJWYWx1ZSwgcGFyYW1ldGVyTmFtZSkge1xuICAgIGlmICghaXNPYmplY3QocGFyYW1ldGVyVmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAnJHtwYXJhbWV0ZXJOYW1lfScgaXMgbm90IGFuIG9iamVjdCwgcmVjZWl2ZWQgdHlwZTogJHt0eXBlb2YgcGFyYW1ldGVyVmFsdWV9YCk7XG4gICAgfVxufVxuLyoqXG4gKiBAdGhyb3dzIFRocm93cyBhIHR5cGUgZXJyb3IgaWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBpcyBub3QgYSBiaWdpbnQuXG4gKiBAcGFyYW0gcGFyYW1ldGVyVmFsdWUgVGhlIHBhcmFtZXRlciB2YWx1ZS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJOYW1lIFRoZSBwYXJhbWV0ZXIgbmFtZS5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZUJpZ0ludChwYXJhbWV0ZXJWYWx1ZSwgcGFyYW1ldGVyTmFtZSkge1xuICAgIGlmICghaXNCaWdJbnQocGFyYW1ldGVyVmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAnJHtwYXJhbWV0ZXJOYW1lfScgaXMgbm90IGEgYmlnaW50LCByZWNlaXZlZCB0eXBlOiAke3R5cGVvZiBwYXJhbWV0ZXJWYWx1ZX1gKTtcbiAgICB9XG59XG4vKipcbiAqIEB0aHJvd3MgVGhyb3dzIGEgdHlwZSBlcnJvciBpZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIG5vdCBhIHN0cmluZ2lmaWVkIGJpZ2ludC5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJWYWx1ZSBUaGUgcGFyYW1ldGVyIHZhbHVlLlxuICogQHBhcmFtIHBhcmFtZXRlck5hbWUgVGhlIHBhcmFtZXRlciBuYW1lLlxuICovXG5mdW5jdGlvbiByZXF1aXJlU3RyaW5naWZpZWRCaWdJbnQocGFyYW1ldGVyVmFsdWUsIHBhcmFtZXRlck5hbWUpIHtcbiAgICBpZiAoIWlzU3RyaW5naWZpZWRCaWdJbnQocGFyYW1ldGVyVmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAnJHtwYXJhbWV0ZXJOYW1lfScgaXMgbm90IGEgc3RyaW5naWZpZWQgYmlnaW50YCk7XG4gICAgfVxufVxuLyoqXG4gKiBAdGhyb3dzIFRocm93cyBhIHR5cGUgZXJyb3IgaWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBpcyBub3QgYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKiBJZiAncHJlZml4JyBpcyAndHJ1ZScsIHRoZSBzdHJpbmcgbXVzdCBzdGFydCB3aXRoICcweCcgb3IgJzBYJyBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZVxuICogaGV4YWRlY2ltYWwgZGlnaXRzICgwLTksIGEtZiwgQS1GKSwgb3RoZXJ3aXNlIG5vIHByZWZpeCBpcyBleHBlY3RlZC4gJ3ByZWZpeCcgaXMgb3B0aW9uYWwgYW5kXG4gKiBpZiBpdHMgdmFsdWUgaXQgaXMgbm90IGV4cGxpY2l0bHkgZGVmaW5lZCBpdCB3aWxsIGJlIHNldCB0byAndHJ1ZScgYnkgZGVmYXVsdC5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJWYWx1ZSBUaGUgcGFyYW1ldGVyIHZhbHVlLlxuICogQHBhcmFtIHBhcmFtZXRlck5hbWUgVGhlIHBhcmFtZXRlciBuYW1lLlxuICogQHBhcmFtIHByZWZpeCBBIGJvb2xlYW4gdG8gaW5jbHVkZSBvciBub3QgYSAnMHgnIG9yICcwWCcgcHJlZml4LlxuICovXG5mdW5jdGlvbiByZXF1aXJlSGV4YWRlY2ltYWwocGFyYW1ldGVyVmFsdWUsIHBhcmFtZXRlck5hbWUsIHByZWZpeCA9IHRydWUpIHtcbiAgICBpZiAoIWlzSGV4YWRlY2ltYWwocGFyYW1ldGVyVmFsdWUsIHByZWZpeCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGFyYW1ldGVyICcke3BhcmFtZXRlck5hbWV9JyBpcyBub3QgYSBoZXhhZGVjaW1hbCBzdHJpbmdgKTtcbiAgICB9XG59XG4vKipcbiAqIEB0aHJvd3MgVGhyb3dzIGEgdHlwZSBlcnJvciBpZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIG5vdCBhIGJpZ251bWJlci5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJWYWx1ZSBUaGUgcGFyYW1ldGVyIHZhbHVlLlxuICogQHBhcmFtIHBhcmFtZXRlck5hbWUgVGhlIHBhcmFtZXRlciBuYW1lLlxuICovXG5mdW5jdGlvbiByZXF1aXJlQmlnTnVtYmVyKHBhcmFtZXRlclZhbHVlLCBwYXJhbWV0ZXJOYW1lKSB7XG4gICAgaWYgKCFpc0JpZ051bWJlcihwYXJhbWV0ZXJWYWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGFyYW1ldGVyICcke3BhcmFtZXRlck5hbWV9JyBpcyBub3QgYSBiaWdudW1iZXJgKTtcbiAgICB9XG59XG4vKipcbiAqIEB0aHJvd3MgVGhyb3dzIGEgdHlwZSBlcnJvciBpZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIG5vdCBhIGJpZ251bWJlci1pc2guXG4gKiBAcGFyYW0gcGFyYW1ldGVyVmFsdWUgVGhlIHBhcmFtZXRlciB2YWx1ZS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJOYW1lIFRoZSBwYXJhbWV0ZXIgbmFtZS5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZUJpZ051bWJlcmlzaChwYXJhbWV0ZXJWYWx1ZSwgcGFyYW1ldGVyTmFtZSkge1xuICAgIGlmICghaXNCaWdOdW1iZXJpc2gocGFyYW1ldGVyVmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAnJHtwYXJhbWV0ZXJOYW1lfScgaXMgbm90IGEgYmlnbnVtYmVyLWlzaGApO1xuICAgIH1cbn1cbi8qKlxuICogQHRocm93cyBUaHJvd3MgYSB0eXBlIGVycm9yIGlmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgdHlwZSBpcyBub3QgcGFydCBvZiB0aGUgbGlzdCBvZiB0eXBlcy5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJWYWx1ZSBUaGUgcGFyYW1ldGVyIHZhbHVlLlxuICogQHBhcmFtIHBhcmFtZXRlck5hbWUgVGhlIHBhcmFtZXRlciBuYW1lLlxuICovXG5mdW5jdGlvbiByZXF1aXJlVHlwZXMocGFyYW1ldGVyVmFsdWUsIHBhcmFtZXRlck5hbWUsIHR5cGVzKSB7XG4gICAgZm9yIChjb25zdCB0eXBlIG9mIHR5cGVzKSB7XG4gICAgICAgIGlmICghaXNTdXBwb3J0ZWRUeXBlKHR5cGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFR5cGUgJyR7dHlwZX0nIGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgdHlwZXMpIHtcbiAgICAgICAgaWYgKGlzVHlwZShwYXJhbWV0ZXJWYWx1ZSwgdHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJyR7cGFyYW1ldGVyTmFtZX0nIGlzIG5vbmUgb2YgdGhlIGZvbGxvd2luZyB0eXBlczogJHt0eXBlcy5qb2luKFwiLCBcIil9YCk7XG59XG5cbmV4cG9ydCB7IHJlcXVpcmVBcnJheSwgcmVxdWlyZUJpZ0ludCwgcmVxdWlyZUJpZ051bWJlciwgcmVxdWlyZUJpZ051bWJlcmlzaCwgcmVxdWlyZUJ1ZmZlciwgcmVxdWlyZURlZmluZWQsIHJlcXVpcmVGdW5jdGlvbiwgcmVxdWlyZUhleGFkZWNpbWFsLCByZXF1aXJlTnVtYmVyLCByZXF1aXJlT2JqZWN0LCByZXF1aXJlU3RyaW5nLCByZXF1aXJlU3RyaW5naWZpZWRCaWdJbnQsIHJlcXVpcmVUeXBlcywgcmVxdWlyZVVpbnQ4QXJyYXkgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@zk-kit/eddsa-poseidon/node_modules/@zk-kit/utils/dist/lib.esm/error-handlers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@zk-kit/eddsa-poseidon/node_modules/@zk-kit/utils/dist/lib.esm/f1-field.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@zk-kit/eddsa-poseidon/node_modules/@zk-kit/utils/dist/lib.esm/f1-field.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ F1Field)\n/* harmony export */ });\n/* harmony import */ var _scalar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scalar.js */ \"(ssr)/./node_modules/@zk-kit/eddsa-poseidon/node_modules/@zk-kit/utils/dist/lib.esm/scalar.js\");\n/**\n * @module @zk-kit/utils\n * @version 1.2.1\n * @file Essential zero-knowledge utility library for JavaScript developers.\n * @copyright Ethereum Foundation 2024\n * @license MIT\n * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/utils}\n*/\n\n\n/**\n * @class F1Field\n * Represents a finite field of order 'order' providing arithmetic operations under modulus.\n * This class includes operations such as addition, subtraction, multiplication, division,\n * and inversion, all performed modulo the field's order. It's designed to work with bigints,\n * supporting large numbers for cryptographic purposes and other applications requiring\n * modular arithmetic.\n * Note that the outputs of the functions will always be within the field if and only if\n * the input values are within the field. Devs need to make sure of that.\n *\n * @property one Represents the scalar value 1 in the field.\n * @property zero Represents the scalar value 0 in the field.\n * @property _order The order of the finite field (i.e., the modulus).\n * @property _half Half the order of the field, used for certain comparisons.\n * @property _negone The scalar value -1 in the field, represented positively.\n */\nclass F1Field {\n    constructor(order) {\n        this.one = 1n;\n        this.zero = 0n;\n        this._order = order;\n        this._half = order >> this.one;\n        this._negone = this._order - this.one;\n    }\n    /**\n     * Ensures a given result falls within the field by applying modular reduction.\n     * This method also handles negative inputs, correctly mapping them into the field.\n     * @param res The result to be normalized to the field.\n     * @returns The equivalent value within the field.\n     */\n    e(res) {\n        res %= this._order;\n        return res < 0 ? res + this._order : res;\n    }\n    /**\n     * Performs modular multiplication of two bigint values within the field.\n     * @param a The first value.\n     * @param b The second value.\n     * @returns The product of 'a' and 'b' modulo the field's order.\n     */\n    mul(a, b) {\n        return (a * b) % this._order;\n    }\n    /**\n     * Subtracts one bigint from another under modulus.\n     * It ensures the result is within the field if and only if the input values are within the field.\n     * @param a The value from which to subtract.\n     * @param b The value to be subtracted.\n     * @returns The difference of 'a' and 'b' modulo the field's order.\n     */\n    sub(a, b) {\n        return a >= b ? a - b : this._order - b + a;\n    }\n    /**\n     * Adds two bigint values together under modulus.\n     * It ensures the result is within the field if and only if the input values are within the field.\n     * @param a The first value.\n     * @param b The second value.\n     * @returns The sum of 'a' and 'b' modulo the field's order.\n     */\n    add(a, b) {\n        const res = a + b;\n        return res >= this._order ? res - this._order : res;\n    }\n    /**\n     * Computes the multiplicative inverse of a given value within the field.\n     * This method uses the Extended Euclidean Algorithm to find the inverse,\n     * ensuring the result is always a positive value less than the field's order.\n     * If the input value is zero, which has no inverse, an error is thrown.\n     * @param a The value for which to compute the inverse.\n     * @returns The multiplicative inverse of 'a' modulo the field's order.\n     * @throws if 'a' is zero.\n     */\n    inv(a) {\n        if (a === this.zero) {\n            throw new Error(\"Zero has no inverse\");\n        }\n        let t = this.zero;\n        let r = this._order;\n        let newt = this.one;\n        let newr = a % this._order;\n        while (newr) {\n            const q = r / newr;\n            [t, newt] = [newt, t - q * newt];\n            [r, newr] = [newr, r - q * newr];\n        }\n        if (t < this.zero) {\n            t += this._order;\n        }\n        return t;\n    }\n    /**\n     * Divides one bigint by another within the field by multiplying the first value\n     * by the multiplicative inverse of the second.\n     * @param a The dividend.\n     * @param b The divisor.\n     * @returns The result of the division of 'a' by 'b' modulo the field's order.\n     */\n    div(a, b) {\n        return this.mul(a, this.inv(b));\n    }\n    /**\n     * Checks if two bigint values are equal within the context of the field.\n     * It ensures the result is within the field if and only if the input values are within the field.\n     * @param a The first value to compare.\n     * @param b The second value to compare.\n     * @returns True if 'a' equals 'b', false otherwise.\n     */\n    eq(a, b) {\n        return a === b;\n    }\n    /**\n     * Squares a bigint value within the field.\n     * This is a specific case of multiplication where the value is multiplied by itself,\n     * optimized for performance where applicable.\n     * It ensures the result is within the field if and only if the input values are within the field.\n     * @param a The value to square.\n     * @returns The square of 'a' modulo the field's order.\n     */\n    square(a) {\n        return (a * a) % this._order;\n    }\n    /**\n     * Compares two bigint values to determine if the first is less than the second,\n     * taking into account the field's order for modular comparison.\n     * It ensures the result is within the field if and only if the input values are within the field.\n     * @param a The first value to compare.\n     * @param b The second value to compare.\n     * @returns True if 'a' is less than 'b', false otherwise.\n     */\n    lt(a, b) {\n        const aa = a > this._half ? a - this._order : a;\n        const bb = b > this._half ? b - this._order : b;\n        return aa < bb;\n    }\n    /**\n     * Compares two bigint values to determine if the first is greater than or equal to the second,\n     * considering the field's modular context.\n     * It ensures the result is within the field if and only if the input values are within the field.\n     * @param a The first value to compare.\n     * @param b The second value to compare.\n     * @returns True if 'a' is greater than or equal to 'b', false otherwise.\n     */\n    geq(a, b) {\n        const aa = a > this._half ? a - this._order : a;\n        const bb = b > this._half ? b - this._order : b;\n        return aa >= bb;\n    }\n    /**\n     * Computes the negation of a bigint value within the field.\n     * The result is the modular additive inverse that, when added to the original value,\n     * yields zero in the field's modulus.\n     * It ensures the result is within the field if and only if the input values are within the field.\n     * @param a The value to negate.\n     * @returns The negation of 'a' modulo the field's order.\n     */\n    neg(a) {\n        return a ? this._order - a : a;\n    }\n    /**\n     * Checks if a bigint value is zero within the context of the field.\n     * @param a The value to check.\n     * @returns True if 'a' is zero, false otherwise.\n     */\n    isZero(a) {\n        return a === this.zero;\n    }\n    /**\n     * Raises a base to an exponent within the field, efficiently computing\n     * scalar exponentiation using the square-and-multiply algorithm.\n     * Supports both positive and negative exponents through the use of the `inv` method for negatives.\n     * @param base The base to be exponentiated.\n     * @param e The exponent.\n     * @returns The result of raising 'base' to the power 'e' modulo the field's order.\n     */\n    pow(base, e) {\n        if ((0,_scalar_js__WEBPACK_IMPORTED_MODULE_0__.isZero)(e)) {\n            return this.one;\n        }\n        if (e < 0n) {\n            base = this.inv(base);\n            e = -e;\n        }\n        const n = (0,_scalar_js__WEBPACK_IMPORTED_MODULE_0__.bits)(e);\n        if (n.length === 0) {\n            return this.one;\n        }\n        let res = base;\n        for (let i = n.length - 2; i >= 0; i -= 1) {\n            res = this.square(res);\n            if (n[i]) {\n                res = this.mul(res, base);\n            }\n        }\n        return res;\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHprLWtpdC9lZGRzYS1wb3NlaWRvbi9ub2RlX21vZHVsZXMvQHprLWtpdC91dGlscy9kaXN0L2xpYi5lc20vZjEtZmllbGQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtEQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnREFBSTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRThCIiwic291cmNlcyI6WyIvVXNlcnMvY2hhbmNlbWNhbGxpc3Rlci9Qcm9qZWN0cy96dXBhc3NodW50L25vZGVfbW9kdWxlcy9Aemsta2l0L2VkZHNhLXBvc2VpZG9uL25vZGVfbW9kdWxlcy9Aemsta2l0L3V0aWxzL2Rpc3QvbGliLmVzbS9mMS1maWVsZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgQHprLWtpdC91dGlsc1xuICogQHZlcnNpb24gMS4yLjFcbiAqIEBmaWxlIEVzc2VudGlhbCB6ZXJvLWtub3dsZWRnZSB1dGlsaXR5IGxpYnJhcnkgZm9yIEphdmFTY3JpcHQgZGV2ZWxvcGVycy5cbiAqIEBjb3B5cmlnaHQgRXRoZXJldW0gRm91bmRhdGlvbiAyMDI0XG4gKiBAbGljZW5zZSBNSVRcbiAqIEBzZWUgW0dpdGh1Yl17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3ByaXZhY3ktc2NhbGluZy1leHBsb3JhdGlvbnMvemsta2l0L3RyZWUvbWFpbi9wYWNrYWdlcy91dGlsc31cbiovXG5pbXBvcnQgeyBpc1plcm8sIGJpdHMgfSBmcm9tICcuL3NjYWxhci5qcyc7XG5cbi8qKlxuICogQGNsYXNzIEYxRmllbGRcbiAqIFJlcHJlc2VudHMgYSBmaW5pdGUgZmllbGQgb2Ygb3JkZXIgJ29yZGVyJyBwcm92aWRpbmcgYXJpdGhtZXRpYyBvcGVyYXRpb25zIHVuZGVyIG1vZHVsdXMuXG4gKiBUaGlzIGNsYXNzIGluY2x1ZGVzIG9wZXJhdGlvbnMgc3VjaCBhcyBhZGRpdGlvbiwgc3VidHJhY3Rpb24sIG11bHRpcGxpY2F0aW9uLCBkaXZpc2lvbixcbiAqIGFuZCBpbnZlcnNpb24sIGFsbCBwZXJmb3JtZWQgbW9kdWxvIHRoZSBmaWVsZCdzIG9yZGVyLiBJdCdzIGRlc2lnbmVkIHRvIHdvcmsgd2l0aCBiaWdpbnRzLFxuICogc3VwcG9ydGluZyBsYXJnZSBudW1iZXJzIGZvciBjcnlwdG9ncmFwaGljIHB1cnBvc2VzIGFuZCBvdGhlciBhcHBsaWNhdGlvbnMgcmVxdWlyaW5nXG4gKiBtb2R1bGFyIGFyaXRobWV0aWMuXG4gKiBOb3RlIHRoYXQgdGhlIG91dHB1dHMgb2YgdGhlIGZ1bmN0aW9ucyB3aWxsIGFsd2F5cyBiZSB3aXRoaW4gdGhlIGZpZWxkIGlmIGFuZCBvbmx5IGlmXG4gKiB0aGUgaW5wdXQgdmFsdWVzIGFyZSB3aXRoaW4gdGhlIGZpZWxkLiBEZXZzIG5lZWQgdG8gbWFrZSBzdXJlIG9mIHRoYXQuXG4gKlxuICogQHByb3BlcnR5IG9uZSBSZXByZXNlbnRzIHRoZSBzY2FsYXIgdmFsdWUgMSBpbiB0aGUgZmllbGQuXG4gKiBAcHJvcGVydHkgemVybyBSZXByZXNlbnRzIHRoZSBzY2FsYXIgdmFsdWUgMCBpbiB0aGUgZmllbGQuXG4gKiBAcHJvcGVydHkgX29yZGVyIFRoZSBvcmRlciBvZiB0aGUgZmluaXRlIGZpZWxkIChpLmUuLCB0aGUgbW9kdWx1cykuXG4gKiBAcHJvcGVydHkgX2hhbGYgSGFsZiB0aGUgb3JkZXIgb2YgdGhlIGZpZWxkLCB1c2VkIGZvciBjZXJ0YWluIGNvbXBhcmlzb25zLlxuICogQHByb3BlcnR5IF9uZWdvbmUgVGhlIHNjYWxhciB2YWx1ZSAtMSBpbiB0aGUgZmllbGQsIHJlcHJlc2VudGVkIHBvc2l0aXZlbHkuXG4gKi9cbmNsYXNzIEYxRmllbGQge1xuICAgIGNvbnN0cnVjdG9yKG9yZGVyKSB7XG4gICAgICAgIHRoaXMub25lID0gMW47XG4gICAgICAgIHRoaXMuemVybyA9IDBuO1xuICAgICAgICB0aGlzLl9vcmRlciA9IG9yZGVyO1xuICAgICAgICB0aGlzLl9oYWxmID0gb3JkZXIgPj4gdGhpcy5vbmU7XG4gICAgICAgIHRoaXMuX25lZ29uZSA9IHRoaXMuX29yZGVyIC0gdGhpcy5vbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgYSBnaXZlbiByZXN1bHQgZmFsbHMgd2l0aGluIHRoZSBmaWVsZCBieSBhcHBseWluZyBtb2R1bGFyIHJlZHVjdGlvbi5cbiAgICAgKiBUaGlzIG1ldGhvZCBhbHNvIGhhbmRsZXMgbmVnYXRpdmUgaW5wdXRzLCBjb3JyZWN0bHkgbWFwcGluZyB0aGVtIGludG8gdGhlIGZpZWxkLlxuICAgICAqIEBwYXJhbSByZXMgVGhlIHJlc3VsdCB0byBiZSBub3JtYWxpemVkIHRvIHRoZSBmaWVsZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgZXF1aXZhbGVudCB2YWx1ZSB3aXRoaW4gdGhlIGZpZWxkLlxuICAgICAqL1xuICAgIGUocmVzKSB7XG4gICAgICAgIHJlcyAlPSB0aGlzLl9vcmRlcjtcbiAgICAgICAgcmV0dXJuIHJlcyA8IDAgPyByZXMgKyB0aGlzLl9vcmRlciA6IHJlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgbW9kdWxhciBtdWx0aXBsaWNhdGlvbiBvZiB0d28gYmlnaW50IHZhbHVlcyB3aXRoaW4gdGhlIGZpZWxkLlxuICAgICAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIFRoZSBwcm9kdWN0IG9mICdhJyBhbmQgJ2InIG1vZHVsbyB0aGUgZmllbGQncyBvcmRlci5cbiAgICAgKi9cbiAgICBtdWwoYSwgYikge1xuICAgICAgICByZXR1cm4gKGEgKiBiKSAlIHRoaXMuX29yZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgb25lIGJpZ2ludCBmcm9tIGFub3RoZXIgdW5kZXIgbW9kdWx1cy5cbiAgICAgKiBJdCBlbnN1cmVzIHRoZSByZXN1bHQgaXMgd2l0aGluIHRoZSBmaWVsZCBpZiBhbmQgb25seSBpZiB0aGUgaW5wdXQgdmFsdWVzIGFyZSB3aXRoaW4gdGhlIGZpZWxkLlxuICAgICAqIEBwYXJhbSBhIFRoZSB2YWx1ZSBmcm9tIHdoaWNoIHRvIHN1YnRyYWN0LlxuICAgICAqIEBwYXJhbSBiIFRoZSB2YWx1ZSB0byBiZSBzdWJ0cmFjdGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBkaWZmZXJlbmNlIG9mICdhJyBhbmQgJ2InIG1vZHVsbyB0aGUgZmllbGQncyBvcmRlci5cbiAgICAgKi9cbiAgICBzdWIoYSwgYikge1xuICAgICAgICByZXR1cm4gYSA+PSBiID8gYSAtIGIgOiB0aGlzLl9vcmRlciAtIGIgKyBhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHR3byBiaWdpbnQgdmFsdWVzIHRvZ2V0aGVyIHVuZGVyIG1vZHVsdXMuXG4gICAgICogSXQgZW5zdXJlcyB0aGUgcmVzdWx0IGlzIHdpdGhpbiB0aGUgZmllbGQgaWYgYW5kIG9ubHkgaWYgdGhlIGlucHV0IHZhbHVlcyBhcmUgd2l0aGluIHRoZSBmaWVsZC5cbiAgICAgKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmFsdWUuXG4gICAgICogQHBhcmFtIGIgVGhlIHNlY29uZCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgc3VtIG9mICdhJyBhbmQgJ2InIG1vZHVsbyB0aGUgZmllbGQncyBvcmRlci5cbiAgICAgKi9cbiAgICBhZGQoYSwgYikge1xuICAgICAgICBjb25zdCByZXMgPSBhICsgYjtcbiAgICAgICAgcmV0dXJuIHJlcyA+PSB0aGlzLl9vcmRlciA/IHJlcyAtIHRoaXMuX29yZGVyIDogcmVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbXVsdGlwbGljYXRpdmUgaW52ZXJzZSBvZiBhIGdpdmVuIHZhbHVlIHdpdGhpbiB0aGUgZmllbGQuXG4gICAgICogVGhpcyBtZXRob2QgdXNlcyB0aGUgRXh0ZW5kZWQgRXVjbGlkZWFuIEFsZ29yaXRobSB0byBmaW5kIHRoZSBpbnZlcnNlLFxuICAgICAqIGVuc3VyaW5nIHRoZSByZXN1bHQgaXMgYWx3YXlzIGEgcG9zaXRpdmUgdmFsdWUgbGVzcyB0aGFuIHRoZSBmaWVsZCdzIG9yZGVyLlxuICAgICAqIElmIHRoZSBpbnB1dCB2YWx1ZSBpcyB6ZXJvLCB3aGljaCBoYXMgbm8gaW52ZXJzZSwgYW4gZXJyb3IgaXMgdGhyb3duLlxuICAgICAqIEBwYXJhbSBhIFRoZSB2YWx1ZSBmb3Igd2hpY2ggdG8gY29tcHV0ZSB0aGUgaW52ZXJzZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgbXVsdGlwbGljYXRpdmUgaW52ZXJzZSBvZiAnYScgbW9kdWxvIHRoZSBmaWVsZCdzIG9yZGVyLlxuICAgICAqIEB0aHJvd3MgaWYgJ2EnIGlzIHplcm8uXG4gICAgICovXG4gICAgaW52KGEpIHtcbiAgICAgICAgaWYgKGEgPT09IHRoaXMuemVybykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWmVybyBoYXMgbm8gaW52ZXJzZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdCA9IHRoaXMuemVybztcbiAgICAgICAgbGV0IHIgPSB0aGlzLl9vcmRlcjtcbiAgICAgICAgbGV0IG5ld3QgPSB0aGlzLm9uZTtcbiAgICAgICAgbGV0IG5ld3IgPSBhICUgdGhpcy5fb3JkZXI7XG4gICAgICAgIHdoaWxlIChuZXdyKSB7XG4gICAgICAgICAgICBjb25zdCBxID0gciAvIG5ld3I7XG4gICAgICAgICAgICBbdCwgbmV3dF0gPSBbbmV3dCwgdCAtIHEgKiBuZXd0XTtcbiAgICAgICAgICAgIFtyLCBuZXdyXSA9IFtuZXdyLCByIC0gcSAqIG5ld3JdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0IDwgdGhpcy56ZXJvKSB7XG4gICAgICAgICAgICB0ICs9IHRoaXMuX29yZGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIG9uZSBiaWdpbnQgYnkgYW5vdGhlciB3aXRoaW4gdGhlIGZpZWxkIGJ5IG11bHRpcGx5aW5nIHRoZSBmaXJzdCB2YWx1ZVxuICAgICAqIGJ5IHRoZSBtdWx0aXBsaWNhdGl2ZSBpbnZlcnNlIG9mIHRoZSBzZWNvbmQuXG4gICAgICogQHBhcmFtIGEgVGhlIGRpdmlkZW5kLlxuICAgICAqIEBwYXJhbSBiIFRoZSBkaXZpc29yLlxuICAgICAqIEByZXR1cm5zIFRoZSByZXN1bHQgb2YgdGhlIGRpdmlzaW9uIG9mICdhJyBieSAnYicgbW9kdWxvIHRoZSBmaWVsZCdzIG9yZGVyLlxuICAgICAqL1xuICAgIGRpdihhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm11bChhLCB0aGlzLmludihiKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0d28gYmlnaW50IHZhbHVlcyBhcmUgZXF1YWwgd2l0aGluIHRoZSBjb250ZXh0IG9mIHRoZSBmaWVsZC5cbiAgICAgKiBJdCBlbnN1cmVzIHRoZSByZXN1bHQgaXMgd2l0aGluIHRoZSBmaWVsZCBpZiBhbmQgb25seSBpZiB0aGUgaW5wdXQgdmFsdWVzIGFyZSB3aXRoaW4gdGhlIGZpZWxkLlxuICAgICAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmICdhJyBlcXVhbHMgJ2InLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZXEoYSwgYikge1xuICAgICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3F1YXJlcyBhIGJpZ2ludCB2YWx1ZSB3aXRoaW4gdGhlIGZpZWxkLlxuICAgICAqIFRoaXMgaXMgYSBzcGVjaWZpYyBjYXNlIG9mIG11bHRpcGxpY2F0aW9uIHdoZXJlIHRoZSB2YWx1ZSBpcyBtdWx0aXBsaWVkIGJ5IGl0c2VsZixcbiAgICAgKiBvcHRpbWl6ZWQgZm9yIHBlcmZvcm1hbmNlIHdoZXJlIGFwcGxpY2FibGUuXG4gICAgICogSXQgZW5zdXJlcyB0aGUgcmVzdWx0IGlzIHdpdGhpbiB0aGUgZmllbGQgaWYgYW5kIG9ubHkgaWYgdGhlIGlucHV0IHZhbHVlcyBhcmUgd2l0aGluIHRoZSBmaWVsZC5cbiAgICAgKiBAcGFyYW0gYSBUaGUgdmFsdWUgdG8gc3F1YXJlLlxuICAgICAqIEByZXR1cm5zIFRoZSBzcXVhcmUgb2YgJ2EnIG1vZHVsbyB0aGUgZmllbGQncyBvcmRlci5cbiAgICAgKi9cbiAgICBzcXVhcmUoYSkge1xuICAgICAgICByZXR1cm4gKGEgKiBhKSAlIHRoaXMuX29yZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyB0d28gYmlnaW50IHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhlIGZpcnN0IGlzIGxlc3MgdGhhbiB0aGUgc2Vjb25kLFxuICAgICAqIHRha2luZyBpbnRvIGFjY291bnQgdGhlIGZpZWxkJ3Mgb3JkZXIgZm9yIG1vZHVsYXIgY29tcGFyaXNvbi5cbiAgICAgKiBJdCBlbnN1cmVzIHRoZSByZXN1bHQgaXMgd2l0aGluIHRoZSBmaWVsZCBpZiBhbmQgb25seSBpZiB0aGUgaW5wdXQgdmFsdWVzIGFyZSB3aXRoaW4gdGhlIGZpZWxkLlxuICAgICAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmICdhJyBpcyBsZXNzIHRoYW4gJ2InLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgbHQoYSwgYikge1xuICAgICAgICBjb25zdCBhYSA9IGEgPiB0aGlzLl9oYWxmID8gYSAtIHRoaXMuX29yZGVyIDogYTtcbiAgICAgICAgY29uc3QgYmIgPSBiID4gdGhpcy5faGFsZiA/IGIgLSB0aGlzLl9vcmRlciA6IGI7XG4gICAgICAgIHJldHVybiBhYSA8IGJiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyB0d28gYmlnaW50IHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhlIGZpcnN0IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgc2Vjb25kLFxuICAgICAqIGNvbnNpZGVyaW5nIHRoZSBmaWVsZCdzIG1vZHVsYXIgY29udGV4dC5cbiAgICAgKiBJdCBlbnN1cmVzIHRoZSByZXN1bHQgaXMgd2l0aGluIHRoZSBmaWVsZCBpZiBhbmQgb25seSBpZiB0aGUgaW5wdXQgdmFsdWVzIGFyZSB3aXRoaW4gdGhlIGZpZWxkLlxuICAgICAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmICdhJyBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJ2InLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZ2VxKGEsIGIpIHtcbiAgICAgICAgY29uc3QgYWEgPSBhID4gdGhpcy5faGFsZiA/IGEgLSB0aGlzLl9vcmRlciA6IGE7XG4gICAgICAgIGNvbnN0IGJiID0gYiA+IHRoaXMuX2hhbGYgPyBiIC0gdGhpcy5fb3JkZXIgOiBiO1xuICAgICAgICByZXR1cm4gYWEgPj0gYmI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBuZWdhdGlvbiBvZiBhIGJpZ2ludCB2YWx1ZSB3aXRoaW4gdGhlIGZpZWxkLlxuICAgICAqIFRoZSByZXN1bHQgaXMgdGhlIG1vZHVsYXIgYWRkaXRpdmUgaW52ZXJzZSB0aGF0LCB3aGVuIGFkZGVkIHRvIHRoZSBvcmlnaW5hbCB2YWx1ZSxcbiAgICAgKiB5aWVsZHMgemVybyBpbiB0aGUgZmllbGQncyBtb2R1bHVzLlxuICAgICAqIEl0IGVuc3VyZXMgdGhlIHJlc3VsdCBpcyB3aXRoaW4gdGhlIGZpZWxkIGlmIGFuZCBvbmx5IGlmIHRoZSBpbnB1dCB2YWx1ZXMgYXJlIHdpdGhpbiB0aGUgZmllbGQuXG4gICAgICogQHBhcmFtIGEgVGhlIHZhbHVlIHRvIG5lZ2F0ZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgbmVnYXRpb24gb2YgJ2EnIG1vZHVsbyB0aGUgZmllbGQncyBvcmRlci5cbiAgICAgKi9cbiAgICBuZWcoYSkge1xuICAgICAgICByZXR1cm4gYSA/IHRoaXMuX29yZGVyIC0gYSA6IGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGJpZ2ludCB2YWx1ZSBpcyB6ZXJvIHdpdGhpbiB0aGUgY29udGV4dCBvZiB0aGUgZmllbGQuXG4gICAgICogQHBhcmFtIGEgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgJ2EnIGlzIHplcm8sIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc1plcm8oYSkge1xuICAgICAgICByZXR1cm4gYSA9PT0gdGhpcy56ZXJvO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSYWlzZXMgYSBiYXNlIHRvIGFuIGV4cG9uZW50IHdpdGhpbiB0aGUgZmllbGQsIGVmZmljaWVudGx5IGNvbXB1dGluZ1xuICAgICAqIHNjYWxhciBleHBvbmVudGlhdGlvbiB1c2luZyB0aGUgc3F1YXJlLWFuZC1tdWx0aXBseSBhbGdvcml0aG0uXG4gICAgICogU3VwcG9ydHMgYm90aCBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgZXhwb25lbnRzIHRocm91Z2ggdGhlIHVzZSBvZiB0aGUgYGludmAgbWV0aG9kIGZvciBuZWdhdGl2ZXMuXG4gICAgICogQHBhcmFtIGJhc2UgVGhlIGJhc2UgdG8gYmUgZXhwb25lbnRpYXRlZC5cbiAgICAgKiBAcGFyYW0gZSBUaGUgZXhwb25lbnQuXG4gICAgICogQHJldHVybnMgVGhlIHJlc3VsdCBvZiByYWlzaW5nICdiYXNlJyB0byB0aGUgcG93ZXIgJ2UnIG1vZHVsbyB0aGUgZmllbGQncyBvcmRlci5cbiAgICAgKi9cbiAgICBwb3coYmFzZSwgZSkge1xuICAgICAgICBpZiAoaXNaZXJvKGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbmU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUgPCAwbikge1xuICAgICAgICAgICAgYmFzZSA9IHRoaXMuaW52KGJhc2UpO1xuICAgICAgICAgICAgZSA9IC1lO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG4gPSBiaXRzKGUpO1xuICAgICAgICBpZiAobi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzID0gYmFzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IG4ubGVuZ3RoIC0gMjsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICAgIHJlcyA9IHRoaXMuc3F1YXJlKHJlcyk7XG4gICAgICAgICAgICBpZiAobltpXSkge1xuICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMubXVsKHJlcywgYmFzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG5cbmV4cG9ydCB7IEYxRmllbGQgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@zk-kit/eddsa-poseidon/node_modules/@zk-kit/utils/dist/lib.esm/f1-field.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@zk-kit/eddsa-poseidon/node_modules/@zk-kit/utils/dist/lib.esm/scalar.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@zk-kit/eddsa-poseidon/node_modules/@zk-kit/utils/dist/lib.esm/scalar.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bits: () => (/* binding */ bits),\n/* harmony export */   gt: () => (/* binding */ gt),\n/* harmony export */   isOdd: () => (/* binding */ isOdd),\n/* harmony export */   isZero: () => (/* binding */ isZero),\n/* harmony export */   mul: () => (/* binding */ mul),\n/* harmony export */   shiftRight: () => (/* binding */ shiftRight)\n/* harmony export */ });\n/**\n * @module @zk-kit/utils\n * @version 1.2.1\n * @file Essential zero-knowledge utility library for JavaScript developers.\n * @copyright Ethereum Foundation 2024\n * @license MIT\n * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/utils}\n*/\n/**\n * @module Scalar\n * This module provides utility functions for performing scalar operations\n * within a field, especially designed to handle operations on bigints.\n * The operations include scalar inversion (`inv`), scalar exponentiation (`pow`),\n * and modular reduction. Functions are carefully implemented to ensure\n * mathematical correctness and efficiency, supporting both positive and\n * negative bigint values. The module aims to provide robust tools for\n * cryptographic calculations and other applications requiring high-precision\n * arithmetic in fields.\n */\n/**\n * Checks if a bigint scalar value is zero.\n * @param a The bigint scalar value to check.\n * @returns True if 'a' is zero, false otherwise.\n */\nfunction isZero(a) {\n    return !a;\n}\n/**\n * Determines whether a bigint scalar value is odd.\n * @param a The bigint scalar value to check.\n * @returns True if 'a' is odd, false if it is even.\n */\nfunction isOdd(a) {\n    return (a & BigInt(1)) === BigInt(1);\n}\n/**\n * Performs a bitwise right shift on a bigint scalar value.\n * This operation is equivalent to dividing by 2^n, but it operates directly\n * on the binary representation, making it efficient for certain types of calculations.\n * @param a The bigint scalar value to shift.\n * @param n The number of bits to shift 'a' by.\n * @returns The result of shifting 'a' right by 'n' bits.\n */\nfunction shiftRight(a, n) {\n    return a >> n;\n}\n/**\n * Multiplies two bigint scalar values.\n * @param a The first bigint scalar value.\n * @param b The second bigint scalar value.\n * @returns The product of 'a' and 'b'.\n */\nfunction mul(a, b) {\n    return a * b;\n}\n/**\n * Compares two bigint scalar values to determine if the first is greater than the second.\n * @param a The first bigint scalar value to compare.\n * @param b The second bigint scalar value to compare.\n * @returns True if 'a' is greater than 'b', false otherwise.\n */\nfunction gt(a, b) {\n    return a > b;\n}\n/**\n * Converts a bigint scalar value into an array of bits, represented as numbers.\n * This function is particularly useful for examining the binary structure of bigints,\n * which can be necessary for bit manipulation and understanding the representation\n * of numbers at a lower level.\n * @param n The bigint scalar value to convert into bits.\n * @returns An array of numbers representing the bits of 'n', starting from the least significant bit.\n */\nfunction bits(n) {\n    const res = [];\n    let E = n;\n    while (E) {\n        if (E & BigInt(1)) {\n            res.push(1);\n        }\n        else {\n            res.push(0);\n        }\n        E >>= BigInt(1);\n    }\n    return res;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHprLWtpdC9lZGRzYS1wb3NlaWRvbi9ub2RlX21vZHVsZXMvQHprLWtpdC91dGlscy9kaXN0L2xpYi5lc20vc2NhbGFyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFb0QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jaGFuY2VtY2FsbGlzdGVyL1Byb2plY3RzL3p1cGFzc2h1bnQvbm9kZV9tb2R1bGVzL0B6ay1raXQvZWRkc2EtcG9zZWlkb24vbm9kZV9tb2R1bGVzL0B6ay1raXQvdXRpbHMvZGlzdC9saWIuZXNtL3NjYWxhci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgQHprLWtpdC91dGlsc1xuICogQHZlcnNpb24gMS4yLjFcbiAqIEBmaWxlIEVzc2VudGlhbCB6ZXJvLWtub3dsZWRnZSB1dGlsaXR5IGxpYnJhcnkgZm9yIEphdmFTY3JpcHQgZGV2ZWxvcGVycy5cbiAqIEBjb3B5cmlnaHQgRXRoZXJldW0gRm91bmRhdGlvbiAyMDI0XG4gKiBAbGljZW5zZSBNSVRcbiAqIEBzZWUgW0dpdGh1Yl17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3ByaXZhY3ktc2NhbGluZy1leHBsb3JhdGlvbnMvemsta2l0L3RyZWUvbWFpbi9wYWNrYWdlcy91dGlsc31cbiovXG4vKipcbiAqIEBtb2R1bGUgU2NhbGFyXG4gKiBUaGlzIG1vZHVsZSBwcm92aWRlcyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgcGVyZm9ybWluZyBzY2FsYXIgb3BlcmF0aW9uc1xuICogd2l0aGluIGEgZmllbGQsIGVzcGVjaWFsbHkgZGVzaWduZWQgdG8gaGFuZGxlIG9wZXJhdGlvbnMgb24gYmlnaW50cy5cbiAqIFRoZSBvcGVyYXRpb25zIGluY2x1ZGUgc2NhbGFyIGludmVyc2lvbiAoYGludmApLCBzY2FsYXIgZXhwb25lbnRpYXRpb24gKGBwb3dgKSxcbiAqIGFuZCBtb2R1bGFyIHJlZHVjdGlvbi4gRnVuY3Rpb25zIGFyZSBjYXJlZnVsbHkgaW1wbGVtZW50ZWQgdG8gZW5zdXJlXG4gKiBtYXRoZW1hdGljYWwgY29ycmVjdG5lc3MgYW5kIGVmZmljaWVuY3ksIHN1cHBvcnRpbmcgYm90aCBwb3NpdGl2ZSBhbmRcbiAqIG5lZ2F0aXZlIGJpZ2ludCB2YWx1ZXMuIFRoZSBtb2R1bGUgYWltcyB0byBwcm92aWRlIHJvYnVzdCB0b29scyBmb3JcbiAqIGNyeXB0b2dyYXBoaWMgY2FsY3VsYXRpb25zIGFuZCBvdGhlciBhcHBsaWNhdGlvbnMgcmVxdWlyaW5nIGhpZ2gtcHJlY2lzaW9uXG4gKiBhcml0aG1ldGljIGluIGZpZWxkcy5cbiAqL1xuLyoqXG4gKiBDaGVja3MgaWYgYSBiaWdpbnQgc2NhbGFyIHZhbHVlIGlzIHplcm8uXG4gKiBAcGFyYW0gYSBUaGUgYmlnaW50IHNjYWxhciB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFRydWUgaWYgJ2EnIGlzIHplcm8sIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNaZXJvKGEpIHtcbiAgICByZXR1cm4gIWE7XG59XG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhIGJpZ2ludCBzY2FsYXIgdmFsdWUgaXMgb2RkLlxuICogQHBhcmFtIGEgVGhlIGJpZ2ludCBzY2FsYXIgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBUcnVlIGlmICdhJyBpcyBvZGQsIGZhbHNlIGlmIGl0IGlzIGV2ZW4uXG4gKi9cbmZ1bmN0aW9uIGlzT2RkKGEpIHtcbiAgICByZXR1cm4gKGEgJiBCaWdJbnQoMSkpID09PSBCaWdJbnQoMSk7XG59XG4vKipcbiAqIFBlcmZvcm1zIGEgYml0d2lzZSByaWdodCBzaGlmdCBvbiBhIGJpZ2ludCBzY2FsYXIgdmFsdWUuXG4gKiBUaGlzIG9wZXJhdGlvbiBpcyBlcXVpdmFsZW50IHRvIGRpdmlkaW5nIGJ5IDJebiwgYnV0IGl0IG9wZXJhdGVzIGRpcmVjdGx5XG4gKiBvbiB0aGUgYmluYXJ5IHJlcHJlc2VudGF0aW9uLCBtYWtpbmcgaXQgZWZmaWNpZW50IGZvciBjZXJ0YWluIHR5cGVzIG9mIGNhbGN1bGF0aW9ucy5cbiAqIEBwYXJhbSBhIFRoZSBiaWdpbnQgc2NhbGFyIHZhbHVlIHRvIHNoaWZ0LlxuICogQHBhcmFtIG4gVGhlIG51bWJlciBvZiBiaXRzIHRvIHNoaWZ0ICdhJyBieS5cbiAqIEByZXR1cm5zIFRoZSByZXN1bHQgb2Ygc2hpZnRpbmcgJ2EnIHJpZ2h0IGJ5ICduJyBiaXRzLlxuICovXG5mdW5jdGlvbiBzaGlmdFJpZ2h0KGEsIG4pIHtcbiAgICByZXR1cm4gYSA+PiBuO1xufVxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBiaWdpbnQgc2NhbGFyIHZhbHVlcy5cbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCBiaWdpbnQgc2NhbGFyIHZhbHVlLlxuICogQHBhcmFtIGIgVGhlIHNlY29uZCBiaWdpbnQgc2NhbGFyIHZhbHVlLlxuICogQHJldHVybnMgVGhlIHByb2R1Y3Qgb2YgJ2EnIGFuZCAnYicuXG4gKi9cbmZ1bmN0aW9uIG11bChhLCBiKSB7XG4gICAgcmV0dXJuIGEgKiBiO1xufVxuLyoqXG4gKiBDb21wYXJlcyB0d28gYmlnaW50IHNjYWxhciB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZSBmaXJzdCBpcyBncmVhdGVyIHRoYW4gdGhlIHNlY29uZC5cbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCBiaWdpbnQgc2NhbGFyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0gYiBUaGUgc2Vjb25kIGJpZ2ludCBzY2FsYXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIFRydWUgaWYgJ2EnIGlzIGdyZWF0ZXIgdGhhbiAnYicsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gZ3QoYSwgYikge1xuICAgIHJldHVybiBhID4gYjtcbn1cbi8qKlxuICogQ29udmVydHMgYSBiaWdpbnQgc2NhbGFyIHZhbHVlIGludG8gYW4gYXJyYXkgb2YgYml0cywgcmVwcmVzZW50ZWQgYXMgbnVtYmVycy5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3IgZXhhbWluaW5nIHRoZSBiaW5hcnkgc3RydWN0dXJlIG9mIGJpZ2ludHMsXG4gKiB3aGljaCBjYW4gYmUgbmVjZXNzYXJ5IGZvciBiaXQgbWFuaXB1bGF0aW9uIGFuZCB1bmRlcnN0YW5kaW5nIHRoZSByZXByZXNlbnRhdGlvblxuICogb2YgbnVtYmVycyBhdCBhIGxvd2VyIGxldmVsLlxuICogQHBhcmFtIG4gVGhlIGJpZ2ludCBzY2FsYXIgdmFsdWUgdG8gY29udmVydCBpbnRvIGJpdHMuXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBudW1iZXJzIHJlcHJlc2VudGluZyB0aGUgYml0cyBvZiAnbicsIHN0YXJ0aW5nIGZyb20gdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdC5cbiAqL1xuZnVuY3Rpb24gYml0cyhuKSB7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgbGV0IEUgPSBuO1xuICAgIHdoaWxlIChFKSB7XG4gICAgICAgIGlmIChFICYgQmlnSW50KDEpKSB7XG4gICAgICAgICAgICByZXMucHVzaCgxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICAgIEUgPj49IEJpZ0ludCgxKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuZXhwb3J0IHsgYml0cywgZ3QsIGlzT2RkLCBpc1plcm8sIG11bCwgc2hpZnRSaWdodCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@zk-kit/eddsa-poseidon/node_modules/@zk-kit/utils/dist/lib.esm/scalar.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@zk-kit/eddsa-poseidon/node_modules/@zk-kit/utils/dist/lib.esm/type-checks.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@zk-kit/eddsa-poseidon/node_modules/@zk-kit/utils/dist/lib.esm/type-checks.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isArray: () => (/* binding */ isArray),\n/* harmony export */   isBigInt: () => (/* binding */ isBigInt),\n/* harmony export */   isBigNumber: () => (/* binding */ isBigNumber),\n/* harmony export */   isBigNumberish: () => (/* binding */ isBigNumberish),\n/* harmony export */   isBuffer: () => (/* binding */ isBuffer),\n/* harmony export */   isDefined: () => (/* binding */ isDefined),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isHexadecimal: () => (/* binding */ isHexadecimal),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   isStringifiedBigInt: () => (/* binding */ isStringifiedBigInt),\n/* harmony export */   isSupportedType: () => (/* binding */ isSupportedType),\n/* harmony export */   isType: () => (/* binding */ isType),\n/* harmony export */   isUint8Array: () => (/* binding */ isUint8Array),\n/* harmony export */   supportedTypes: () => (/* binding */ supportedTypes)\n/* harmony export */ });\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ \"buffer\");\n/**\n * @module @zk-kit/utils\n * @version 1.2.1\n * @file Essential zero-knowledge utility library for JavaScript developers.\n * @copyright Ethereum Foundation 2024\n * @license MIT\n * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/utils}\n*/\n\n\n/**\n * @module TypeChecks\n * This module provides utility functions to check data types.\n * It defines a set of supported types and includes functions to check if\n * a value is defined and if it matches a supported type. These functions\n * are useful for type checking and validation in the other libraries,\n * enhancing code robustness and reliability.\n */\n/** @internal */\nconst supportedTypes = [\n    \"number\",\n    \"string\",\n    \"function\",\n    \"Array\",\n    \"Uint8Array\",\n    \"Buffer\",\n    \"object\",\n    \"bigint\",\n    \"stringified-bigint\",\n    \"hexadecimal\",\n    \"bignumber\",\n    \"bignumberish\"\n];\n/**\n * Returns true if the value is defined, false otherwise.\n * @param value The value to be checked.\n */\nfunction isDefined(value) {\n    return typeof value !== \"undefined\";\n}\n/**\n * Returns true if the value is a number, false otherwise.\n * @param value The value to be checked.\n */\nfunction isNumber(value) {\n    return typeof value === \"number\";\n}\n/**\n * Returns true if the value is a string, false otherwise.\n * @param value The value to be checked.\n */\nfunction isString(value) {\n    return typeof value === \"string\";\n}\n/**\n * Returns true if the value is a function, false otherwise.\n * @param value The value to be checked.\n */\nfunction isFunction(value) {\n    return typeof value === \"function\";\n}\n/**\n * Returns true if the value is an object, false otherwise.\n * Please, note that arrays are also objects in JavaScript.\n * @param value The value to be checked.\n */\nfunction isObject(value) {\n    return typeof value === \"object\";\n}\n/**\n * Returns true if the value is an Array instance, false otherwise.\n * @param value The value to be checked.\n */\nfunction isArray(value) {\n    return isObject(value) && Array.isArray(value);\n}\n/**\n * Returns true if the value is a Uint8Array instance, false otherwise.\n * @param value The value to be checked.\n */\nfunction isUint8Array(value) {\n    return value instanceof Uint8Array;\n}\n/**\n * Returns true if the value is a Buffer instance, false otherwise.\n * @param value The value to be checked.\n */\nfunction isBuffer(value) {\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.isBuffer(value);\n}\n/**\n * Returns true if the value is a bigint, false otherwise.\n * @param value The value to be checked.\n */\nfunction isBigInt(value) {\n    return typeof value === \"bigint\";\n}\n/**\n * Checks if the given value is a string that represents a valid bigint.\n * @param value The value to be checked if it's a stringified bigint.\n */\nfunction isStringifiedBigInt(value) {\n    // Check if value is a string first.\n    if (!isString(value)) {\n        return false;\n    }\n    try {\n        // Attempt to convert the string to BigInt.\n        BigInt(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Checks if a string is a valid hexadecimal string representation.\n * If 'prefix' is 'true', the string must start with '0x' or '0X' followed by one or more\n * hexadecimal digits (0-9, a-f, A-F), otherwise no prefix is expected. 'prefix' is optional and\n * if its value it is not explicitly defined it will be set to 'true' by default.\n * @param value The string to be tested.\n * @param prefix A boolean to include or not a '0x' or '0X' prefix.\n */\nfunction isHexadecimal(value, prefix = true) {\n    if (!isString(value)) {\n        return false;\n    }\n    if (prefix) {\n        return /^(0x|0X)[0-9a-fA-F]+$/.test(value);\n    }\n    return /^[0-9a-fA-F]+$/.test(value);\n}\n/**\n * Checks if the given value can be considered as BigNumber.\n * A value is considered a BigNumber if it is a bigint or a string\n * that can be converted to a bigint (via `Bigint(s)`).\n * @param value The value to check.\n */\nfunction isBigNumber(value) {\n    return isBigInt(value) || isStringifiedBigInt(value);\n}\n/**\n * Checks if the given value can be considered as BigNumberish.\n * A value is considered BigNumberish if it meets\n * any of the following conditions: it's a number, a bigint, a string\n * that can be converted to a bigint, a hexadecimal\n * string, or a Buffer object.\n * @param value The value to check.\n */\nfunction isBigNumberish(value) {\n    return (isNumber(value) ||\n        isBigInt(value) ||\n        isStringifiedBigInt(value) ||\n        isHexadecimal(value) ||\n        isBuffer(value) ||\n        isUint8Array(value));\n}\n/**\n * Returns true if the value type is the same as the type passed\n * as the second parameter, false otherwise.\n * @param value\n * @param type The expected type.\n */\nfunction isType(value, type) {\n    switch (type) {\n        case \"number\":\n            return isNumber(value);\n        case \"string\":\n            return isString(value);\n        case \"function\":\n            return isFunction(value);\n        case \"Array\":\n            return isArray(value);\n        case \"Uint8Array\":\n            return isUint8Array(value);\n        case \"Buffer\":\n            return isBuffer(value);\n        case \"object\":\n            return isObject(value);\n        case \"bigint\":\n            return isBigInt(value);\n        case \"stringified-bigint\":\n            return isStringifiedBigInt(value);\n        case \"hexadecimal\":\n            return isHexadecimal(value);\n        case \"bignumber\":\n            return isBigNumber(value);\n        case \"bignumberish\":\n            return isBigNumberish(value);\n        default:\n            return false;\n    }\n}\n/**\n * Returns true if the type is being supported by this utility\n * functions, false otherwise.\n * @param type The type to be checked.\n */\nfunction isSupportedType(type) {\n    return supportedTypes.includes(type);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHprLWtpdC9lZGRzYS1wb3NlaWRvbi9ub2RlX21vZHVsZXMvQHprLWtpdC91dGlscy9kaXN0L2xpYi5lc20vdHlwZS1jaGVja3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMENBQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW9OIiwic291cmNlcyI6WyIvVXNlcnMvY2hhbmNlbWNhbGxpc3Rlci9Qcm9qZWN0cy96dXBhc3NodW50L25vZGVfbW9kdWxlcy9Aemsta2l0L2VkZHNhLXBvc2VpZG9uL25vZGVfbW9kdWxlcy9Aemsta2l0L3V0aWxzL2Rpc3QvbGliLmVzbS90eXBlLWNoZWNrcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgQHprLWtpdC91dGlsc1xuICogQHZlcnNpb24gMS4yLjFcbiAqIEBmaWxlIEVzc2VudGlhbCB6ZXJvLWtub3dsZWRnZSB1dGlsaXR5IGxpYnJhcnkgZm9yIEphdmFTY3JpcHQgZGV2ZWxvcGVycy5cbiAqIEBjb3B5cmlnaHQgRXRoZXJldW0gRm91bmRhdGlvbiAyMDI0XG4gKiBAbGljZW5zZSBNSVRcbiAqIEBzZWUgW0dpdGh1Yl17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3ByaXZhY3ktc2NhbGluZy1leHBsb3JhdGlvbnMvemsta2l0L3RyZWUvbWFpbi9wYWNrYWdlcy91dGlsc31cbiovXG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXInO1xuXG4vKipcbiAqIEBtb2R1bGUgVHlwZUNoZWNrc1xuICogVGhpcyBtb2R1bGUgcHJvdmlkZXMgdXRpbGl0eSBmdW5jdGlvbnMgdG8gY2hlY2sgZGF0YSB0eXBlcy5cbiAqIEl0IGRlZmluZXMgYSBzZXQgb2Ygc3VwcG9ydGVkIHR5cGVzIGFuZCBpbmNsdWRlcyBmdW5jdGlvbnMgdG8gY2hlY2sgaWZcbiAqIGEgdmFsdWUgaXMgZGVmaW5lZCBhbmQgaWYgaXQgbWF0Y2hlcyBhIHN1cHBvcnRlZCB0eXBlLiBUaGVzZSBmdW5jdGlvbnNcbiAqIGFyZSB1c2VmdWwgZm9yIHR5cGUgY2hlY2tpbmcgYW5kIHZhbGlkYXRpb24gaW4gdGhlIG90aGVyIGxpYnJhcmllcyxcbiAqIGVuaGFuY2luZyBjb2RlIHJvYnVzdG5lc3MgYW5kIHJlbGlhYmlsaXR5LlxuICovXG4vKiogQGludGVybmFsICovXG5jb25zdCBzdXBwb3J0ZWRUeXBlcyA9IFtcbiAgICBcIm51bWJlclwiLFxuICAgIFwic3RyaW5nXCIsXG4gICAgXCJmdW5jdGlvblwiLFxuICAgIFwiQXJyYXlcIixcbiAgICBcIlVpbnQ4QXJyYXlcIixcbiAgICBcIkJ1ZmZlclwiLFxuICAgIFwib2JqZWN0XCIsXG4gICAgXCJiaWdpbnRcIixcbiAgICBcInN0cmluZ2lmaWVkLWJpZ2ludFwiLFxuICAgIFwiaGV4YWRlY2ltYWxcIixcbiAgICBcImJpZ251bWJlclwiLFxuICAgIFwiYmlnbnVtYmVyaXNoXCJcbl07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgZGVmaW5lZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICovXG5mdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGlzIGEgbnVtYmVyLCBmYWxzZSBvdGhlcndpc2UuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIjtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZywgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBmdW5jdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogUGxlYXNlLCBub3RlIHRoYXQgYXJyYXlzIGFyZSBhbHNvIG9iamVjdHMgaW4gSmF2YVNjcmlwdC5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGlzIGFuIEFycmF5IGluc3RhbmNlLCBmYWxzZSBvdGhlcndpc2UuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIEFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGlzIGEgVWludDhBcnJheSBpbnN0YW5jZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICovXG5mdW5jdGlvbiBpc1VpbnQ4QXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGlzIGEgQnVmZmVyIGluc3RhbmNlLCBmYWxzZSBvdGhlcndpc2UuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKi9cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSk7XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBiaWdpbnQsIGZhbHNlIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqL1xuZnVuY3Rpb24gaXNCaWdJbnQodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBhIHZhbGlkIGJpZ2ludC5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgY2hlY2tlZCBpZiBpdCdzIGEgc3RyaW5naWZpZWQgYmlnaW50LlxuICovXG5mdW5jdGlvbiBpc1N0cmluZ2lmaWVkQmlnSW50KHZhbHVlKSB7XG4gICAgLy8gQ2hlY2sgaWYgdmFsdWUgaXMgYSBzdHJpbmcgZmlyc3QuXG4gICAgaWYgKCFpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyBBdHRlbXB0IHRvIGNvbnZlcnQgdGhlIHN0cmluZyB0byBCaWdJbnQuXG4gICAgICAgIEJpZ0ludCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIENoZWNrcyBpZiBhIHN0cmluZyBpcyBhIHZhbGlkIGhleGFkZWNpbWFsIHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAqIElmICdwcmVmaXgnIGlzICd0cnVlJywgdGhlIHN0cmluZyBtdXN0IHN0YXJ0IHdpdGggJzB4JyBvciAnMFgnIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlXG4gKiBoZXhhZGVjaW1hbCBkaWdpdHMgKDAtOSwgYS1mLCBBLUYpLCBvdGhlcndpc2Ugbm8gcHJlZml4IGlzIGV4cGVjdGVkLiAncHJlZml4JyBpcyBvcHRpb25hbCBhbmRcbiAqIGlmIGl0cyB2YWx1ZSBpdCBpcyBub3QgZXhwbGljaXRseSBkZWZpbmVkIGl0IHdpbGwgYmUgc2V0IHRvICd0cnVlJyBieSBkZWZhdWx0LlxuICogQHBhcmFtIHZhbHVlIFRoZSBzdHJpbmcgdG8gYmUgdGVzdGVkLlxuICogQHBhcmFtIHByZWZpeCBBIGJvb2xlYW4gdG8gaW5jbHVkZSBvciBub3QgYSAnMHgnIG9yICcwWCcgcHJlZml4LlxuICovXG5mdW5jdGlvbiBpc0hleGFkZWNpbWFsKHZhbHVlLCBwcmVmaXggPSB0cnVlKSB7XG4gICAgaWYgKCFpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAocHJlZml4KSB7XG4gICAgICAgIHJldHVybiAvXigweHwwWClbMC05YS1mQS1GXSskLy50ZXN0KHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIC9eWzAtOWEtZkEtRl0rJC8udGVzdCh2YWx1ZSk7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgY2FuIGJlIGNvbnNpZGVyZWQgYXMgQmlnTnVtYmVyLlxuICogQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGEgQmlnTnVtYmVyIGlmIGl0IGlzIGEgYmlnaW50IG9yIGEgc3RyaW5nXG4gKiB0aGF0IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYSBiaWdpbnQgKHZpYSBgQmlnaW50KHMpYCkuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICovXG5mdW5jdGlvbiBpc0JpZ051bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiBpc0JpZ0ludCh2YWx1ZSkgfHwgaXNTdHJpbmdpZmllZEJpZ0ludCh2YWx1ZSk7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgY2FuIGJlIGNvbnNpZGVyZWQgYXMgQmlnTnVtYmVyaXNoLlxuICogQSB2YWx1ZSBpcyBjb25zaWRlcmVkIEJpZ051bWJlcmlzaCBpZiBpdCBtZWV0c1xuICogYW55IG9mIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczogaXQncyBhIG51bWJlciwgYSBiaWdpbnQsIGEgc3RyaW5nXG4gKiB0aGF0IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYSBiaWdpbnQsIGEgaGV4YWRlY2ltYWxcbiAqIHN0cmluZywgb3IgYSBCdWZmZXIgb2JqZWN0LlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqL1xuZnVuY3Rpb24gaXNCaWdOdW1iZXJpc2godmFsdWUpIHtcbiAgICByZXR1cm4gKGlzTnVtYmVyKHZhbHVlKSB8fFxuICAgICAgICBpc0JpZ0ludCh2YWx1ZSkgfHxcbiAgICAgICAgaXNTdHJpbmdpZmllZEJpZ0ludCh2YWx1ZSkgfHxcbiAgICAgICAgaXNIZXhhZGVjaW1hbCh2YWx1ZSkgfHxcbiAgICAgICAgaXNCdWZmZXIodmFsdWUpIHx8XG4gICAgICAgIGlzVWludDhBcnJheSh2YWx1ZSkpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIHR5cGUgaXMgdGhlIHNhbWUgYXMgdGhlIHR5cGUgcGFzc2VkXG4gKiBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHBhcmFtIHZhbHVlXG4gKiBAcGFyYW0gdHlwZSBUaGUgZXhwZWN0ZWQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaXNUeXBlKHZhbHVlLCB0eXBlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIHJldHVybiBpc051bWJlcih2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBpc1N0cmluZyh2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24odmFsdWUpO1xuICAgICAgICBjYXNlIFwiQXJyYXlcIjpcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKTtcbiAgICAgICAgY2FzZSBcIlVpbnQ4QXJyYXlcIjpcbiAgICAgICAgICAgIHJldHVybiBpc1VpbnQ4QXJyYXkodmFsdWUpO1xuICAgICAgICBjYXNlIFwiQnVmZmVyXCI6XG4gICAgICAgICAgICByZXR1cm4gaXNCdWZmZXIodmFsdWUpO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpO1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgICAgICByZXR1cm4gaXNCaWdJbnQodmFsdWUpO1xuICAgICAgICBjYXNlIFwic3RyaW5naWZpZWQtYmlnaW50XCI6XG4gICAgICAgICAgICByZXR1cm4gaXNTdHJpbmdpZmllZEJpZ0ludCh2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJoZXhhZGVjaW1hbFwiOlxuICAgICAgICAgICAgcmV0dXJuIGlzSGV4YWRlY2ltYWwodmFsdWUpO1xuICAgICAgICBjYXNlIFwiYmlnbnVtYmVyXCI6XG4gICAgICAgICAgICByZXR1cm4gaXNCaWdOdW1iZXIodmFsdWUpO1xuICAgICAgICBjYXNlIFwiYmlnbnVtYmVyaXNoXCI6XG4gICAgICAgICAgICByZXR1cm4gaXNCaWdOdW1iZXJpc2godmFsdWUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB0eXBlIGlzIGJlaW5nIHN1cHBvcnRlZCBieSB0aGlzIHV0aWxpdHlcbiAqIGZ1bmN0aW9ucywgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgdG8gYmUgY2hlY2tlZC5cbiAqL1xuZnVuY3Rpb24gaXNTdXBwb3J0ZWRUeXBlKHR5cGUpIHtcbiAgICByZXR1cm4gc3VwcG9ydGVkVHlwZXMuaW5jbHVkZXModHlwZSk7XG59XG5cbmV4cG9ydCB7IGlzQXJyYXksIGlzQmlnSW50LCBpc0JpZ051bWJlciwgaXNCaWdOdW1iZXJpc2gsIGlzQnVmZmVyLCBpc0RlZmluZWQsIGlzRnVuY3Rpb24sIGlzSGV4YWRlY2ltYWwsIGlzTnVtYmVyLCBpc09iamVjdCwgaXNTdHJpbmcsIGlzU3RyaW5naWZpZWRCaWdJbnQsIGlzU3VwcG9ydGVkVHlwZSwgaXNUeXBlLCBpc1VpbnQ4QXJyYXksIHN1cHBvcnRlZFR5cGVzIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@zk-kit/eddsa-poseidon/node_modules/@zk-kit/utils/dist/lib.esm/type-checks.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@zk-kit/lean-imt/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@zk-kit/lean-imt/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LeanIMT: () => (/* binding */ LeanIMT)\n/* harmony export */ });\n/* harmony import */ var _zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zk-kit/utils/error-handlers */ \"(ssr)/./node_modules/@zk-kit/lean-imt/node_modules/@zk-kit/utils/dist/lib.esm/error-handlers.js\");\n/**\n * @module @zk-kit/lean-imt\n * @version 2.2.3\n * @file Lean Incremental Merkle tree implementation in TypeScript.\n * @copyright Ethereum Foundation 2025\n * @license MIT\n * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/lean-imt}\n*/\n\n\n/**\n * The {@link LeanIMT} is an optimized binary version of the {@link IMT}.\n * This implementation exclusively supports binary trees, eliminates the use of\n * zeroes, and the tree's {@link LeanIMT#depth} is dynamic. When a node doesn't have the right child,\n * instead of using a zero hash as in the IMT, the node's value becomes that\n * of its left child. Furthermore, rather than utilizing a static tree depth,\n * it is updated based on the number of {@link LeanIMT#leaves} in the tree. This approach\n * results in the calculation of significantly fewer hashes, making the tree more efficient.\n */\nclass LeanIMT {\n    /**\n     * It initializes the tree with a given hash function and an optional list of leaves.\n     * @param hash The hash function used to create nodes.\n     * @param leaves The list of leaves.\n     */\n    constructor(hash, leaves = []) {\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(hash, \"hash\");\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireFunction)(hash, \"hash\");\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireArray)(leaves, \"leaves\");\n        // Initialize the attributes.\n        this._nodes = [[]];\n        this._hash = hash;\n        // Initialize the tree with a list of leaves if there are any.\n        if (leaves.length > 0) {\n            this.insertMany(leaves);\n        }\n    }\n    /**\n     * The root of the tree. This value doesn't need to be stored as\n     * it is always the first and unique element of the last level of the tree.\n     * Its value can be retrieved in {@link LeanIMT#_nodes}.\n     * @returns The root hash of the tree.\n     */\n    get root() {\n        return this._nodes[this.depth][0];\n    }\n    /**\n     * The depth of the tree, which equals the number of levels - 1.\n     * @returns The depth of the tree.\n     */\n    get depth() {\n        return this._nodes.length - 1;\n    }\n    /**\n     * The leaves of the tree. They can be retrieved from the first\n     * level of the tree using {@link LeanIMT#_nodes}. The returned\n     * value is a copy of the array and not the original object.\n     * @returns The list of tree leaves.\n     */\n    get leaves() {\n        return this._nodes[0].slice();\n    }\n    /**\n     * The size of the tree, which the number of its leaves.\n     * It's the length of the first level's list.\n     * @returns The number of leaves of the tree.\n     */\n    get size() {\n        return this._nodes[0].length;\n    }\n    /**\n     * It returns the index of a leaf. If the leaf does not exist it returns -1.\n     * @param leaf A leaf of the tree.\n     * @returns The index of the leaf.\n     */\n    indexOf(leaf) {\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(leaf, \"leaf\");\n        return this._nodes[0].indexOf(leaf);\n    }\n    /**\n     * It returns true if the leaf exists, and false otherwise\n     * @param leaf A leaf of the tree.\n     * @returns True if the tree has the leaf, and false otherwise.\n     */\n    has(leaf) {\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(leaf, \"leaf\");\n        return this._nodes[0].includes(leaf);\n    }\n    /**\n     * The leaves are inserted incrementally. If 'i' is the index of the last\n     * leaf, the new one will be inserted at position 'i + 1'. Every time a\n     * new leaf is inserted, the nodes that separate the new leaf from the root\n     * of the tree are created or updated if they already exist, from bottom to top.\n     * When a node has only one child (the left one), its value takes on the value\n     * of the child. Otherwise, the hash of the children is calculated.\n     * @param leaf The new leaf to be inserted in the tree.\n     */\n    insert(leaf) {\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(leaf, \"leaf\");\n        // If the next depth is greater, a new tree level will be added.\n        if (this.depth < Math.ceil(Math.log2(this.size + 1))) {\n            // Adding an array is like adding a new level.\n            this._nodes.push([]);\n        }\n        let node = leaf;\n        // The index of the new leaf equals the number of leaves in the tree.\n        let index = this.size;\n        for (let level = 0; level < this.depth; level += 1) {\n            this._nodes[level][index] = node;\n            // Bitwise AND, 0 -> left or 1 -> right.\n            // If the node is a right node the parent node will be the hash\n            // of the child nodes. Otherwise, parent will equal left child node.\n            if (index & 1) {\n                const sibling = this._nodes[level][index - 1];\n                node = this._hash(sibling, node);\n            }\n            // Right shift, it divides a number by 2 and discards the remainder.\n            index >>= 1;\n        }\n        // Store the new root.\n        this._nodes[this.depth] = [node];\n    }\n    /**\n     * This function is useful when you want to insert N leaves all at once.\n     * It is more efficient than using the {@link LeanIMT#insert} method N times because it\n     * significantly reduces the number of cases where a node has only one\n     * child, which is a common occurrence in gradual insertion.\n     * @param leaves The list of leaves to be inserted.\n     */\n    insertMany(leaves) {\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(leaves, \"leaves\");\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireArray)(leaves, \"leaves\");\n        if (leaves.length === 0) {\n            throw new Error(\"There are no leaves to add\");\n        }\n        let startIndex = this.size >> 1;\n        this._nodes[0] = this._nodes[0].concat(leaves);\n        // Calculate how many tree levels will need to be added\n        // using the number of leaves.\n        const numberOfNewLevels = Math.ceil(Math.log2(this.size)) - this.depth;\n        // Add the new levels.\n        for (let i = 0; i < numberOfNewLevels; i += 1) {\n            this._nodes.push([]);\n        }\n        for (let level = 0; level < this.depth; level += 1) {\n            // Calculate the number of nodes of the next level.\n            const numberOfNodes = Math.ceil(this._nodes[level].length / 2);\n            for (let index = startIndex; index < numberOfNodes; index += 1) {\n                const rightNode = this._nodes[level][index * 2 + 1];\n                const leftNode = this._nodes[level][index * 2];\n                const parentNode = rightNode ? this._hash(leftNode, rightNode) : leftNode;\n                this._nodes[level + 1][index] = parentNode;\n            }\n            startIndex >>= 1;\n        }\n    }\n    /**\n     * It updates a leaf in the tree. It's very similar to the {@link LeanIMT#insert} function.\n     * @param index The index of the leaf to be updated.\n     * @param newLeaf The new leaf to be inserted.\n     */\n    update(index, newLeaf) {\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(index, \"index\");\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(newLeaf, \"newLeaf\");\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireNumber)(index, \"index\");\n        let node = newLeaf;\n        for (let level = 0; level < this.depth; level += 1) {\n            this._nodes[level][index] = node;\n            if (index & 1) {\n                const sibling = this._nodes[level][index - 1];\n                node = this._hash(sibling, node);\n            }\n            else {\n                // In this case there could still be a right node\n                // because the path might not be the rightmost one\n                // (like the 'insert' function).\n                const sibling = this._nodes[level][index + 1];\n                // If the sibling node does not exist, it means that the node at\n                // this level has the same value as its child. Therefore, there\n                // no hash to calculate.\n                if (sibling !== undefined) {\n                    node = this._hash(node, sibling);\n                }\n            }\n            index >>= 1;\n        }\n        this._nodes[this.depth] = [node];\n    }\n    /**\n     * Updates m leaves all at once.\n     * It is more efficient than using the {@link LeanIMT#update} method m times because it\n     * prevents updating middle nodes several times. This would happen when updating leaves\n     * with common ancestors. The naive approach of calling 'update' m times has complexity\n     * O(m*log(n)) (where n is the number of leaves of the tree), which ends up in\n     * O(n*log(n)) when m ~ n. With this new approach, this ends up being O(n) because every\n     * node is updated at most once and there are around 2*n nodes in the tree.\n     * @param indices The list of indices of the respective leaves.\n     * @param leaves The list of leaves to be updated.\n     */\n    updateMany(indices, leaves) {\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(leaves, \"leaves\");\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(indices, \"indices\");\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireArray)(leaves, \"leaves\");\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireArray)(indices, \"indices\");\n        if (leaves.length !== indices.length) {\n            throw new Error(\"There is no correspondence between indices and leaves\");\n        }\n        // This will keep track of the outdated nodes of each level.\n        let modifiedIndices = new Set();\n        for (let i = 0; i < indices.length; i += 1) {\n            (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireNumber)(indices[i], `index ${i}`);\n            if (indices[i] < 0 || indices[i] >= this.size) {\n                throw new Error(`Index ${i} is out of range`);\n            }\n            if (modifiedIndices.has(indices[i])) {\n                throw new Error(`Leaf ${indices[i]} is repeated`);\n            }\n            modifiedIndices.add(indices[i]);\n        }\n        modifiedIndices.clear();\n        // First, modify the first level, which consists only of raw, un-hashed values\n        for (let leaf = 0; leaf < indices.length; leaf += 1) {\n            this._nodes[0][indices[leaf]] = leaves[leaf];\n            modifiedIndices.add(indices[leaf] >> 1);\n        }\n        // Now update each node of the corresponding levels\n        for (let level = 1; level <= this.depth; level += 1) {\n            const newModifiedIndices = [];\n            for (const index of modifiedIndices) {\n                const leftChild = this._nodes[level - 1][2 * index];\n                const rightChild = this._nodes[level - 1][2 * index + 1];\n                this._nodes[level][index] = rightChild ? this._hash(leftChild, rightChild) : leftChild;\n                newModifiedIndices.push(index >> 1);\n            }\n            modifiedIndices = new Set(newModifiedIndices);\n        }\n    }\n    /**\n     * It generates a {@link LeanIMTMerkleProof} for a leaf of the tree.\n     * That proof can be verified by this tree using the same hash function.\n     * @param index The index of the leaf for which a Merkle proof will be generated.\n     * @returns The Merkle proof of the leaf.\n     */\n    generateProof(index) {\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(index, \"index\");\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireNumber)(index, \"index\");\n        if (index < 0 || index >= this.size) {\n            throw new Error(`The leaf at index '${index}' does not exist in this tree`);\n        }\n        const leaf = this.leaves[index];\n        const siblings = [];\n        const path = [];\n        for (let level = 0; level < this.depth; level += 1) {\n            const isRightNode = index & 1;\n            const siblingIndex = isRightNode ? index - 1 : index + 1;\n            const sibling = this._nodes[level][siblingIndex];\n            // If the sibling node does not exist, it means that the node at\n            // this level has the same value as its child. Therefore, there\n            // is no need to include it in the proof since there is no hash to calculate.\n            if (sibling !== undefined) {\n                path.push(isRightNode);\n                siblings.push(sibling);\n            }\n            index >>= 1;\n        }\n        // The index might be different from the original index of the leaf, since\n        // in some cases some siblings are not included (as explained above).\n        return { root: this.root, leaf, index: Number.parseInt(path.reverse().join(\"\"), 2), siblings };\n    }\n    /**\n     * It verifies a {@link LeanIMTMerkleProof} to confirm that a leaf indeed\n     * belongs to a tree.  Does not verify that the node belongs to this\n     * tree in particular.  Equivalent to\n     * `LeanIMT.verifyProof(proof, this._hash)`.\n     * @param proof The Merkle tree proof.\n     * @returns True if the leaf is part of the tree, and false otherwise.\n     */\n    verifyProof(proof) {\n        return LeanIMT.verifyProof(proof, this._hash);\n    }\n    /**\n     * It verifies a {@link LeanIMTMerkleProof} to confirm that a leaf indeed\n     * belongs to a tree.\n     * @param proof The Merkle tree proof.\n     * @returns True if the leaf is part of the tree, and false otherwise.\n     */\n    static verifyProof(proof, hash) {\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(proof, \"proof\");\n        const { root, leaf, siblings, index } = proof;\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(proof.root, \"proof.root\");\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(proof.leaf, \"proof.leaf\");\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(proof.siblings, \"proof.siblings\");\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(proof.index, \"proof.index\");\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireArray)(proof.siblings, \"proof.siblings\");\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireNumber)(proof.index, \"proof.index\");\n        let node = leaf;\n        for (let i = 0; i < siblings.length; i += 1) {\n            if ((index >> i) & 1) {\n                node = hash(siblings[i], node);\n            }\n            else {\n                node = hash(node, siblings[i]);\n            }\n        }\n        return root === node;\n    }\n    /**\n     * It enables the conversion of the full tree structure into a JSON string,\n     * facilitating future imports of the tree. This approach is beneficial for\n     * large trees, as it saves time by storing hashes instead of recomputing them\n     * @returns The stringified JSON of the tree.\n     */\n    export() {\n        return JSON.stringify(this._nodes, (_, v) => (typeof v === \"bigint\" ? v.toString() : v));\n    }\n    /**\n     * It imports an entire tree by initializing the nodes without calculating\n     * any hashes. Note that it is crucial to ensure the integrity of the tree\n     * before or after importing it. If the map function is not defined, node\n     * values will be converted to bigints by default.\n     * @param hash The hash function used to create nodes.\n     * @param nodes The stringified JSON of the tree.\n     * @param map A function to map each node of the tree and convert their types.\n     * @returns A LeanIMT instance.\n     */\n    static import(hash, nodes, map) {\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(hash, \"hash\");\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(nodes, \"nodes\");\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireFunction)(hash, \"hash\");\n        (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireString)(nodes, \"nodes\");\n        if (map) {\n            (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireDefined)(map, \"map\");\n            (0,_zk_kit_utils_error_handlers__WEBPACK_IMPORTED_MODULE_0__.requireFunction)(map, \"map\");\n        }\n        const tree = new LeanIMT(hash);\n        tree._nodes = JSON.parse(nodes, (_, value) => {\n            if (typeof value === \"string\") {\n                return map ? map(value) : BigInt(value);\n            }\n            return value;\n        });\n        return tree;\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHprLWtpdC9sZWFuLWltdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQzJIOztBQUUzSDtBQUNBLFFBQVEsZUFBZSx1Q0FBdUMsVUFBVTtBQUN4RTtBQUNBLDJCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBLHlDQUF5QyxzQkFBc0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0RUFBYztBQUN0QixRQUFRLDZFQUFlO0FBQ3ZCLFFBQVEsMEVBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxQkFBcUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNEVBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNEVBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0RUFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxzQkFBc0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNEVBQWM7QUFDdEIsUUFBUSwwRUFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQSx5Q0FBeUMsdUJBQXVCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxzQkFBc0I7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDRFQUFjO0FBQ3RCLFFBQVEsNEVBQWM7QUFDdEIsUUFBUSwyRUFBYTtBQUNyQjtBQUNBLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxzQkFBc0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0RUFBYztBQUN0QixRQUFRLDRFQUFjO0FBQ3RCLFFBQVEsMEVBQVk7QUFDcEIsUUFBUSwwRUFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QyxZQUFZLDJFQUFhLHNCQUFzQixFQUFFO0FBQ2pEO0FBQ0EseUNBQXlDLEdBQUc7QUFDNUM7QUFDQTtBQUNBLHdDQUF3QyxZQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBCQUEwQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0RUFBYztBQUN0QixRQUFRLDJFQUFhO0FBQ3JCO0FBQ0Esa0RBQWtELE1BQU07QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHNCQUFzQiwwQkFBMEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDRFQUFjO0FBQ3RCLGdCQUFnQiw4QkFBOEI7QUFDOUMsUUFBUSw0RUFBYztBQUN0QixRQUFRLDRFQUFjO0FBQ3RCLFFBQVEsNEVBQWM7QUFDdEIsUUFBUSw0RUFBYztBQUN0QixRQUFRLDBFQUFZO0FBQ3BCLFFBQVEsMkVBQWE7QUFDckI7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDRFQUFjO0FBQ3RCLFFBQVEsNEVBQWM7QUFDdEIsUUFBUSw2RUFBZTtBQUN2QixRQUFRLDJFQUFhO0FBQ3JCO0FBQ0EsWUFBWSw0RUFBYztBQUMxQixZQUFZLDZFQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFbUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jaGFuY2VtY2FsbGlzdGVyL1Byb2plY3RzL3p1cGFzc2h1bnQvbm9kZV9tb2R1bGVzL0B6ay1raXQvbGVhbi1pbXQvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgQHprLWtpdC9sZWFuLWltdFxuICogQHZlcnNpb24gMi4yLjNcbiAqIEBmaWxlIExlYW4gSW5jcmVtZW50YWwgTWVya2xlIHRyZWUgaW1wbGVtZW50YXRpb24gaW4gVHlwZVNjcmlwdC5cbiAqIEBjb3B5cmlnaHQgRXRoZXJldW0gRm91bmRhdGlvbiAyMDI1XG4gKiBAbGljZW5zZSBNSVRcbiAqIEBzZWUgW0dpdGh1Yl17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3ByaXZhY3ktc2NhbGluZy1leHBsb3JhdGlvbnMvemsta2l0L3RyZWUvbWFpbi9wYWNrYWdlcy9sZWFuLWltdH1cbiovXG5pbXBvcnQgeyByZXF1aXJlRGVmaW5lZCwgcmVxdWlyZUZ1bmN0aW9uLCByZXF1aXJlQXJyYXksIHJlcXVpcmVOdW1iZXIsIHJlcXVpcmVTdHJpbmcgfSBmcm9tICdAemsta2l0L3V0aWxzL2Vycm9yLWhhbmRsZXJzJztcblxuLyoqXG4gKiBUaGUge0BsaW5rIExlYW5JTVR9IGlzIGFuIG9wdGltaXplZCBiaW5hcnkgdmVyc2lvbiBvZiB0aGUge0BsaW5rIElNVH0uXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIGV4Y2x1c2l2ZWx5IHN1cHBvcnRzIGJpbmFyeSB0cmVlcywgZWxpbWluYXRlcyB0aGUgdXNlIG9mXG4gKiB6ZXJvZXMsIGFuZCB0aGUgdHJlZSdzIHtAbGluayBMZWFuSU1UI2RlcHRofSBpcyBkeW5hbWljLiBXaGVuIGEgbm9kZSBkb2Vzbid0IGhhdmUgdGhlIHJpZ2h0IGNoaWxkLFxuICogaW5zdGVhZCBvZiB1c2luZyBhIHplcm8gaGFzaCBhcyBpbiB0aGUgSU1ULCB0aGUgbm9kZSdzIHZhbHVlIGJlY29tZXMgdGhhdFxuICogb2YgaXRzIGxlZnQgY2hpbGQuIEZ1cnRoZXJtb3JlLCByYXRoZXIgdGhhbiB1dGlsaXppbmcgYSBzdGF0aWMgdHJlZSBkZXB0aCxcbiAqIGl0IGlzIHVwZGF0ZWQgYmFzZWQgb24gdGhlIG51bWJlciBvZiB7QGxpbmsgTGVhbklNVCNsZWF2ZXN9IGluIHRoZSB0cmVlLiBUaGlzIGFwcHJvYWNoXG4gKiByZXN1bHRzIGluIHRoZSBjYWxjdWxhdGlvbiBvZiBzaWduaWZpY2FudGx5IGZld2VyIGhhc2hlcywgbWFraW5nIHRoZSB0cmVlIG1vcmUgZWZmaWNpZW50LlxuICovXG5jbGFzcyBMZWFuSU1UIHtcbiAgICAvKipcbiAgICAgKiBJdCBpbml0aWFsaXplcyB0aGUgdHJlZSB3aXRoIGEgZ2l2ZW4gaGFzaCBmdW5jdGlvbiBhbmQgYW4gb3B0aW9uYWwgbGlzdCBvZiBsZWF2ZXMuXG4gICAgICogQHBhcmFtIGhhc2ggVGhlIGhhc2ggZnVuY3Rpb24gdXNlZCB0byBjcmVhdGUgbm9kZXMuXG4gICAgICogQHBhcmFtIGxlYXZlcyBUaGUgbGlzdCBvZiBsZWF2ZXMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaGFzaCwgbGVhdmVzID0gW10pIHtcbiAgICAgICAgcmVxdWlyZURlZmluZWQoaGFzaCwgXCJoYXNoXCIpO1xuICAgICAgICByZXF1aXJlRnVuY3Rpb24oaGFzaCwgXCJoYXNoXCIpO1xuICAgICAgICByZXF1aXJlQXJyYXkobGVhdmVzLCBcImxlYXZlc1wiKTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgYXR0cmlidXRlcy5cbiAgICAgICAgdGhpcy5fbm9kZXMgPSBbW11dO1xuICAgICAgICB0aGlzLl9oYXNoID0gaGFzaDtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgdHJlZSB3aXRoIGEgbGlzdCBvZiBsZWF2ZXMgaWYgdGhlcmUgYXJlIGFueS5cbiAgICAgICAgaWYgKGxlYXZlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmluc2VydE1hbnkobGVhdmVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcm9vdCBvZiB0aGUgdHJlZS4gVGhpcyB2YWx1ZSBkb2Vzbid0IG5lZWQgdG8gYmUgc3RvcmVkIGFzXG4gICAgICogaXQgaXMgYWx3YXlzIHRoZSBmaXJzdCBhbmQgdW5pcXVlIGVsZW1lbnQgb2YgdGhlIGxhc3QgbGV2ZWwgb2YgdGhlIHRyZWUuXG4gICAgICogSXRzIHZhbHVlIGNhbiBiZSByZXRyaWV2ZWQgaW4ge0BsaW5rIExlYW5JTVQjX25vZGVzfS5cbiAgICAgKiBAcmV0dXJucyBUaGUgcm9vdCBoYXNoIG9mIHRoZSB0cmVlLlxuICAgICAqL1xuICAgIGdldCByb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbm9kZXNbdGhpcy5kZXB0aF1bMF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBkZXB0aCBvZiB0aGUgdHJlZSwgd2hpY2ggZXF1YWxzIHRoZSBudW1iZXIgb2YgbGV2ZWxzIC0gMS5cbiAgICAgKiBAcmV0dXJucyBUaGUgZGVwdGggb2YgdGhlIHRyZWUuXG4gICAgICovXG4gICAgZ2V0IGRlcHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbm9kZXMubGVuZ3RoIC0gMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGxlYXZlcyBvZiB0aGUgdHJlZS4gVGhleSBjYW4gYmUgcmV0cmlldmVkIGZyb20gdGhlIGZpcnN0XG4gICAgICogbGV2ZWwgb2YgdGhlIHRyZWUgdXNpbmcge0BsaW5rIExlYW5JTVQjX25vZGVzfS4gVGhlIHJldHVybmVkXG4gICAgICogdmFsdWUgaXMgYSBjb3B5IG9mIHRoZSBhcnJheSBhbmQgbm90IHRoZSBvcmlnaW5hbCBvYmplY3QuXG4gICAgICogQHJldHVybnMgVGhlIGxpc3Qgb2YgdHJlZSBsZWF2ZXMuXG4gICAgICovXG4gICAgZ2V0IGxlYXZlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vZGVzWzBdLnNsaWNlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBzaXplIG9mIHRoZSB0cmVlLCB3aGljaCB0aGUgbnVtYmVyIG9mIGl0cyBsZWF2ZXMuXG4gICAgICogSXQncyB0aGUgbGVuZ3RoIG9mIHRoZSBmaXJzdCBsZXZlbCdzIGxpc3QuXG4gICAgICogQHJldHVybnMgVGhlIG51bWJlciBvZiBsZWF2ZXMgb2YgdGhlIHRyZWUuXG4gICAgICovXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub2Rlc1swXS5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEl0IHJldHVybnMgdGhlIGluZGV4IG9mIGEgbGVhZi4gSWYgdGhlIGxlYWYgZG9lcyBub3QgZXhpc3QgaXQgcmV0dXJucyAtMS5cbiAgICAgKiBAcGFyYW0gbGVhZiBBIGxlYWYgb2YgdGhlIHRyZWUuXG4gICAgICogQHJldHVybnMgVGhlIGluZGV4IG9mIHRoZSBsZWFmLlxuICAgICAqL1xuICAgIGluZGV4T2YobGVhZikge1xuICAgICAgICByZXF1aXJlRGVmaW5lZChsZWFmLCBcImxlYWZcIik7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub2Rlc1swXS5pbmRleE9mKGxlYWYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdCByZXR1cm5zIHRydWUgaWYgdGhlIGxlYWYgZXhpc3RzLCBhbmQgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICogQHBhcmFtIGxlYWYgQSBsZWFmIG9mIHRoZSB0cmVlLlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHRyZWUgaGFzIHRoZSBsZWFmLCBhbmQgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGhhcyhsZWFmKSB7XG4gICAgICAgIHJlcXVpcmVEZWZpbmVkKGxlYWYsIFwibGVhZlwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vZGVzWzBdLmluY2x1ZGVzKGxlYWYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbGVhdmVzIGFyZSBpbnNlcnRlZCBpbmNyZW1lbnRhbGx5LiBJZiAnaScgaXMgdGhlIGluZGV4IG9mIHRoZSBsYXN0XG4gICAgICogbGVhZiwgdGhlIG5ldyBvbmUgd2lsbCBiZSBpbnNlcnRlZCBhdCBwb3NpdGlvbiAnaSArIDEnLiBFdmVyeSB0aW1lIGFcbiAgICAgKiBuZXcgbGVhZiBpcyBpbnNlcnRlZCwgdGhlIG5vZGVzIHRoYXQgc2VwYXJhdGUgdGhlIG5ldyBsZWFmIGZyb20gdGhlIHJvb3RcbiAgICAgKiBvZiB0aGUgdHJlZSBhcmUgY3JlYXRlZCBvciB1cGRhdGVkIGlmIHRoZXkgYWxyZWFkeSBleGlzdCwgZnJvbSBib3R0b20gdG8gdG9wLlxuICAgICAqIFdoZW4gYSBub2RlIGhhcyBvbmx5IG9uZSBjaGlsZCAodGhlIGxlZnQgb25lKSwgaXRzIHZhbHVlIHRha2VzIG9uIHRoZSB2YWx1ZVxuICAgICAqIG9mIHRoZSBjaGlsZC4gT3RoZXJ3aXNlLCB0aGUgaGFzaCBvZiB0aGUgY2hpbGRyZW4gaXMgY2FsY3VsYXRlZC5cbiAgICAgKiBAcGFyYW0gbGVhZiBUaGUgbmV3IGxlYWYgdG8gYmUgaW5zZXJ0ZWQgaW4gdGhlIHRyZWUuXG4gICAgICovXG4gICAgaW5zZXJ0KGxlYWYpIHtcbiAgICAgICAgcmVxdWlyZURlZmluZWQobGVhZiwgXCJsZWFmXCIpO1xuICAgICAgICAvLyBJZiB0aGUgbmV4dCBkZXB0aCBpcyBncmVhdGVyLCBhIG5ldyB0cmVlIGxldmVsIHdpbGwgYmUgYWRkZWQuXG4gICAgICAgIGlmICh0aGlzLmRlcHRoIDwgTWF0aC5jZWlsKE1hdGgubG9nMih0aGlzLnNpemUgKyAxKSkpIHtcbiAgICAgICAgICAgIC8vIEFkZGluZyBhbiBhcnJheSBpcyBsaWtlIGFkZGluZyBhIG5ldyBsZXZlbC5cbiAgICAgICAgICAgIHRoaXMuX25vZGVzLnB1c2goW10pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBub2RlID0gbGVhZjtcbiAgICAgICAgLy8gVGhlIGluZGV4IG9mIHRoZSBuZXcgbGVhZiBlcXVhbHMgdGhlIG51bWJlciBvZiBsZWF2ZXMgaW4gdGhlIHRyZWUuXG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuc2l6ZTtcbiAgICAgICAgZm9yIChsZXQgbGV2ZWwgPSAwOyBsZXZlbCA8IHRoaXMuZGVwdGg7IGxldmVsICs9IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX25vZGVzW2xldmVsXVtpbmRleF0gPSBub2RlO1xuICAgICAgICAgICAgLy8gQml0d2lzZSBBTkQsIDAgLT4gbGVmdCBvciAxIC0+IHJpZ2h0LlxuICAgICAgICAgICAgLy8gSWYgdGhlIG5vZGUgaXMgYSByaWdodCBub2RlIHRoZSBwYXJlbnQgbm9kZSB3aWxsIGJlIHRoZSBoYXNoXG4gICAgICAgICAgICAvLyBvZiB0aGUgY2hpbGQgbm9kZXMuIE90aGVyd2lzZSwgcGFyZW50IHdpbGwgZXF1YWwgbGVmdCBjaGlsZCBub2RlLlxuICAgICAgICAgICAgaWYgKGluZGV4ICYgMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSB0aGlzLl9ub2Rlc1tsZXZlbF1baW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICBub2RlID0gdGhpcy5faGFzaChzaWJsaW5nLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJpZ2h0IHNoaWZ0LCBpdCBkaXZpZGVzIGEgbnVtYmVyIGJ5IDIgYW5kIGRpc2NhcmRzIHRoZSByZW1haW5kZXIuXG4gICAgICAgICAgICBpbmRleCA+Pj0gMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdG9yZSB0aGUgbmV3IHJvb3QuXG4gICAgICAgIHRoaXMuX25vZGVzW3RoaXMuZGVwdGhdID0gW25vZGVdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIGluc2VydCBOIGxlYXZlcyBhbGwgYXQgb25jZS5cbiAgICAgKiBJdCBpcyBtb3JlIGVmZmljaWVudCB0aGFuIHVzaW5nIHRoZSB7QGxpbmsgTGVhbklNVCNpbnNlcnR9IG1ldGhvZCBOIHRpbWVzIGJlY2F1c2UgaXRcbiAgICAgKiBzaWduaWZpY2FudGx5IHJlZHVjZXMgdGhlIG51bWJlciBvZiBjYXNlcyB3aGVyZSBhIG5vZGUgaGFzIG9ubHkgb25lXG4gICAgICogY2hpbGQsIHdoaWNoIGlzIGEgY29tbW9uIG9jY3VycmVuY2UgaW4gZ3JhZHVhbCBpbnNlcnRpb24uXG4gICAgICogQHBhcmFtIGxlYXZlcyBUaGUgbGlzdCBvZiBsZWF2ZXMgdG8gYmUgaW5zZXJ0ZWQuXG4gICAgICovXG4gICAgaW5zZXJ0TWFueShsZWF2ZXMpIHtcbiAgICAgICAgcmVxdWlyZURlZmluZWQobGVhdmVzLCBcImxlYXZlc1wiKTtcbiAgICAgICAgcmVxdWlyZUFycmF5KGxlYXZlcywgXCJsZWF2ZXNcIik7XG4gICAgICAgIGlmIChsZWF2ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSBhcmUgbm8gbGVhdmVzIHRvIGFkZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IHRoaXMuc2l6ZSA+PiAxO1xuICAgICAgICB0aGlzLl9ub2Rlc1swXSA9IHRoaXMuX25vZGVzWzBdLmNvbmNhdChsZWF2ZXMpO1xuICAgICAgICAvLyBDYWxjdWxhdGUgaG93IG1hbnkgdHJlZSBsZXZlbHMgd2lsbCBuZWVkIHRvIGJlIGFkZGVkXG4gICAgICAgIC8vIHVzaW5nIHRoZSBudW1iZXIgb2YgbGVhdmVzLlxuICAgICAgICBjb25zdCBudW1iZXJPZk5ld0xldmVscyA9IE1hdGguY2VpbChNYXRoLmxvZzIodGhpcy5zaXplKSkgLSB0aGlzLmRlcHRoO1xuICAgICAgICAvLyBBZGQgdGhlIG5ldyBsZXZlbHMuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZOZXdMZXZlbHM7IGkgKz0gMSkge1xuICAgICAgICAgICAgdGhpcy5fbm9kZXMucHVzaChbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbGV2ZWwgPSAwOyBsZXZlbCA8IHRoaXMuZGVwdGg7IGxldmVsICs9IDEpIHtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIG5vZGVzIG9mIHRoZSBuZXh0IGxldmVsLlxuICAgICAgICAgICAgY29uc3QgbnVtYmVyT2ZOb2RlcyA9IE1hdGguY2VpbCh0aGlzLl9ub2Rlc1tsZXZlbF0ubGVuZ3RoIC8gMik7XG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IHN0YXJ0SW5kZXg7IGluZGV4IDwgbnVtYmVyT2ZOb2RlczsgaW5kZXggKz0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0Tm9kZSA9IHRoaXMuX25vZGVzW2xldmVsXVtpbmRleCAqIDIgKyAxXTtcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0Tm9kZSA9IHRoaXMuX25vZGVzW2xldmVsXVtpbmRleCAqIDJdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSByaWdodE5vZGUgPyB0aGlzLl9oYXNoKGxlZnROb2RlLCByaWdodE5vZGUpIDogbGVmdE5vZGU7XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9kZXNbbGV2ZWwgKyAxXVtpbmRleF0gPSBwYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnRJbmRleCA+Pj0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdCB1cGRhdGVzIGEgbGVhZiBpbiB0aGUgdHJlZS4gSXQncyB2ZXJ5IHNpbWlsYXIgdG8gdGhlIHtAbGluayBMZWFuSU1UI2luc2VydH0gZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbGVhZiB0byBiZSB1cGRhdGVkLlxuICAgICAqIEBwYXJhbSBuZXdMZWFmIFRoZSBuZXcgbGVhZiB0byBiZSBpbnNlcnRlZC5cbiAgICAgKi9cbiAgICB1cGRhdGUoaW5kZXgsIG5ld0xlYWYpIHtcbiAgICAgICAgcmVxdWlyZURlZmluZWQoaW5kZXgsIFwiaW5kZXhcIik7XG4gICAgICAgIHJlcXVpcmVEZWZpbmVkKG5ld0xlYWYsIFwibmV3TGVhZlwiKTtcbiAgICAgICAgcmVxdWlyZU51bWJlcihpbmRleCwgXCJpbmRleFwiKTtcbiAgICAgICAgbGV0IG5vZGUgPSBuZXdMZWFmO1xuICAgICAgICBmb3IgKGxldCBsZXZlbCA9IDA7IGxldmVsIDwgdGhpcy5kZXB0aDsgbGV2ZWwgKz0gMSkge1xuICAgICAgICAgICAgdGhpcy5fbm9kZXNbbGV2ZWxdW2luZGV4XSA9IG5vZGU7XG4gICAgICAgICAgICBpZiAoaW5kZXggJiAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2libGluZyA9IHRoaXMuX25vZGVzW2xldmVsXVtpbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLl9oYXNoKHNpYmxpbmcsIG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlIHRoZXJlIGNvdWxkIHN0aWxsIGJlIGEgcmlnaHQgbm9kZVxuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhlIHBhdGggbWlnaHQgbm90IGJlIHRoZSByaWdodG1vc3Qgb25lXG4gICAgICAgICAgICAgICAgLy8gKGxpa2UgdGhlICdpbnNlcnQnIGZ1bmN0aW9uKS5cbiAgICAgICAgICAgICAgICBjb25zdCBzaWJsaW5nID0gdGhpcy5fbm9kZXNbbGV2ZWxdW2luZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHNpYmxpbmcgbm9kZSBkb2VzIG5vdCBleGlzdCwgaXQgbWVhbnMgdGhhdCB0aGUgbm9kZSBhdFxuICAgICAgICAgICAgICAgIC8vIHRoaXMgbGV2ZWwgaGFzIHRoZSBzYW1lIHZhbHVlIGFzIGl0cyBjaGlsZC4gVGhlcmVmb3JlLCB0aGVyZVxuICAgICAgICAgICAgICAgIC8vIG5vIGhhc2ggdG8gY2FsY3VsYXRlLlxuICAgICAgICAgICAgICAgIGlmIChzaWJsaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHRoaXMuX2hhc2gobm9kZSwgc2libGluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXggPj49IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbm9kZXNbdGhpcy5kZXB0aF0gPSBbbm9kZV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgbSBsZWF2ZXMgYWxsIGF0IG9uY2UuXG4gICAgICogSXQgaXMgbW9yZSBlZmZpY2llbnQgdGhhbiB1c2luZyB0aGUge0BsaW5rIExlYW5JTVQjdXBkYXRlfSBtZXRob2QgbSB0aW1lcyBiZWNhdXNlIGl0XG4gICAgICogcHJldmVudHMgdXBkYXRpbmcgbWlkZGxlIG5vZGVzIHNldmVyYWwgdGltZXMuIFRoaXMgd291bGQgaGFwcGVuIHdoZW4gdXBkYXRpbmcgbGVhdmVzXG4gICAgICogd2l0aCBjb21tb24gYW5jZXN0b3JzLiBUaGUgbmFpdmUgYXBwcm9hY2ggb2YgY2FsbGluZyAndXBkYXRlJyBtIHRpbWVzIGhhcyBjb21wbGV4aXR5XG4gICAgICogTyhtKmxvZyhuKSkgKHdoZXJlIG4gaXMgdGhlIG51bWJlciBvZiBsZWF2ZXMgb2YgdGhlIHRyZWUpLCB3aGljaCBlbmRzIHVwIGluXG4gICAgICogTyhuKmxvZyhuKSkgd2hlbiBtIH4gbi4gV2l0aCB0aGlzIG5ldyBhcHByb2FjaCwgdGhpcyBlbmRzIHVwIGJlaW5nIE8obikgYmVjYXVzZSBldmVyeVxuICAgICAqIG5vZGUgaXMgdXBkYXRlZCBhdCBtb3N0IG9uY2UgYW5kIHRoZXJlIGFyZSBhcm91bmQgMipuIG5vZGVzIGluIHRoZSB0cmVlLlxuICAgICAqIEBwYXJhbSBpbmRpY2VzIFRoZSBsaXN0IG9mIGluZGljZXMgb2YgdGhlIHJlc3BlY3RpdmUgbGVhdmVzLlxuICAgICAqIEBwYXJhbSBsZWF2ZXMgVGhlIGxpc3Qgb2YgbGVhdmVzIHRvIGJlIHVwZGF0ZWQuXG4gICAgICovXG4gICAgdXBkYXRlTWFueShpbmRpY2VzLCBsZWF2ZXMpIHtcbiAgICAgICAgcmVxdWlyZURlZmluZWQobGVhdmVzLCBcImxlYXZlc1wiKTtcbiAgICAgICAgcmVxdWlyZURlZmluZWQoaW5kaWNlcywgXCJpbmRpY2VzXCIpO1xuICAgICAgICByZXF1aXJlQXJyYXkobGVhdmVzLCBcImxlYXZlc1wiKTtcbiAgICAgICAgcmVxdWlyZUFycmF5KGluZGljZXMsIFwiaW5kaWNlc1wiKTtcbiAgICAgICAgaWYgKGxlYXZlcy5sZW5ndGggIT09IGluZGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSBpcyBubyBjb3JyZXNwb25kZW5jZSBiZXR3ZWVuIGluZGljZXMgYW5kIGxlYXZlc1wiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIHdpbGwga2VlcCB0cmFjayBvZiB0aGUgb3V0ZGF0ZWQgbm9kZXMgb2YgZWFjaCBsZXZlbC5cbiAgICAgICAgbGV0IG1vZGlmaWVkSW5kaWNlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICByZXF1aXJlTnVtYmVyKGluZGljZXNbaV0sIGBpbmRleCAke2l9YCk7XG4gICAgICAgICAgICBpZiAoaW5kaWNlc1tpXSA8IDAgfHwgaW5kaWNlc1tpXSA+PSB0aGlzLnNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluZGV4ICR7aX0gaXMgb3V0IG9mIHJhbmdlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW9kaWZpZWRJbmRpY2VzLmhhcyhpbmRpY2VzW2ldKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGVhZiAke2luZGljZXNbaV19IGlzIHJlcGVhdGVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb2RpZmllZEluZGljZXMuYWRkKGluZGljZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIG1vZGlmaWVkSW5kaWNlcy5jbGVhcigpO1xuICAgICAgICAvLyBGaXJzdCwgbW9kaWZ5IHRoZSBmaXJzdCBsZXZlbCwgd2hpY2ggY29uc2lzdHMgb25seSBvZiByYXcsIHVuLWhhc2hlZCB2YWx1ZXNcbiAgICAgICAgZm9yIChsZXQgbGVhZiA9IDA7IGxlYWYgPCBpbmRpY2VzLmxlbmd0aDsgbGVhZiArPSAxKSB7XG4gICAgICAgICAgICB0aGlzLl9ub2Rlc1swXVtpbmRpY2VzW2xlYWZdXSA9IGxlYXZlc1tsZWFmXTtcbiAgICAgICAgICAgIG1vZGlmaWVkSW5kaWNlcy5hZGQoaW5kaWNlc1tsZWFmXSA+PiAxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3cgdXBkYXRlIGVhY2ggbm9kZSBvZiB0aGUgY29ycmVzcG9uZGluZyBsZXZlbHNcbiAgICAgICAgZm9yIChsZXQgbGV2ZWwgPSAxOyBsZXZlbCA8PSB0aGlzLmRlcHRoOyBsZXZlbCArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdNb2RpZmllZEluZGljZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgbW9kaWZpZWRJbmRpY2VzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdENoaWxkID0gdGhpcy5fbm9kZXNbbGV2ZWwgLSAxXVsyICogaW5kZXhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0Q2hpbGQgPSB0aGlzLl9ub2Rlc1tsZXZlbCAtIDFdWzIgKiBpbmRleCArIDFdO1xuICAgICAgICAgICAgICAgIHRoaXMuX25vZGVzW2xldmVsXVtpbmRleF0gPSByaWdodENoaWxkID8gdGhpcy5faGFzaChsZWZ0Q2hpbGQsIHJpZ2h0Q2hpbGQpIDogbGVmdENoaWxkO1xuICAgICAgICAgICAgICAgIG5ld01vZGlmaWVkSW5kaWNlcy5wdXNoKGluZGV4ID4+IDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW9kaWZpZWRJbmRpY2VzID0gbmV3IFNldChuZXdNb2RpZmllZEluZGljZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEl0IGdlbmVyYXRlcyBhIHtAbGluayBMZWFuSU1UTWVya2xlUHJvb2Z9IGZvciBhIGxlYWYgb2YgdGhlIHRyZWUuXG4gICAgICogVGhhdCBwcm9vZiBjYW4gYmUgdmVyaWZpZWQgYnkgdGhpcyB0cmVlIHVzaW5nIHRoZSBzYW1lIGhhc2ggZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbGVhZiBmb3Igd2hpY2ggYSBNZXJrbGUgcHJvb2Ygd2lsbCBiZSBnZW5lcmF0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIE1lcmtsZSBwcm9vZiBvZiB0aGUgbGVhZi5cbiAgICAgKi9cbiAgICBnZW5lcmF0ZVByb29mKGluZGV4KSB7XG4gICAgICAgIHJlcXVpcmVEZWZpbmVkKGluZGV4LCBcImluZGV4XCIpO1xuICAgICAgICByZXF1aXJlTnVtYmVyKGluZGV4LCBcImluZGV4XCIpO1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgbGVhZiBhdCBpbmRleCAnJHtpbmRleH0nIGRvZXMgbm90IGV4aXN0IGluIHRoaXMgdHJlZWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlYWYgPSB0aGlzLmxlYXZlc1tpbmRleF07XG4gICAgICAgIGNvbnN0IHNpYmxpbmdzID0gW107XG4gICAgICAgIGNvbnN0IHBhdGggPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbGV2ZWwgPSAwOyBsZXZlbCA8IHRoaXMuZGVwdGg7IGxldmVsICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzUmlnaHROb2RlID0gaW5kZXggJiAxO1xuICAgICAgICAgICAgY29uc3Qgc2libGluZ0luZGV4ID0gaXNSaWdodE5vZGUgPyBpbmRleCAtIDEgOiBpbmRleCArIDE7XG4gICAgICAgICAgICBjb25zdCBzaWJsaW5nID0gdGhpcy5fbm9kZXNbbGV2ZWxdW3NpYmxpbmdJbmRleF07XG4gICAgICAgICAgICAvLyBJZiB0aGUgc2libGluZyBub2RlIGRvZXMgbm90IGV4aXN0LCBpdCBtZWFucyB0aGF0IHRoZSBub2RlIGF0XG4gICAgICAgICAgICAvLyB0aGlzIGxldmVsIGhhcyB0aGUgc2FtZSB2YWx1ZSBhcyBpdHMgY2hpbGQuIFRoZXJlZm9yZSwgdGhlcmVcbiAgICAgICAgICAgIC8vIGlzIG5vIG5lZWQgdG8gaW5jbHVkZSBpdCBpbiB0aGUgcHJvb2Ygc2luY2UgdGhlcmUgaXMgbm8gaGFzaCB0byBjYWxjdWxhdGUuXG4gICAgICAgICAgICBpZiAoc2libGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGF0aC5wdXNoKGlzUmlnaHROb2RlKTtcbiAgICAgICAgICAgICAgICBzaWJsaW5ncy5wdXNoKHNpYmxpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXggPj49IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGluZGV4IG1pZ2h0IGJlIGRpZmZlcmVudCBmcm9tIHRoZSBvcmlnaW5hbCBpbmRleCBvZiB0aGUgbGVhZiwgc2luY2VcbiAgICAgICAgLy8gaW4gc29tZSBjYXNlcyBzb21lIHNpYmxpbmdzIGFyZSBub3QgaW5jbHVkZWQgKGFzIGV4cGxhaW5lZCBhYm92ZSkuXG4gICAgICAgIHJldHVybiB7IHJvb3Q6IHRoaXMucm9vdCwgbGVhZiwgaW5kZXg6IE51bWJlci5wYXJzZUludChwYXRoLnJldmVyc2UoKS5qb2luKFwiXCIpLCAyKSwgc2libGluZ3MgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXQgdmVyaWZpZXMgYSB7QGxpbmsgTGVhbklNVE1lcmtsZVByb29mfSB0byBjb25maXJtIHRoYXQgYSBsZWFmIGluZGVlZFxuICAgICAqIGJlbG9uZ3MgdG8gYSB0cmVlLiAgRG9lcyBub3QgdmVyaWZ5IHRoYXQgdGhlIG5vZGUgYmVsb25ncyB0byB0aGlzXG4gICAgICogdHJlZSBpbiBwYXJ0aWN1bGFyLiAgRXF1aXZhbGVudCB0b1xuICAgICAqIGBMZWFuSU1ULnZlcmlmeVByb29mKHByb29mLCB0aGlzLl9oYXNoKWAuXG4gICAgICogQHBhcmFtIHByb29mIFRoZSBNZXJrbGUgdHJlZSBwcm9vZi5cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBsZWFmIGlzIHBhcnQgb2YgdGhlIHRyZWUsIGFuZCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgdmVyaWZ5UHJvb2YocHJvb2YpIHtcbiAgICAgICAgcmV0dXJuIExlYW5JTVQudmVyaWZ5UHJvb2YocHJvb2YsIHRoaXMuX2hhc2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdCB2ZXJpZmllcyBhIHtAbGluayBMZWFuSU1UTWVya2xlUHJvb2Z9IHRvIGNvbmZpcm0gdGhhdCBhIGxlYWYgaW5kZWVkXG4gICAgICogYmVsb25ncyB0byBhIHRyZWUuXG4gICAgICogQHBhcmFtIHByb29mIFRoZSBNZXJrbGUgdHJlZSBwcm9vZi5cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBsZWFmIGlzIHBhcnQgb2YgdGhlIHRyZWUsIGFuZCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc3RhdGljIHZlcmlmeVByb29mKHByb29mLCBoYXNoKSB7XG4gICAgICAgIHJlcXVpcmVEZWZpbmVkKHByb29mLCBcInByb29mXCIpO1xuICAgICAgICBjb25zdCB7IHJvb3QsIGxlYWYsIHNpYmxpbmdzLCBpbmRleCB9ID0gcHJvb2Y7XG4gICAgICAgIHJlcXVpcmVEZWZpbmVkKHByb29mLnJvb3QsIFwicHJvb2Yucm9vdFwiKTtcbiAgICAgICAgcmVxdWlyZURlZmluZWQocHJvb2YubGVhZiwgXCJwcm9vZi5sZWFmXCIpO1xuICAgICAgICByZXF1aXJlRGVmaW5lZChwcm9vZi5zaWJsaW5ncywgXCJwcm9vZi5zaWJsaW5nc1wiKTtcbiAgICAgICAgcmVxdWlyZURlZmluZWQocHJvb2YuaW5kZXgsIFwicHJvb2YuaW5kZXhcIik7XG4gICAgICAgIHJlcXVpcmVBcnJheShwcm9vZi5zaWJsaW5ncywgXCJwcm9vZi5zaWJsaW5nc1wiKTtcbiAgICAgICAgcmVxdWlyZU51bWJlcihwcm9vZi5pbmRleCwgXCJwcm9vZi5pbmRleFwiKTtcbiAgICAgICAgbGV0IG5vZGUgPSBsZWFmO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpYmxpbmdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoKGluZGV4ID4+IGkpICYgMSkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBoYXNoKHNpYmxpbmdzW2ldLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBoYXNoKG5vZGUsIHNpYmxpbmdzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm9vdCA9PT0gbm9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXQgZW5hYmxlcyB0aGUgY29udmVyc2lvbiBvZiB0aGUgZnVsbCB0cmVlIHN0cnVjdHVyZSBpbnRvIGEgSlNPTiBzdHJpbmcsXG4gICAgICogZmFjaWxpdGF0aW5nIGZ1dHVyZSBpbXBvcnRzIG9mIHRoZSB0cmVlLiBUaGlzIGFwcHJvYWNoIGlzIGJlbmVmaWNpYWwgZm9yXG4gICAgICogbGFyZ2UgdHJlZXMsIGFzIGl0IHNhdmVzIHRpbWUgYnkgc3RvcmluZyBoYXNoZXMgaW5zdGVhZCBvZiByZWNvbXB1dGluZyB0aGVtXG4gICAgICogQHJldHVybnMgVGhlIHN0cmluZ2lmaWVkIEpTT04gb2YgdGhlIHRyZWUuXG4gICAgICovXG4gICAgZXhwb3J0KCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5fbm9kZXMsIChfLCB2KSA9PiAodHlwZW9mIHYgPT09IFwiYmlnaW50XCIgPyB2LnRvU3RyaW5nKCkgOiB2KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEl0IGltcG9ydHMgYW4gZW50aXJlIHRyZWUgYnkgaW5pdGlhbGl6aW5nIHRoZSBub2RlcyB3aXRob3V0IGNhbGN1bGF0aW5nXG4gICAgICogYW55IGhhc2hlcy4gTm90ZSB0aGF0IGl0IGlzIGNydWNpYWwgdG8gZW5zdXJlIHRoZSBpbnRlZ3JpdHkgb2YgdGhlIHRyZWVcbiAgICAgKiBiZWZvcmUgb3IgYWZ0ZXIgaW1wb3J0aW5nIGl0LiBJZiB0aGUgbWFwIGZ1bmN0aW9uIGlzIG5vdCBkZWZpbmVkLCBub2RlXG4gICAgICogdmFsdWVzIHdpbGwgYmUgY29udmVydGVkIHRvIGJpZ2ludHMgYnkgZGVmYXVsdC5cbiAgICAgKiBAcGFyYW0gaGFzaCBUaGUgaGFzaCBmdW5jdGlvbiB1c2VkIHRvIGNyZWF0ZSBub2Rlcy5cbiAgICAgKiBAcGFyYW0gbm9kZXMgVGhlIHN0cmluZ2lmaWVkIEpTT04gb2YgdGhlIHRyZWUuXG4gICAgICogQHBhcmFtIG1hcCBBIGZ1bmN0aW9uIHRvIG1hcCBlYWNoIG5vZGUgb2YgdGhlIHRyZWUgYW5kIGNvbnZlcnQgdGhlaXIgdHlwZXMuXG4gICAgICogQHJldHVybnMgQSBMZWFuSU1UIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbXBvcnQoaGFzaCwgbm9kZXMsIG1hcCkge1xuICAgICAgICByZXF1aXJlRGVmaW5lZChoYXNoLCBcImhhc2hcIik7XG4gICAgICAgIHJlcXVpcmVEZWZpbmVkKG5vZGVzLCBcIm5vZGVzXCIpO1xuICAgICAgICByZXF1aXJlRnVuY3Rpb24oaGFzaCwgXCJoYXNoXCIpO1xuICAgICAgICByZXF1aXJlU3RyaW5nKG5vZGVzLCBcIm5vZGVzXCIpO1xuICAgICAgICBpZiAobWFwKSB7XG4gICAgICAgICAgICByZXF1aXJlRGVmaW5lZChtYXAsIFwibWFwXCIpO1xuICAgICAgICAgICAgcmVxdWlyZUZ1bmN0aW9uKG1hcCwgXCJtYXBcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJlZSA9IG5ldyBMZWFuSU1UKGhhc2gpO1xuICAgICAgICB0cmVlLl9ub2RlcyA9IEpTT04ucGFyc2Uobm9kZXMsIChfLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXAgPyBtYXAodmFsdWUpIDogQmlnSW50KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgTGVhbklNVCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@zk-kit/lean-imt/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@zk-kit/lean-imt/node_modules/@zk-kit/utils/dist/lib.esm/error-handlers.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@zk-kit/lean-imt/node_modules/@zk-kit/utils/dist/lib.esm/error-handlers.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   requireArray: () => (/* binding */ requireArray),\n/* harmony export */   requireBigInt: () => (/* binding */ requireBigInt),\n/* harmony export */   requireBigNumber: () => (/* binding */ requireBigNumber),\n/* harmony export */   requireBigNumberish: () => (/* binding */ requireBigNumberish),\n/* harmony export */   requireBoolean: () => (/* binding */ requireBoolean),\n/* harmony export */   requireBuffer: () => (/* binding */ requireBuffer),\n/* harmony export */   requireDefined: () => (/* binding */ requireDefined),\n/* harmony export */   requireFunction: () => (/* binding */ requireFunction),\n/* harmony export */   requireHexadecimal: () => (/* binding */ requireHexadecimal),\n/* harmony export */   requireNumber: () => (/* binding */ requireNumber),\n/* harmony export */   requireObject: () => (/* binding */ requireObject),\n/* harmony export */   requireString: () => (/* binding */ requireString),\n/* harmony export */   requireStringifiedBigInt: () => (/* binding */ requireStringifiedBigInt),\n/* harmony export */   requireTypes: () => (/* binding */ requireTypes),\n/* harmony export */   requireUint8Array: () => (/* binding */ requireUint8Array)\n/* harmony export */ });\n/* harmony import */ var _type_checks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./type-checks.js */ \"(ssr)/./node_modules/@zk-kit/lean-imt/node_modules/@zk-kit/utils/dist/lib.esm/type-checks.js\");\n/**\n * @module @zk-kit/utils\n * @version 1.3.0\n * @file Essential zero-knowledge utility library for JavaScript developers.\n * @copyright Ethereum Foundation 2025\n * @license MIT\n * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/utils}\n*/\n\n\n/**\n * @module ErrorHandlers\n * This module is designed to provide utility functions for validating\n * function parameters. It includes functions that throw type errors if\n * the parameters do not meet specified criteria, such as being defined,\n * a number, a string, a function, or an array. This module helps ensure\n * that functions receive the correct types of inputs, enhancing code\n * reliability and reducing runtime errors.\n */\n/**\n * @throws Throws a type error if the parameter value has not been defined.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireDefined(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isDefined)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not defined`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a number.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireNumber(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isNumber)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a number, received type: ${typeof parameterValue}`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a boolean.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireBoolean(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isBoolean)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a boolean, received type: ${typeof parameterValue}`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a string.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireString(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isString)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a string, received type: ${typeof parameterValue}`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a function.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireFunction(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a function, received type: ${typeof parameterValue}`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not an Array.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireArray(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not an Array instance`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a Uint8Array.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireUint8Array(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isUint8Array)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a Uint8Array instance`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a Buffer.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireBuffer(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isBuffer)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a Buffer instance`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not an object.\n * Please, note that arrays are also objects in JavaScript.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireObject(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not an object, received type: ${typeof parameterValue}`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a bigint.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireBigInt(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isBigInt)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a bigint, received type: ${typeof parameterValue}`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a stringified bigint.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireStringifiedBigInt(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isStringifiedBigInt)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a stringified bigint`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a hexadecimal string.\n * If 'prefix' is 'true', the string must start with '0x' or '0X' followed by one or more\n * hexadecimal digits (0-9, a-f, A-F), otherwise no prefix is expected. 'prefix' is optional and\n * if its value it is not explicitly defined it will be set to 'true' by default.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n * @param prefix A boolean to include or not a '0x' or '0X' prefix.\n */\nfunction requireHexadecimal(parameterValue, parameterName, prefix = true) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isHexadecimal)(parameterValue, prefix)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a hexadecimal string`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a bignumber.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireBigNumber(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isBigNumber)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a bignumber`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a bignumber-ish.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireBigNumberish(parameterValue, parameterName) {\n    if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isBigNumberish)(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a bignumber-ish`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value type is not part of the list of types.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireTypes(parameterValue, parameterName, types) {\n    for (const type of types) {\n        if (!(0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isSupportedType)(type)) {\n            throw new Error(`Type '${type}' is not supported`);\n        }\n    }\n    for (const type of types) {\n        if ((0,_type_checks_js__WEBPACK_IMPORTED_MODULE_0__.isType)(parameterValue, type)) {\n            return;\n        }\n    }\n    throw new TypeError(`Parameter '${parameterName}' is none of the following types: ${types.join(\", \")}`);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHprLWtpdC9sZWFuLWltdC9ub2RlX21vZHVsZXMvQHprLWtpdC91dGlscy9kaXN0L2xpYi5lc20vZXJyb3ItaGFuZGxlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUN1Tzs7QUFFdk87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywwREFBUztBQUNsQiwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx5REFBUTtBQUNqQiwwQ0FBMEMsY0FBYyxvQ0FBb0Msc0JBQXNCO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDBEQUFTO0FBQ2xCLDBDQUEwQyxjQUFjLHFDQUFxQyxzQkFBc0I7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMseURBQVE7QUFDakIsMENBQTBDLGNBQWMsb0NBQW9DLHNCQUFzQjtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywyREFBVTtBQUNuQiwwQ0FBMEMsY0FBYyxzQ0FBc0Msc0JBQXNCO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHdEQUFPO0FBQ2hCLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZEQUFZO0FBQ3JCLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHlEQUFRO0FBQ2pCLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMseURBQVE7QUFDakIsMENBQTBDLGNBQWMscUNBQXFDLHNCQUFzQjtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx5REFBUTtBQUNqQiwwQ0FBMEMsY0FBYyxvQ0FBb0Msc0JBQXNCO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG9FQUFtQjtBQUM1QiwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhEQUFhO0FBQ3RCLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDREQUFXO0FBQ3BCLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLCtEQUFjO0FBQ3ZCLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0VBQWU7QUFDNUIscUNBQXFDLEtBQUs7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1REFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsY0FBYyxvQ0FBb0MsaUJBQWlCO0FBQ3pHOztBQUUwUSIsInNvdXJjZXMiOlsiL1VzZXJzL2NoYW5jZW1jYWxsaXN0ZXIvUHJvamVjdHMvenVwYXNzaHVudC9ub2RlX21vZHVsZXMvQHprLWtpdC9sZWFuLWltdC9ub2RlX21vZHVsZXMvQHprLWtpdC91dGlscy9kaXN0L2xpYi5lc20vZXJyb3ItaGFuZGxlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIEB6ay1raXQvdXRpbHNcbiAqIEB2ZXJzaW9uIDEuMy4wXG4gKiBAZmlsZSBFc3NlbnRpYWwgemVyby1rbm93bGVkZ2UgdXRpbGl0eSBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0IGRldmVsb3BlcnMuXG4gKiBAY29weXJpZ2h0IEV0aGVyZXVtIEZvdW5kYXRpb24gMjAyNVxuICogQGxpY2Vuc2UgTUlUXG4gKiBAc2VlIFtHaXRodWJde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9wcml2YWN5LXNjYWxpbmctZXhwbG9yYXRpb25zL3prLWtpdC90cmVlL21haW4vcGFja2FnZXMvdXRpbHN9XG4qL1xuaW1wb3J0IHsgaXNEZWZpbmVkLCBpc051bWJlciwgaXNCb29sZWFuLCBpc1N0cmluZywgaXNGdW5jdGlvbiwgaXNBcnJheSwgaXNVaW50OEFycmF5LCBpc0J1ZmZlciwgaXNPYmplY3QsIGlzQmlnSW50LCBpc1N0cmluZ2lmaWVkQmlnSW50LCBpc0hleGFkZWNpbWFsLCBpc0JpZ051bWJlciwgaXNCaWdOdW1iZXJpc2gsIGlzU3VwcG9ydGVkVHlwZSwgaXNUeXBlIH0gZnJvbSAnLi90eXBlLWNoZWNrcy5qcyc7XG5cbi8qKlxuICogQG1vZHVsZSBFcnJvckhhbmRsZXJzXG4gKiBUaGlzIG1vZHVsZSBpcyBkZXNpZ25lZCB0byBwcm92aWRlIHV0aWxpdHkgZnVuY3Rpb25zIGZvciB2YWxpZGF0aW5nXG4gKiBmdW5jdGlvbiBwYXJhbWV0ZXJzLiBJdCBpbmNsdWRlcyBmdW5jdGlvbnMgdGhhdCB0aHJvdyB0eXBlIGVycm9ycyBpZlxuICogdGhlIHBhcmFtZXRlcnMgZG8gbm90IG1lZXQgc3BlY2lmaWVkIGNyaXRlcmlhLCBzdWNoIGFzIGJlaW5nIGRlZmluZWQsXG4gKiBhIG51bWJlciwgYSBzdHJpbmcsIGEgZnVuY3Rpb24sIG9yIGFuIGFycmF5LiBUaGlzIG1vZHVsZSBoZWxwcyBlbnN1cmVcbiAqIHRoYXQgZnVuY3Rpb25zIHJlY2VpdmUgdGhlIGNvcnJlY3QgdHlwZXMgb2YgaW5wdXRzLCBlbmhhbmNpbmcgY29kZVxuICogcmVsaWFiaWxpdHkgYW5kIHJlZHVjaW5nIHJ1bnRpbWUgZXJyb3JzLlxuICovXG4vKipcbiAqIEB0aHJvd3MgVGhyb3dzIGEgdHlwZSBlcnJvciBpZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGhhcyBub3QgYmVlbiBkZWZpbmVkLlxuICogQHBhcmFtIHBhcmFtZXRlclZhbHVlIFRoZSBwYXJhbWV0ZXIgdmFsdWUuXG4gKiBAcGFyYW0gcGFyYW1ldGVyTmFtZSBUaGUgcGFyYW1ldGVyIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVEZWZpbmVkKHBhcmFtZXRlclZhbHVlLCBwYXJhbWV0ZXJOYW1lKSB7XG4gICAgaWYgKCFpc0RlZmluZWQocGFyYW1ldGVyVmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAnJHtwYXJhbWV0ZXJOYW1lfScgaXMgbm90IGRlZmluZWRgKTtcbiAgICB9XG59XG4vKipcbiAqIEB0aHJvd3MgVGhyb3dzIGEgdHlwZSBlcnJvciBpZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIG5vdCBhIG51bWJlci5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJWYWx1ZSBUaGUgcGFyYW1ldGVyIHZhbHVlLlxuICogQHBhcmFtIHBhcmFtZXRlck5hbWUgVGhlIHBhcmFtZXRlciBuYW1lLlxuICovXG5mdW5jdGlvbiByZXF1aXJlTnVtYmVyKHBhcmFtZXRlclZhbHVlLCBwYXJhbWV0ZXJOYW1lKSB7XG4gICAgaWYgKCFpc051bWJlcihwYXJhbWV0ZXJWYWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGFyYW1ldGVyICcke3BhcmFtZXRlck5hbWV9JyBpcyBub3QgYSBudW1iZXIsIHJlY2VpdmVkIHR5cGU6ICR7dHlwZW9mIHBhcmFtZXRlclZhbHVlfWApO1xuICAgIH1cbn1cbi8qKlxuICogQHRocm93cyBUaHJvd3MgYSB0eXBlIGVycm9yIGlmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgaXMgbm90IGEgYm9vbGVhbi5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJWYWx1ZSBUaGUgcGFyYW1ldGVyIHZhbHVlLlxuICogQHBhcmFtIHBhcmFtZXRlck5hbWUgVGhlIHBhcmFtZXRlciBuYW1lLlxuICovXG5mdW5jdGlvbiByZXF1aXJlQm9vbGVhbihwYXJhbWV0ZXJWYWx1ZSwgcGFyYW1ldGVyTmFtZSkge1xuICAgIGlmICghaXNCb29sZWFuKHBhcmFtZXRlclZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJyR7cGFyYW1ldGVyTmFtZX0nIGlzIG5vdCBhIGJvb2xlYW4sIHJlY2VpdmVkIHR5cGU6ICR7dHlwZW9mIHBhcmFtZXRlclZhbHVlfWApO1xuICAgIH1cbn1cbi8qKlxuICogQHRocm93cyBUaHJvd3MgYSB0eXBlIGVycm9yIGlmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgaXMgbm90IGEgc3RyaW5nLlxuICogQHBhcmFtIHBhcmFtZXRlclZhbHVlIFRoZSBwYXJhbWV0ZXIgdmFsdWUuXG4gKiBAcGFyYW0gcGFyYW1ldGVyTmFtZSBUaGUgcGFyYW1ldGVyIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVTdHJpbmcocGFyYW1ldGVyVmFsdWUsIHBhcmFtZXRlck5hbWUpIHtcbiAgICBpZiAoIWlzU3RyaW5nKHBhcmFtZXRlclZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJyR7cGFyYW1ldGVyTmFtZX0nIGlzIG5vdCBhIHN0cmluZywgcmVjZWl2ZWQgdHlwZTogJHt0eXBlb2YgcGFyYW1ldGVyVmFsdWV9YCk7XG4gICAgfVxufVxuLyoqXG4gKiBAdGhyb3dzIFRocm93cyBhIHR5cGUgZXJyb3IgaWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBpcyBub3QgYSBmdW5jdGlvbi5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJWYWx1ZSBUaGUgcGFyYW1ldGVyIHZhbHVlLlxuICogQHBhcmFtIHBhcmFtZXRlck5hbWUgVGhlIHBhcmFtZXRlciBuYW1lLlxuICovXG5mdW5jdGlvbiByZXF1aXJlRnVuY3Rpb24ocGFyYW1ldGVyVmFsdWUsIHBhcmFtZXRlck5hbWUpIHtcbiAgICBpZiAoIWlzRnVuY3Rpb24ocGFyYW1ldGVyVmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAnJHtwYXJhbWV0ZXJOYW1lfScgaXMgbm90IGEgZnVuY3Rpb24sIHJlY2VpdmVkIHR5cGU6ICR7dHlwZW9mIHBhcmFtZXRlclZhbHVlfWApO1xuICAgIH1cbn1cbi8qKlxuICogQHRocm93cyBUaHJvd3MgYSB0eXBlIGVycm9yIGlmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgaXMgbm90IGFuIEFycmF5LlxuICogQHBhcmFtIHBhcmFtZXRlclZhbHVlIFRoZSBwYXJhbWV0ZXIgdmFsdWUuXG4gKiBAcGFyYW0gcGFyYW1ldGVyTmFtZSBUaGUgcGFyYW1ldGVyIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVBcnJheShwYXJhbWV0ZXJWYWx1ZSwgcGFyYW1ldGVyTmFtZSkge1xuICAgIGlmICghaXNBcnJheShwYXJhbWV0ZXJWYWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGFyYW1ldGVyICcke3BhcmFtZXRlck5hbWV9JyBpcyBub3QgYW4gQXJyYXkgaW5zdGFuY2VgKTtcbiAgICB9XG59XG4vKipcbiAqIEB0aHJvd3MgVGhyb3dzIGEgdHlwZSBlcnJvciBpZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIG5vdCBhIFVpbnQ4QXJyYXkuXG4gKiBAcGFyYW0gcGFyYW1ldGVyVmFsdWUgVGhlIHBhcmFtZXRlciB2YWx1ZS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJOYW1lIFRoZSBwYXJhbWV0ZXIgbmFtZS5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZVVpbnQ4QXJyYXkocGFyYW1ldGVyVmFsdWUsIHBhcmFtZXRlck5hbWUpIHtcbiAgICBpZiAoIWlzVWludDhBcnJheShwYXJhbWV0ZXJWYWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGFyYW1ldGVyICcke3BhcmFtZXRlck5hbWV9JyBpcyBub3QgYSBVaW50OEFycmF5IGluc3RhbmNlYCk7XG4gICAgfVxufVxuLyoqXG4gKiBAdGhyb3dzIFRocm93cyBhIHR5cGUgZXJyb3IgaWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBpcyBub3QgYSBCdWZmZXIuXG4gKiBAcGFyYW0gcGFyYW1ldGVyVmFsdWUgVGhlIHBhcmFtZXRlciB2YWx1ZS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJOYW1lIFRoZSBwYXJhbWV0ZXIgbmFtZS5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZUJ1ZmZlcihwYXJhbWV0ZXJWYWx1ZSwgcGFyYW1ldGVyTmFtZSkge1xuICAgIGlmICghaXNCdWZmZXIocGFyYW1ldGVyVmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAnJHtwYXJhbWV0ZXJOYW1lfScgaXMgbm90IGEgQnVmZmVyIGluc3RhbmNlYCk7XG4gICAgfVxufVxuLyoqXG4gKiBAdGhyb3dzIFRocm93cyBhIHR5cGUgZXJyb3IgaWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBpcyBub3QgYW4gb2JqZWN0LlxuICogUGxlYXNlLCBub3RlIHRoYXQgYXJyYXlzIGFyZSBhbHNvIG9iamVjdHMgaW4gSmF2YVNjcmlwdC5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJWYWx1ZSBUaGUgcGFyYW1ldGVyIHZhbHVlLlxuICogQHBhcmFtIHBhcmFtZXRlck5hbWUgVGhlIHBhcmFtZXRlciBuYW1lLlxuICovXG5mdW5jdGlvbiByZXF1aXJlT2JqZWN0KHBhcmFtZXRlclZhbHVlLCBwYXJhbWV0ZXJOYW1lKSB7XG4gICAgaWYgKCFpc09iamVjdChwYXJhbWV0ZXJWYWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGFyYW1ldGVyICcke3BhcmFtZXRlck5hbWV9JyBpcyBub3QgYW4gb2JqZWN0LCByZWNlaXZlZCB0eXBlOiAke3R5cGVvZiBwYXJhbWV0ZXJWYWx1ZX1gKTtcbiAgICB9XG59XG4vKipcbiAqIEB0aHJvd3MgVGhyb3dzIGEgdHlwZSBlcnJvciBpZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIG5vdCBhIGJpZ2ludC5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJWYWx1ZSBUaGUgcGFyYW1ldGVyIHZhbHVlLlxuICogQHBhcmFtIHBhcmFtZXRlck5hbWUgVGhlIHBhcmFtZXRlciBuYW1lLlxuICovXG5mdW5jdGlvbiByZXF1aXJlQmlnSW50KHBhcmFtZXRlclZhbHVlLCBwYXJhbWV0ZXJOYW1lKSB7XG4gICAgaWYgKCFpc0JpZ0ludChwYXJhbWV0ZXJWYWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGFyYW1ldGVyICcke3BhcmFtZXRlck5hbWV9JyBpcyBub3QgYSBiaWdpbnQsIHJlY2VpdmVkIHR5cGU6ICR7dHlwZW9mIHBhcmFtZXRlclZhbHVlfWApO1xuICAgIH1cbn1cbi8qKlxuICogQHRocm93cyBUaHJvd3MgYSB0eXBlIGVycm9yIGlmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgaXMgbm90IGEgc3RyaW5naWZpZWQgYmlnaW50LlxuICogQHBhcmFtIHBhcmFtZXRlclZhbHVlIFRoZSBwYXJhbWV0ZXIgdmFsdWUuXG4gKiBAcGFyYW0gcGFyYW1ldGVyTmFtZSBUaGUgcGFyYW1ldGVyIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVTdHJpbmdpZmllZEJpZ0ludChwYXJhbWV0ZXJWYWx1ZSwgcGFyYW1ldGVyTmFtZSkge1xuICAgIGlmICghaXNTdHJpbmdpZmllZEJpZ0ludChwYXJhbWV0ZXJWYWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGFyYW1ldGVyICcke3BhcmFtZXRlck5hbWV9JyBpcyBub3QgYSBzdHJpbmdpZmllZCBiaWdpbnRgKTtcbiAgICB9XG59XG4vKipcbiAqIEB0aHJvd3MgVGhyb3dzIGEgdHlwZSBlcnJvciBpZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIG5vdCBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqIElmICdwcmVmaXgnIGlzICd0cnVlJywgdGhlIHN0cmluZyBtdXN0IHN0YXJ0IHdpdGggJzB4JyBvciAnMFgnIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlXG4gKiBoZXhhZGVjaW1hbCBkaWdpdHMgKDAtOSwgYS1mLCBBLUYpLCBvdGhlcndpc2Ugbm8gcHJlZml4IGlzIGV4cGVjdGVkLiAncHJlZml4JyBpcyBvcHRpb25hbCBhbmRcbiAqIGlmIGl0cyB2YWx1ZSBpdCBpcyBub3QgZXhwbGljaXRseSBkZWZpbmVkIGl0IHdpbGwgYmUgc2V0IHRvICd0cnVlJyBieSBkZWZhdWx0LlxuICogQHBhcmFtIHBhcmFtZXRlclZhbHVlIFRoZSBwYXJhbWV0ZXIgdmFsdWUuXG4gKiBAcGFyYW0gcGFyYW1ldGVyTmFtZSBUaGUgcGFyYW1ldGVyIG5hbWUuXG4gKiBAcGFyYW0gcHJlZml4IEEgYm9vbGVhbiB0byBpbmNsdWRlIG9yIG5vdCBhICcweCcgb3IgJzBYJyBwcmVmaXguXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVIZXhhZGVjaW1hbChwYXJhbWV0ZXJWYWx1ZSwgcGFyYW1ldGVyTmFtZSwgcHJlZml4ID0gdHJ1ZSkge1xuICAgIGlmICghaXNIZXhhZGVjaW1hbChwYXJhbWV0ZXJWYWx1ZSwgcHJlZml4KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJyR7cGFyYW1ldGVyTmFtZX0nIGlzIG5vdCBhIGhleGFkZWNpbWFsIHN0cmluZ2ApO1xuICAgIH1cbn1cbi8qKlxuICogQHRocm93cyBUaHJvd3MgYSB0eXBlIGVycm9yIGlmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgaXMgbm90IGEgYmlnbnVtYmVyLlxuICogQHBhcmFtIHBhcmFtZXRlclZhbHVlIFRoZSBwYXJhbWV0ZXIgdmFsdWUuXG4gKiBAcGFyYW0gcGFyYW1ldGVyTmFtZSBUaGUgcGFyYW1ldGVyIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVCaWdOdW1iZXIocGFyYW1ldGVyVmFsdWUsIHBhcmFtZXRlck5hbWUpIHtcbiAgICBpZiAoIWlzQmlnTnVtYmVyKHBhcmFtZXRlclZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJyR7cGFyYW1ldGVyTmFtZX0nIGlzIG5vdCBhIGJpZ251bWJlcmApO1xuICAgIH1cbn1cbi8qKlxuICogQHRocm93cyBUaHJvd3MgYSB0eXBlIGVycm9yIGlmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgaXMgbm90IGEgYmlnbnVtYmVyLWlzaC5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJWYWx1ZSBUaGUgcGFyYW1ldGVyIHZhbHVlLlxuICogQHBhcmFtIHBhcmFtZXRlck5hbWUgVGhlIHBhcmFtZXRlciBuYW1lLlxuICovXG5mdW5jdGlvbiByZXF1aXJlQmlnTnVtYmVyaXNoKHBhcmFtZXRlclZhbHVlLCBwYXJhbWV0ZXJOYW1lKSB7XG4gICAgaWYgKCFpc0JpZ051bWJlcmlzaChwYXJhbWV0ZXJWYWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGFyYW1ldGVyICcke3BhcmFtZXRlck5hbWV9JyBpcyBub3QgYSBiaWdudW1iZXItaXNoYCk7XG4gICAgfVxufVxuLyoqXG4gKiBAdGhyb3dzIFRocm93cyBhIHR5cGUgZXJyb3IgaWYgdGhlIHBhcmFtZXRlciB2YWx1ZSB0eXBlIGlzIG5vdCBwYXJ0IG9mIHRoZSBsaXN0IG9mIHR5cGVzLlxuICogQHBhcmFtIHBhcmFtZXRlclZhbHVlIFRoZSBwYXJhbWV0ZXIgdmFsdWUuXG4gKiBAcGFyYW0gcGFyYW1ldGVyTmFtZSBUaGUgcGFyYW1ldGVyIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVUeXBlcyhwYXJhbWV0ZXJWYWx1ZSwgcGFyYW1ldGVyTmFtZSwgdHlwZXMpIHtcbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgdHlwZXMpIHtcbiAgICAgICAgaWYgKCFpc1N1cHBvcnRlZFR5cGUodHlwZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVHlwZSAnJHt0eXBlfScgaXMgbm90IHN1cHBvcnRlZGApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgdHlwZSBvZiB0eXBlcykge1xuICAgICAgICBpZiAoaXNUeXBlKHBhcmFtZXRlclZhbHVlLCB0eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAnJHtwYXJhbWV0ZXJOYW1lfScgaXMgbm9uZSBvZiB0aGUgZm9sbG93aW5nIHR5cGVzOiAke3R5cGVzLmpvaW4oXCIsIFwiKX1gKTtcbn1cblxuZXhwb3J0IHsgcmVxdWlyZUFycmF5LCByZXF1aXJlQmlnSW50LCByZXF1aXJlQmlnTnVtYmVyLCByZXF1aXJlQmlnTnVtYmVyaXNoLCByZXF1aXJlQm9vbGVhbiwgcmVxdWlyZUJ1ZmZlciwgcmVxdWlyZURlZmluZWQsIHJlcXVpcmVGdW5jdGlvbiwgcmVxdWlyZUhleGFkZWNpbWFsLCByZXF1aXJlTnVtYmVyLCByZXF1aXJlT2JqZWN0LCByZXF1aXJlU3RyaW5nLCByZXF1aXJlU3RyaW5naWZpZWRCaWdJbnQsIHJlcXVpcmVUeXBlcywgcmVxdWlyZVVpbnQ4QXJyYXkgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@zk-kit/lean-imt/node_modules/@zk-kit/utils/dist/lib.esm/error-handlers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@zk-kit/lean-imt/node_modules/@zk-kit/utils/dist/lib.esm/type-checks.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@zk-kit/lean-imt/node_modules/@zk-kit/utils/dist/lib.esm/type-checks.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isArray: () => (/* binding */ isArray),\n/* harmony export */   isBigInt: () => (/* binding */ isBigInt),\n/* harmony export */   isBigNumber: () => (/* binding */ isBigNumber),\n/* harmony export */   isBigNumberish: () => (/* binding */ isBigNumberish),\n/* harmony export */   isBoolean: () => (/* binding */ isBoolean),\n/* harmony export */   isBuffer: () => (/* binding */ isBuffer),\n/* harmony export */   isDefined: () => (/* binding */ isDefined),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isHexadecimal: () => (/* binding */ isHexadecimal),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   isStringifiedBigInt: () => (/* binding */ isStringifiedBigInt),\n/* harmony export */   isSupportedType: () => (/* binding */ isSupportedType),\n/* harmony export */   isType: () => (/* binding */ isType),\n/* harmony export */   isUint8Array: () => (/* binding */ isUint8Array),\n/* harmony export */   supportedTypes: () => (/* binding */ supportedTypes)\n/* harmony export */ });\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ \"buffer\");\n/**\n * @module @zk-kit/utils\n * @version 1.3.0\n * @file Essential zero-knowledge utility library for JavaScript developers.\n * @copyright Ethereum Foundation 2025\n * @license MIT\n * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/utils}\n*/\n\n\n/**\n * @module TypeChecks\n * This module provides utility functions to check data types.\n * It defines a set of supported types and includes functions to check if\n * a value is defined and if it matches a supported type. These functions\n * are useful for type checking and validation in the other libraries,\n * enhancing code robustness and reliability.\n */\n/** @internal */\nconst supportedTypes = [\n    \"number\",\n    \"boolean\",\n    \"string\",\n    \"function\",\n    \"Array\",\n    \"Uint8Array\",\n    \"Buffer\",\n    \"object\",\n    \"bigint\",\n    \"stringified-bigint\",\n    \"hexadecimal\",\n    \"bignumber\",\n    \"bignumberish\"\n];\n/**\n * Returns true if the value is defined, false otherwise.\n * @param value The value to be checked.\n */\nfunction isDefined(value) {\n    return typeof value !== \"undefined\";\n}\n/**\n * Returns true if the value is a number, false otherwise.\n * @param value The value to be checked.\n */\nfunction isNumber(value) {\n    return typeof value === \"number\";\n}\n/**\n * Returns true if the value is a boolean, false otherwise.\n * @param value The value to be checked.\n */\nfunction isBoolean(value) {\n    return typeof value === \"boolean\";\n}\n/**\n * Returns true if the value is a string, false otherwise.\n * @param value The value to be checked.\n */\nfunction isString(value) {\n    return typeof value === \"string\";\n}\n/**\n * Returns true if the value is a function, false otherwise.\n * @param value The value to be checked.\n */\nfunction isFunction(value) {\n    return typeof value === \"function\";\n}\n/**\n * Returns true if the value is an object, false otherwise.\n * Please, note that arrays are also objects in JavaScript.\n * @param value The value to be checked.\n */\nfunction isObject(value) {\n    return typeof value === \"object\";\n}\n/**\n * Returns true if the value is an Array instance, false otherwise.\n * @param value The value to be checked.\n */\nfunction isArray(value) {\n    return isObject(value) && Array.isArray(value);\n}\n/**\n * Returns true if the value is a Uint8Array instance, false otherwise.\n * @param value The value to be checked.\n */\nfunction isUint8Array(value) {\n    return value instanceof Uint8Array;\n}\n/**\n * Returns true if the value is a Buffer instance, false otherwise.\n * @param value The value to be checked.\n */\nfunction isBuffer(value) {\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.isBuffer(value);\n}\n/**\n * Returns true if the value is a bigint, false otherwise.\n * @param value The value to be checked.\n */\nfunction isBigInt(value) {\n    return typeof value === \"bigint\";\n}\n/**\n * Checks if the given value is a string that represents a valid bigint.\n * @param value The value to be checked if it's a stringified bigint.\n */\nfunction isStringifiedBigInt(value) {\n    // Check if value is a string first.\n    if (!isString(value)) {\n        return false;\n    }\n    try {\n        // Attempt to convert the string to BigInt.\n        BigInt(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Checks if a string is a valid hexadecimal string representation.\n * If 'prefix' is 'true', the string must start with '0x' or '0X' followed by one or more\n * hexadecimal digits (0-9, a-f, A-F), otherwise no prefix is expected. 'prefix' is optional and\n * if its value it is not explicitly defined it will be set to 'true' by default.\n * @param value The string to be tested.\n * @param prefix A boolean to include or not a '0x' or '0X' prefix.\n */\nfunction isHexadecimal(value, prefix = true) {\n    if (!isString(value)) {\n        return false;\n    }\n    if (prefix) {\n        return /^(0x|0X)[0-9a-fA-F]+$/.test(value);\n    }\n    return /^[0-9a-fA-F]+$/.test(value);\n}\n/**\n * Checks if the given value can be considered as BigNumber.\n * A value is considered a BigNumber if it is a bigint or a string\n * that can be converted to a bigint (via `Bigint(s)`).\n * @param value The value to check.\n */\nfunction isBigNumber(value) {\n    return isBigInt(value) || isStringifiedBigInt(value);\n}\n/**\n * Checks if the given value can be considered as BigNumberish.\n * A value is considered BigNumberish if it meets\n * any of the following conditions: it's a number, a bigint, a string\n * that can be converted to a bigint, a hexadecimal\n * string, or a Buffer object.\n * @param value The value to check.\n */\nfunction isBigNumberish(value) {\n    return (isNumber(value) ||\n        isBigInt(value) ||\n        isStringifiedBigInt(value) ||\n        isHexadecimal(value) ||\n        isBuffer(value) ||\n        isUint8Array(value));\n}\n/**\n * Returns true if the value type is the same as the type passed\n * as the second parameter, false otherwise.\n * @param value\n * @param type The expected type.\n */\nfunction isType(value, type) {\n    switch (type) {\n        case \"number\":\n            return isNumber(value);\n        case \"boolean\":\n            return isBoolean(value);\n        case \"string\":\n            return isString(value);\n        case \"function\":\n            return isFunction(value);\n        case \"Array\":\n            return isArray(value);\n        case \"Uint8Array\":\n            return isUint8Array(value);\n        case \"Buffer\":\n            return isBuffer(value);\n        case \"object\":\n            return isObject(value);\n        case \"bigint\":\n            return isBigInt(value);\n        case \"stringified-bigint\":\n            return isStringifiedBigInt(value);\n        case \"hexadecimal\":\n            return isHexadecimal(value);\n        case \"bignumber\":\n            return isBigNumber(value);\n        case \"bignumberish\":\n            return isBigNumberish(value);\n        default:\n            return false;\n    }\n}\n/**\n * Returns true if the type is being supported by this utility\n * functions, false otherwise.\n * @param type The type to be checked.\n */\nfunction isSupportedType(type) {\n    return supportedTypes.includes(type);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHprLWtpdC9sZWFuLWltdC9ub2RlX21vZHVsZXMvQHprLWtpdC91dGlscy9kaXN0L2xpYi5lc20vdHlwZS1jaGVja3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ2dDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQ0FBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStOIiwic291cmNlcyI6WyIvVXNlcnMvY2hhbmNlbWNhbGxpc3Rlci9Qcm9qZWN0cy96dXBhc3NodW50L25vZGVfbW9kdWxlcy9Aemsta2l0L2xlYW4taW10L25vZGVfbW9kdWxlcy9Aemsta2l0L3V0aWxzL2Rpc3QvbGliLmVzbS90eXBlLWNoZWNrcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgQHprLWtpdC91dGlsc1xuICogQHZlcnNpb24gMS4zLjBcbiAqIEBmaWxlIEVzc2VudGlhbCB6ZXJvLWtub3dsZWRnZSB1dGlsaXR5IGxpYnJhcnkgZm9yIEphdmFTY3JpcHQgZGV2ZWxvcGVycy5cbiAqIEBjb3B5cmlnaHQgRXRoZXJldW0gRm91bmRhdGlvbiAyMDI1XG4gKiBAbGljZW5zZSBNSVRcbiAqIEBzZWUgW0dpdGh1Yl17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3ByaXZhY3ktc2NhbGluZy1leHBsb3JhdGlvbnMvemsta2l0L3RyZWUvbWFpbi9wYWNrYWdlcy91dGlsc31cbiovXG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXInO1xuXG4vKipcbiAqIEBtb2R1bGUgVHlwZUNoZWNrc1xuICogVGhpcyBtb2R1bGUgcHJvdmlkZXMgdXRpbGl0eSBmdW5jdGlvbnMgdG8gY2hlY2sgZGF0YSB0eXBlcy5cbiAqIEl0IGRlZmluZXMgYSBzZXQgb2Ygc3VwcG9ydGVkIHR5cGVzIGFuZCBpbmNsdWRlcyBmdW5jdGlvbnMgdG8gY2hlY2sgaWZcbiAqIGEgdmFsdWUgaXMgZGVmaW5lZCBhbmQgaWYgaXQgbWF0Y2hlcyBhIHN1cHBvcnRlZCB0eXBlLiBUaGVzZSBmdW5jdGlvbnNcbiAqIGFyZSB1c2VmdWwgZm9yIHR5cGUgY2hlY2tpbmcgYW5kIHZhbGlkYXRpb24gaW4gdGhlIG90aGVyIGxpYnJhcmllcyxcbiAqIGVuaGFuY2luZyBjb2RlIHJvYnVzdG5lc3MgYW5kIHJlbGlhYmlsaXR5LlxuICovXG4vKiogQGludGVybmFsICovXG5jb25zdCBzdXBwb3J0ZWRUeXBlcyA9IFtcbiAgICBcIm51bWJlclwiLFxuICAgIFwiYm9vbGVhblwiLFxuICAgIFwic3RyaW5nXCIsXG4gICAgXCJmdW5jdGlvblwiLFxuICAgIFwiQXJyYXlcIixcbiAgICBcIlVpbnQ4QXJyYXlcIixcbiAgICBcIkJ1ZmZlclwiLFxuICAgIFwib2JqZWN0XCIsXG4gICAgXCJiaWdpbnRcIixcbiAgICBcInN0cmluZ2lmaWVkLWJpZ2ludFwiLFxuICAgIFwiaGV4YWRlY2ltYWxcIixcbiAgICBcImJpZ251bWJlclwiLFxuICAgIFwiYmlnbnVtYmVyaXNoXCJcbl07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgZGVmaW5lZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICovXG5mdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGlzIGEgbnVtYmVyLCBmYWxzZSBvdGhlcndpc2UuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIjtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhIGJvb2xlYW4sIGZhbHNlIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqL1xuZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCI7XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmcsIGZhbHNlIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGZhbHNlIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QsIGZhbHNlIG90aGVyd2lzZS5cbiAqIFBsZWFzZSwgbm90ZSB0aGF0IGFycmF5cyBhcmUgYWxzbyBvYmplY3RzIGluIEphdmFTY3JpcHQuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhbiBBcnJheSBpbnN0YW5jZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICovXG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhIFVpbnQ4QXJyYXkgaW5zdGFuY2UsIGZhbHNlIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqL1xuZnVuY3Rpb24gaXNVaW50OEFycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhIEJ1ZmZlciBpbnN0YW5jZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICovXG5mdW5jdGlvbiBpc0J1ZmZlcih2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuaXNCdWZmZXIodmFsdWUpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGlzIGEgYmlnaW50LCBmYWxzZSBvdGhlcndpc2UuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKi9cbmZ1bmN0aW9uIGlzQmlnSW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIjtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSB2YWxpZCBiaWdpbnQuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGNoZWNrZWQgaWYgaXQncyBhIHN0cmluZ2lmaWVkIGJpZ2ludC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmdpZmllZEJpZ0ludCh2YWx1ZSkge1xuICAgIC8vIENoZWNrIGlmIHZhbHVlIGlzIGEgc3RyaW5nIGZpcnN0LlxuICAgIGlmICghaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gQXR0ZW1wdCB0byBjb252ZXJ0IHRoZSBzdHJpbmcgdG8gQmlnSW50LlxuICAgICAgICBCaWdJbnQodmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdHJpbmcgaXMgYSB2YWxpZCBoZXhhZGVjaW1hbCBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gKiBJZiAncHJlZml4JyBpcyAndHJ1ZScsIHRoZSBzdHJpbmcgbXVzdCBzdGFydCB3aXRoICcweCcgb3IgJzBYJyBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZVxuICogaGV4YWRlY2ltYWwgZGlnaXRzICgwLTksIGEtZiwgQS1GKSwgb3RoZXJ3aXNlIG5vIHByZWZpeCBpcyBleHBlY3RlZC4gJ3ByZWZpeCcgaXMgb3B0aW9uYWwgYW5kXG4gKiBpZiBpdHMgdmFsdWUgaXQgaXMgbm90IGV4cGxpY2l0bHkgZGVmaW5lZCBpdCB3aWxsIGJlIHNldCB0byAndHJ1ZScgYnkgZGVmYXVsdC5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgc3RyaW5nIHRvIGJlIHRlc3RlZC5cbiAqIEBwYXJhbSBwcmVmaXggQSBib29sZWFuIHRvIGluY2x1ZGUgb3Igbm90IGEgJzB4JyBvciAnMFgnIHByZWZpeC5cbiAqL1xuZnVuY3Rpb24gaXNIZXhhZGVjaW1hbCh2YWx1ZSwgcHJlZml4ID0gdHJ1ZSkge1xuICAgIGlmICghaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gL14oMHh8MFgpWzAtOWEtZkEtRl0rJC8udGVzdCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiAvXlswLTlhLWZBLUZdKyQvLnRlc3QodmFsdWUpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbHVlIGNhbiBiZSBjb25zaWRlcmVkIGFzIEJpZ051bWJlci5cbiAqIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhIEJpZ051bWJlciBpZiBpdCBpcyBhIGJpZ2ludCBvciBhIHN0cmluZ1xuICogdGhhdCBjYW4gYmUgY29udmVydGVkIHRvIGEgYmlnaW50ICh2aWEgYEJpZ2ludChzKWApLlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqL1xuZnVuY3Rpb24gaXNCaWdOdW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gaXNCaWdJbnQodmFsdWUpIHx8IGlzU3RyaW5naWZpZWRCaWdJbnQodmFsdWUpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbHVlIGNhbiBiZSBjb25zaWRlcmVkIGFzIEJpZ051bWJlcmlzaC5cbiAqIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBCaWdOdW1iZXJpc2ggaWYgaXQgbWVldHNcbiAqIGFueSBvZiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6IGl0J3MgYSBudW1iZXIsIGEgYmlnaW50LCBhIHN0cmluZ1xuICogdGhhdCBjYW4gYmUgY29udmVydGVkIHRvIGEgYmlnaW50LCBhIGhleGFkZWNpbWFsXG4gKiBzdHJpbmcsIG9yIGEgQnVmZmVyIG9iamVjdC5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKi9cbmZ1bmN0aW9uIGlzQmlnTnVtYmVyaXNoKHZhbHVlKSB7XG4gICAgcmV0dXJuIChpc051bWJlcih2YWx1ZSkgfHxcbiAgICAgICAgaXNCaWdJbnQodmFsdWUpIHx8XG4gICAgICAgIGlzU3RyaW5naWZpZWRCaWdJbnQodmFsdWUpIHx8XG4gICAgICAgIGlzSGV4YWRlY2ltYWwodmFsdWUpIHx8XG4gICAgICAgIGlzQnVmZmVyKHZhbHVlKSB8fFxuICAgICAgICBpc1VpbnQ4QXJyYXkodmFsdWUpKTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSB0eXBlIGlzIHRoZSBzYW1lIGFzIHRoZSB0eXBlIHBhc3NlZFxuICogYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB2YWx1ZVxuICogQHBhcmFtIHR5cGUgVGhlIGV4cGVjdGVkIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzVHlwZSh2YWx1ZSwgdHlwZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICByZXR1cm4gaXNOdW1iZXIodmFsdWUpO1xuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgcmV0dXJuIGlzQm9vbGVhbih2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBpc1N0cmluZyh2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24odmFsdWUpO1xuICAgICAgICBjYXNlIFwiQXJyYXlcIjpcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKTtcbiAgICAgICAgY2FzZSBcIlVpbnQ4QXJyYXlcIjpcbiAgICAgICAgICAgIHJldHVybiBpc1VpbnQ4QXJyYXkodmFsdWUpO1xuICAgICAgICBjYXNlIFwiQnVmZmVyXCI6XG4gICAgICAgICAgICByZXR1cm4gaXNCdWZmZXIodmFsdWUpO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpO1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgICAgICByZXR1cm4gaXNCaWdJbnQodmFsdWUpO1xuICAgICAgICBjYXNlIFwic3RyaW5naWZpZWQtYmlnaW50XCI6XG4gICAgICAgICAgICByZXR1cm4gaXNTdHJpbmdpZmllZEJpZ0ludCh2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJoZXhhZGVjaW1hbFwiOlxuICAgICAgICAgICAgcmV0dXJuIGlzSGV4YWRlY2ltYWwodmFsdWUpO1xuICAgICAgICBjYXNlIFwiYmlnbnVtYmVyXCI6XG4gICAgICAgICAgICByZXR1cm4gaXNCaWdOdW1iZXIodmFsdWUpO1xuICAgICAgICBjYXNlIFwiYmlnbnVtYmVyaXNoXCI6XG4gICAgICAgICAgICByZXR1cm4gaXNCaWdOdW1iZXJpc2godmFsdWUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB0eXBlIGlzIGJlaW5nIHN1cHBvcnRlZCBieSB0aGlzIHV0aWxpdHlcbiAqIGZ1bmN0aW9ucywgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgdG8gYmUgY2hlY2tlZC5cbiAqL1xuZnVuY3Rpb24gaXNTdXBwb3J0ZWRUeXBlKHR5cGUpIHtcbiAgICByZXR1cm4gc3VwcG9ydGVkVHlwZXMuaW5jbHVkZXModHlwZSk7XG59XG5cbmV4cG9ydCB7IGlzQXJyYXksIGlzQmlnSW50LCBpc0JpZ051bWJlciwgaXNCaWdOdW1iZXJpc2gsIGlzQm9vbGVhbiwgaXNCdWZmZXIsIGlzRGVmaW5lZCwgaXNGdW5jdGlvbiwgaXNIZXhhZGVjaW1hbCwgaXNOdW1iZXIsIGlzT2JqZWN0LCBpc1N0cmluZywgaXNTdHJpbmdpZmllZEJpZ0ludCwgaXNTdXBwb3J0ZWRUeXBlLCBpc1R5cGUsIGlzVWludDhBcnJheSwgc3VwcG9ydGVkVHlwZXMgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@zk-kit/lean-imt/node_modules/@zk-kit/utils/dist/lib.esm/type-checks.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@zk-kit/utils/dist/index.node.js":
/*!*******************************************************!*\
  !*** ./node_modules/@zk-kit/utils/dist/index.node.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Buffer: () => (/* reexport safe */ buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer),\n/* harmony export */   F1Field: () => (/* binding */ F1Field),\n/* harmony export */   base64ToBuffer: () => (/* binding */ base64ToBuffer),\n/* harmony export */   base64ToText: () => (/* binding */ base64ToText),\n/* harmony export */   beBigIntToBuffer: () => (/* binding */ beBigIntToBuffer),\n/* harmony export */   beBufferToBigInt: () => (/* binding */ beBufferToBigInt),\n/* harmony export */   bigIntToBuffer: () => (/* binding */ bigIntToBuffer),\n/* harmony export */   bigIntToHexadecimal: () => (/* binding */ bigIntToHexadecimal),\n/* harmony export */   bigNumberishToBigInt: () => (/* binding */ bigNumberishToBigInt),\n/* harmony export */   bigNumberishToBuffer: () => (/* binding */ bigNumberishToBuffer),\n/* harmony export */   bufferToBase64: () => (/* binding */ bufferToBase64),\n/* harmony export */   bufferToBigInt: () => (/* binding */ bufferToBigInt),\n/* harmony export */   bufferToHexadecimal: () => (/* binding */ bufferToHexadecimal),\n/* harmony export */   conversions: () => (/* binding */ conversions),\n/* harmony export */   crypto: () => (/* binding */ crypto_node),\n/* harmony export */   errorHandlers: () => (/* binding */ errorHandlers),\n/* harmony export */   hexadecimalToBigInt: () => (/* binding */ hexadecimalToBigInt),\n/* harmony export */   hexadecimalToBuffer: () => (/* binding */ hexadecimalToBuffer),\n/* harmony export */   isArray: () => (/* binding */ isArray),\n/* harmony export */   isBigInt: () => (/* binding */ isBigInt),\n/* harmony export */   isBigNumber: () => (/* binding */ isBigNumber),\n/* harmony export */   isBigNumberish: () => (/* binding */ isBigNumberish),\n/* harmony export */   isBoolean: () => (/* binding */ isBoolean),\n/* harmony export */   isBuffer: () => (/* binding */ isBuffer),\n/* harmony export */   isDefined: () => (/* binding */ isDefined),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isHexadecimal: () => (/* binding */ isHexadecimal),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   isStringifiedBigInt: () => (/* binding */ isStringifiedBigInt),\n/* harmony export */   isSupportedType: () => (/* binding */ isSupportedType),\n/* harmony export */   isType: () => (/* binding */ isType),\n/* harmony export */   isUint8Array: () => (/* binding */ isUint8Array),\n/* harmony export */   leBigIntToBuffer: () => (/* binding */ leBigIntToBuffer),\n/* harmony export */   leBufferToBigInt: () => (/* binding */ leBufferToBigInt),\n/* harmony export */   packFflonkProof: () => (/* binding */ packFflonkProof),\n/* harmony export */   packGroth16Proof: () => (/* binding */ packGroth16Proof),\n/* harmony export */   packPlonkProof: () => (/* binding */ packPlonkProof),\n/* harmony export */   packing: () => (/* binding */ proofPacking),\n/* harmony export */   requireArray: () => (/* binding */ requireArray),\n/* harmony export */   requireBigInt: () => (/* binding */ requireBigInt),\n/* harmony export */   requireBigNumber: () => (/* binding */ requireBigNumber),\n/* harmony export */   requireBigNumberish: () => (/* binding */ requireBigNumberish),\n/* harmony export */   requireBoolean: () => (/* binding */ requireBoolean),\n/* harmony export */   requireBuffer: () => (/* binding */ requireBuffer),\n/* harmony export */   requireDefined: () => (/* binding */ requireDefined),\n/* harmony export */   requireFunction: () => (/* binding */ requireFunction),\n/* harmony export */   requireHexadecimal: () => (/* binding */ requireHexadecimal),\n/* harmony export */   requireNumber: () => (/* binding */ requireNumber),\n/* harmony export */   requireObject: () => (/* binding */ requireObject),\n/* harmony export */   requireString: () => (/* binding */ requireString),\n/* harmony export */   requireStringifiedBigInt: () => (/* binding */ requireStringifiedBigInt),\n/* harmony export */   requireTypes: () => (/* binding */ requireTypes),\n/* harmony export */   requireUint8Array: () => (/* binding */ requireUint8Array),\n/* harmony export */   scalar: () => (/* binding */ scalar),\n/* harmony export */   supportedTypes: () => (/* binding */ supportedTypes),\n/* harmony export */   textToBase64: () => (/* binding */ textToBase64),\n/* harmony export */   typeChecks: () => (/* binding */ typeChecks),\n/* harmony export */   unpackFflonkProof: () => (/* binding */ unpackFflonkProof),\n/* harmony export */   unpackGroth16Proof: () => (/* binding */ unpackGroth16Proof),\n/* harmony export */   unpackPlonkProof: () => (/* binding */ unpackPlonkProof)\n/* harmony export */ });\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var ethers_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ethers/utils */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var ethers_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers/utils */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/**\n * @module @zk-kit/utils\n * @version 1.4.1\n * @file Essential zero-knowledge utility library for JavaScript developers.\n * @copyright Ethereum Foundation 2025\n * @license MIT\n * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/utils}\n*/\n\n\n\n\n\n/**\n * @module TypeChecks\n * This module provides utility functions to check data types.\n * It defines a set of supported types and includes functions to check if\n * a value is defined and if it matches a supported type. These functions\n * are useful for type checking and validation in the other libraries,\n * enhancing code robustness and reliability.\n */\n/** @internal */\nconst supportedTypes = [\n    \"number\",\n    \"boolean\",\n    \"string\",\n    \"function\",\n    \"Array\",\n    \"Uint8Array\",\n    \"Buffer\",\n    \"object\",\n    \"bigint\",\n    \"stringified-bigint\",\n    \"hexadecimal\",\n    \"bignumber\",\n    \"bignumberish\"\n];\n/**\n * Returns true if the value is defined, false otherwise.\n * @param value The value to be checked.\n */\nfunction isDefined(value) {\n    return typeof value !== \"undefined\";\n}\n/**\n * Returns true if the value is a number, false otherwise.\n * @param value The value to be checked.\n */\nfunction isNumber(value) {\n    return typeof value === \"number\";\n}\n/**\n * Returns true if the value is a boolean, false otherwise.\n * @param value The value to be checked.\n */\nfunction isBoolean(value) {\n    return typeof value === \"boolean\";\n}\n/**\n * Returns true if the value is a string, false otherwise.\n * @param value The value to be checked.\n */\nfunction isString(value) {\n    return typeof value === \"string\";\n}\n/**\n * Returns true if the value is a function, false otherwise.\n * @param value The value to be checked.\n */\nfunction isFunction(value) {\n    return typeof value === \"function\";\n}\n/**\n * Returns true if the value is an object, false otherwise.\n * Please, note that arrays are also objects in JavaScript.\n * @param value The value to be checked.\n */\nfunction isObject(value) {\n    return typeof value === \"object\";\n}\n/**\n * Returns true if the value is an Array instance, false otherwise.\n * @param value The value to be checked.\n */\nfunction isArray(value) {\n    return isObject(value) && Array.isArray(value);\n}\n/**\n * Returns true if the value is a Uint8Array instance, false otherwise.\n * @param value The value to be checked.\n */\nfunction isUint8Array(value) {\n    return value instanceof Uint8Array;\n}\n/**\n * Returns true if the value is a Buffer instance, false otherwise.\n * @param value The value to be checked.\n */\nfunction isBuffer(value) {\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.isBuffer(value);\n}\n/**\n * Returns true if the value is a bigint, false otherwise.\n * @param value The value to be checked.\n */\nfunction isBigInt(value) {\n    return typeof value === \"bigint\";\n}\n/**\n * Checks if the given value is a string that represents a valid bigint.\n * @param value The value to be checked if it's a stringified bigint.\n */\nfunction isStringifiedBigInt(value) {\n    // Check if value is a string first.\n    if (!isString(value)) {\n        return false;\n    }\n    try {\n        // Attempt to convert the string to BigInt.\n        BigInt(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Checks if a string is a valid hexadecimal string representation.\n * If 'prefix' is 'true', the string must start with '0x' or '0X' followed by one or more\n * hexadecimal digits (0-9, a-f, A-F), otherwise no prefix is expected. 'prefix' is optional and\n * if its value it is not explicitly defined it will be set to 'true' by default.\n * @param value The string to be tested.\n * @param prefix A boolean to include or not a '0x' or '0X' prefix.\n */\nfunction isHexadecimal(value, prefix = true) {\n    if (!isString(value)) {\n        return false;\n    }\n    if (prefix) {\n        return /^(0x|0X)[0-9a-fA-F]+$/.test(value);\n    }\n    return /^[0-9a-fA-F]+$/.test(value);\n}\n/**\n * Checks if the given value can be considered as BigNumber.\n * A value is considered a BigNumber if it is a bigint or a string\n * that can be converted to a bigint (via `Bigint(s)`).\n * @param value The value to check.\n */\nfunction isBigNumber(value) {\n    return isBigInt(value) || isStringifiedBigInt(value);\n}\n/**\n * Checks if the given value can be considered as BigNumberish.\n * A value is considered BigNumberish if it meets\n * any of the following conditions: it's a number, a bigint, a string\n * that can be converted to a bigint, a hexadecimal\n * string, or a Buffer object.\n * @param value The value to check.\n */\nfunction isBigNumberish(value) {\n    return (isNumber(value) ||\n        isBigInt(value) ||\n        isStringifiedBigInt(value) ||\n        isHexadecimal(value) ||\n        isBuffer(value) ||\n        isUint8Array(value));\n}\n/**\n * Returns true if the value type is the same as the type passed\n * as the second parameter, false otherwise.\n * @param value\n * @param type The expected type.\n */\nfunction isType(value, type) {\n    switch (type) {\n        case \"number\":\n            return isNumber(value);\n        case \"boolean\":\n            return isBoolean(value);\n        case \"string\":\n            return isString(value);\n        case \"function\":\n            return isFunction(value);\n        case \"Array\":\n            return isArray(value);\n        case \"Uint8Array\":\n            return isUint8Array(value);\n        case \"Buffer\":\n            return isBuffer(value);\n        case \"object\":\n            return isObject(value);\n        case \"bigint\":\n            return isBigInt(value);\n        case \"stringified-bigint\":\n            return isStringifiedBigInt(value);\n        case \"hexadecimal\":\n            return isHexadecimal(value);\n        case \"bignumber\":\n            return isBigNumber(value);\n        case \"bignumberish\":\n            return isBigNumberish(value);\n        default:\n            return false;\n    }\n}\n/**\n * Returns true if the type is being supported by this utility\n * functions, false otherwise.\n * @param type The type to be checked.\n */\nfunction isSupportedType(type) {\n    return supportedTypes.includes(type);\n}\n\nvar typeChecks = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    isArray: isArray,\n    isBigInt: isBigInt,\n    isBigNumber: isBigNumber,\n    isBigNumberish: isBigNumberish,\n    isBoolean: isBoolean,\n    isBuffer: isBuffer,\n    isDefined: isDefined,\n    isFunction: isFunction,\n    isHexadecimal: isHexadecimal,\n    isNumber: isNumber,\n    isObject: isObject,\n    isString: isString,\n    isStringifiedBigInt: isStringifiedBigInt,\n    isSupportedType: isSupportedType,\n    isType: isType,\n    isUint8Array: isUint8Array,\n    supportedTypes: supportedTypes\n});\n\n/**\n * @module ErrorHandlers\n * This module is designed to provide utility functions for validating\n * function parameters. It includes functions that throw type errors if\n * the parameters do not meet specified criteria, such as being defined,\n * a number, a string, a function, or an array. This module helps ensure\n * that functions receive the correct types of inputs, enhancing code\n * reliability and reducing runtime errors.\n */\n/**\n * @throws Throws a type error if the parameter value has not been defined.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireDefined(parameterValue, parameterName) {\n    if (!isDefined(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not defined`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a number.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireNumber(parameterValue, parameterName) {\n    if (!isNumber(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a number, received type: ${typeof parameterValue}`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a boolean.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireBoolean(parameterValue, parameterName) {\n    if (!isBoolean(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a boolean, received type: ${typeof parameterValue}`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a string.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireString(parameterValue, parameterName) {\n    if (!isString(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a string, received type: ${typeof parameterValue}`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a function.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireFunction(parameterValue, parameterName) {\n    if (!isFunction(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a function, received type: ${typeof parameterValue}`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not an Array.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireArray(parameterValue, parameterName) {\n    if (!isArray(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not an Array instance`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a Uint8Array.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireUint8Array(parameterValue, parameterName) {\n    if (!isUint8Array(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a Uint8Array instance`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a Buffer.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireBuffer(parameterValue, parameterName) {\n    if (!isBuffer(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a Buffer instance`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not an object.\n * Please, note that arrays are also objects in JavaScript.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireObject(parameterValue, parameterName) {\n    if (!isObject(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not an object, received type: ${typeof parameterValue}`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a bigint.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireBigInt(parameterValue, parameterName) {\n    if (!isBigInt(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a bigint, received type: ${typeof parameterValue}`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a stringified bigint.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireStringifiedBigInt(parameterValue, parameterName) {\n    if (!isStringifiedBigInt(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a stringified bigint`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a hexadecimal string.\n * If 'prefix' is 'true', the string must start with '0x' or '0X' followed by one or more\n * hexadecimal digits (0-9, a-f, A-F), otherwise no prefix is expected. 'prefix' is optional and\n * if its value it is not explicitly defined it will be set to 'true' by default.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n * @param prefix A boolean to include or not a '0x' or '0X' prefix.\n */\nfunction requireHexadecimal(parameterValue, parameterName, prefix = true) {\n    if (!isHexadecimal(parameterValue, prefix)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a hexadecimal string`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a bignumber.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireBigNumber(parameterValue, parameterName) {\n    if (!isBigNumber(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a bignumber`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value is not a bignumber-ish.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireBigNumberish(parameterValue, parameterName) {\n    if (!isBigNumberish(parameterValue)) {\n        throw new TypeError(`Parameter '${parameterName}' is not a bignumber-ish`);\n    }\n}\n/**\n * @throws Throws a type error if the parameter value type is not part of the list of types.\n * @param parameterValue The parameter value.\n * @param parameterName The parameter name.\n */\nfunction requireTypes(parameterValue, parameterName, types) {\n    for (const type of types) {\n        if (!isSupportedType(type)) {\n            throw new Error(`Type '${type}' is not supported`);\n        }\n    }\n    for (const type of types) {\n        if (isType(parameterValue, type)) {\n            return;\n        }\n    }\n    throw new TypeError(`Parameter '${parameterName}' is none of the following types: ${types.join(\", \")}`);\n}\n\nvar errorHandlers = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    requireArray: requireArray,\n    requireBigInt: requireBigInt,\n    requireBigNumber: requireBigNumber,\n    requireBigNumberish: requireBigNumberish,\n    requireBoolean: requireBoolean,\n    requireBuffer: requireBuffer,\n    requireDefined: requireDefined,\n    requireFunction: requireFunction,\n    requireHexadecimal: requireHexadecimal,\n    requireNumber: requireNumber,\n    requireObject: requireObject,\n    requireString: requireString,\n    requireStringifiedBigInt: requireStringifiedBigInt,\n    requireTypes: requireTypes,\n    requireUint8Array: requireUint8Array\n});\n\n/**\n * @module Conversions\n * This module provides a collection of utility functions for converting\n * between different numerical formats, particularly focusing on\n * conversions involving bigints, hexadecimals and buffers.\n * The module is structured with clear function naming to indicate\n * the conversion direction (e.g., `bigIntToHexadecimal` for BigInt\n * to hexadecimal, `bufferToBigInt` for buffer to bigint) and employs\n * type checks to ensure the correct handling of various input types.\n * It also includes variations for both big-endian (`be`) and little-endian\n * (`le`) conversions. It is important to note that when there is no prefix,\n * the order of bytes is always big-endian.\n */\n/**\n * Converts a bigint to a hexadecimal string.\n * @param value The bigint value to convert.\n * @returns The hexadecimal representation of the bigint.\n */\nfunction bigIntToHexadecimal(value) {\n    requireBigInt(value, \"value\");\n    let hex = value.toString(16);\n    // Ensure even length.\n    if (hex.length % 2 !== 0) {\n        hex = `0${hex}`;\n    }\n    return hex;\n}\n/**\n * Converts a hexadecimal string to a bigint. The input is interpreted as hexadecimal\n * with or without a '0x' prefix. It uses big-endian byte order.\n * @param value The hexadecimal string to convert.\n * @returns The bigint representation of the hexadecimal string.\n */\nfunction hexadecimalToBigInt(value) {\n    if (!isHexadecimal(value) && !isHexadecimal(value, false)) {\n        throw new TypeError(`Parameter 'value' is not a hexadecimal string`);\n    }\n    // Ensure the hex string starts with '0x'.\n    const formattedHexString = value.startsWith(\"0x\") ? value : `0x${value}`;\n    return BigInt(formattedHexString);\n}\n/**\n * Converts a buffer of bytes to a bigint using big-endian byte order.\n * It accepts 'Buffer' or 'Uint8Array'.\n * @param value The buffer to convert.\n * @returns The bigint representation of the buffer's contents.\n */\nfunction beBufferToBigInt(value) {\n    requireTypes(value, \"value\", [\"Buffer\", \"Uint8Array\"]);\n    return BigInt(`0x${buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value).toString(\"hex\")}`);\n}\n/**\n * Converts a buffer to a bigint using little-endian byte order.\n * It accepts 'Buffer' or 'Uint8Array'.\n * @param value The buffer to convert.\n * @returns The bigint representation of the buffer's contents in little-endian.\n */\nfunction leBufferToBigInt(value) {\n    requireTypes(value, \"value\", [\"Buffer\", \"Uint8Array\"]);\n    return BigInt(`0x${buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value).reverse().toString(\"hex\")}`);\n}\n/**\n * Converts a buffer to a bigint. Alias for beBufferToBigInt.\n * @param value The buffer to convert.\n * @returns The bigint representation of the buffer's contents.\n */\nfunction bufferToBigInt(value) {\n    return beBufferToBigInt(value);\n}\n/**\n * Converts a bigint to a buffer and fills with zeros if a valid\n * size (i.e. number of bytes) is specified. If the size is not defined,\n * it gets the size from the given bigint. If the specified size is smaller than\n * the size of the bigint (i.e. `minSize`), an error is thrown.\n * It uses big-endian byte order.\n * @param value The bigint to convert.\n * @param size The number of bytes of the buffer to return.\n * @returns The buffer representation of the bigint.\n */\nfunction beBigIntToBuffer(value, size) {\n    const hex = bigIntToHexadecimal(value);\n    // Calculate the minimum buffer size required to represent 'n' in bytes.\n    // Each hexadecimal character represents 4 bits, so 2 characters are 1 byte.\n    const minSize = Math.ceil(hex.length / 2);\n    if (!size) {\n        size = minSize;\n    }\n    else if (size < minSize) {\n        throw Error(`Size ${size} is too small, need at least ${minSize} bytes`);\n    }\n    // Allocate buffer of the desired size, filled with zeros.\n    const buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(size, 0);\n    const fromHex = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(hex, \"hex\");\n    fromHex.copy(buffer, size - fromHex.length);\n    return buffer;\n}\n/**\n * Converts a bigint to a buffer and fills with zeros if a valid\n * size (i.e. number of bytes) is specified. If the size is not defined,\n * it gets the size from the given bigint. If the specified size is smaller than\n * the size of the bigint (i.e. `minSize`), an error is thrown.\n * It uses little-endian byte order.\n * @param value The bigint to convert.\n * @param size The number of bytes of the buffer to return.\n * @returns The buffer representation of the bigint in little-endian.\n */\nfunction leBigIntToBuffer(value, size) {\n    const hex = bigIntToHexadecimal(value);\n    // Calculate the minimum buffer size required to represent 'n' in bytes.\n    // Each hexadecimal character represents 4 bits, so 2 characters are 1 byte.\n    const minSize = Math.ceil(hex.length / 2);\n    if (!size) {\n        size = minSize;\n    }\n    else if (size < minSize) {\n        throw Error(`Size ${size} is too small, need at least ${minSize} bytes`);\n    }\n    // Allocate buffer of the desired size, filled with zeros.\n    const buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(size, 0);\n    const fromHex = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(hex, \"hex\").reverse();\n    fromHex.copy(buffer, 0);\n    return buffer;\n}\n/**\n * Converts a bigint to a buffer. Alias for beBigIntToBuffer.\n * @param value The bigint to convert.\n * @returns The buffer representation of the bigint.\n */\nfunction bigIntToBuffer(value) {\n    return beBigIntToBuffer(value);\n}\n/**\n * Converts a BigNumberish type to a bigint. If the input is already a bigint,\n * the return value will be the bigint itself, otherwise it will be converted\n * to a bigint using big-endian byte order.\n * @param value The BigNumberish value to convert.\n * @returns The bigint representation of the BigNumberish value.\n */\nfunction bigNumberishToBigInt(value) {\n    requireBigNumberish(value, \"value\");\n    if (isBuffer(value) || isUint8Array(value)) {\n        return bufferToBigInt(value);\n    }\n    return BigInt(value);\n}\n/**\n * Converts a BigNumberish type to a buffer. If the input is already a buffer,\n * the return value will be the buffer itself, otherwise it will be converted\n * to a buffer using big-endian byte order.\n * @param value The BigNumberish value to convert.\n * @returns The buffer representation of the BigNumberish value.\n */\nfunction bigNumberishToBuffer(value) {\n    requireBigNumberish(value, \"value\");\n    if (isBuffer(value) || isUint8Array(value)) {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value);\n    }\n    return bigIntToBuffer(bigNumberishToBigInt(value));\n}\n/**\n * Converts an hexadecimal string to a buffer. The hexadecimal string\n * should not start with '0x' or '0X'. It keeps the bytes in the same order.\n * @param value The hexadecimal string to convert.\n * @returns The buffer representation of the hexadecimal string.\n */\nfunction hexadecimalToBuffer(value) {\n    requireHexadecimal(value, \"value\", false);\n    // Ensure even length before converting to buffer.\n    if (value.length % 2 !== 0) {\n        value = `0${value}`;\n    }\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value, \"hex\");\n}\n/**\n * Converts a buffer to a hexadecimal string. It accepts 'Buffer' or 'Uint8Array'.\n * The hexadecimal string will not start with '0x' or '0X'. It keeps the bytes in the same order.\n * @param value The buffer to convert.\n * @returns The converted hexadecimal string.\n */\nfunction bufferToHexadecimal(value) {\n    requireTypes(value, \"value\", [\"Buffer\", \"Uint8Array\"]);\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value).toString(\"hex\");\n}\n/**\n * Converts bytes to a base64 string. It accepts 'Buffer' or 'Uint8Array'.\n * @param value The bytes to convert.\n * @returns The converted base64 string.\n */\nfunction bufferToBase64(value) {\n    requireTypes(value, \"value\", [\"Buffer\", \"Uint8Array\"]);\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value).toString(\"base64\");\n}\n/**\n * Converts a base64 string to bytes (i.e. a buffer). This function does not check\n * if the input value is a valid base64 string. If there are unsupported characters\n * they will be ignored.\n * @param value The base64 string to convert.\n * @returns The converted buffer.\n */\nfunction base64ToBuffer(value) {\n    requireString(value, \"value\");\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value, \"base64\");\n}\n/**\n * Converts text (utf8) to a base64 string.\n * @param value The text to convert.\n * @returns The converted base64 string.\n */\nfunction textToBase64(value) {\n    requireString(value, \"value\");\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value, \"utf8\").toString(\"base64\");\n}\n/**\n * Converts a base64 string to text (utf8). This function does not check\n * if the input value is a valid base64 string. If there are unsupported characters\n * they could be ignored and the result may be unexpected.\n * @param value The base64 string to convert.\n * @returns The converted text.\n */\nfunction base64ToText(value) {\n    requireString(value, \"value\");\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value, \"base64\").toString(\"utf8\");\n}\n\nvar conversions = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    base64ToBuffer: base64ToBuffer,\n    base64ToText: base64ToText,\n    beBigIntToBuffer: beBigIntToBuffer,\n    beBufferToBigInt: beBufferToBigInt,\n    bigIntToBuffer: bigIntToBuffer,\n    bigIntToHexadecimal: bigIntToHexadecimal,\n    bigNumberishToBigInt: bigNumberishToBigInt,\n    bigNumberishToBuffer: bigNumberishToBuffer,\n    bufferToBase64: bufferToBase64,\n    bufferToBigInt: bufferToBigInt,\n    bufferToHexadecimal: bufferToHexadecimal,\n    hexadecimalToBigInt: hexadecimalToBigInt,\n    hexadecimalToBuffer: hexadecimalToBuffer,\n    leBigIntToBuffer: leBigIntToBuffer,\n    leBufferToBigInt: leBufferToBigInt,\n    textToBase64: textToBase64\n});\n\n/**\n * Generates a random sequence of bytes securely using Node.js's crypto module.\n * @param size The number of bytes to generate.\n * @returns A Uint8Array containing the generated random bytes.\n */\n/* eslint-disable import/prefer-default-export */\nfunction getRandomValues(size) {\n    if (size <= 0)\n        throw Error(`size ${size} is too small, need at least 1`);\n    const buffer = (0,crypto__WEBPACK_IMPORTED_MODULE_1__.randomBytes)(size);\n    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n}\n\nvar crypto_node = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    getRandomValues: getRandomValues\n});\n\n/**\n * @module Scalar\n * This module provides utility functions for performing scalar operations\n * within a field, especially designed to handle operations on bigints.\n * The operations include scalar inversion (`inv`), scalar exponentiation (`pow`),\n * and modular reduction. Functions are carefully implemented to ensure\n * mathematical correctness and efficiency, supporting both positive and\n * negative bigint values. The module aims to provide robust tools for\n * cryptographic calculations and other applications requiring high-precision\n * arithmetic in fields.\n */\n/**\n * Checks if a bigint scalar value is zero.\n * @param a The bigint scalar value to check.\n * @returns True if 'a' is zero, false otherwise.\n */\nfunction isZero(a) {\n    return !a;\n}\n/**\n * Determines whether a bigint scalar value is odd.\n * @param a The bigint scalar value to check.\n * @returns True if 'a' is odd, false if it is even.\n */\nfunction isOdd(a) {\n    return (a & BigInt(1)) === BigInt(1);\n}\n/**\n * Performs a bitwise right shift on a bigint scalar value.\n * This operation is equivalent to dividing by 2^n, but it operates directly\n * on the binary representation, making it efficient for certain types of calculations.\n * @param a The bigint scalar value to shift.\n * @param n The number of bits to shift 'a' by.\n * @returns The result of shifting 'a' right by 'n' bits.\n */\nfunction shiftRight(a, n) {\n    return a >> n;\n}\n/**\n * Multiplies two bigint scalar values.\n * @param a The first bigint scalar value.\n * @param b The second bigint scalar value.\n * @returns The product of 'a' and 'b'.\n */\nfunction mul(a, b) {\n    return a * b;\n}\n/**\n * Compares two bigint scalar values to determine if the first is greater than the second.\n * @param a The first bigint scalar value to compare.\n * @param b The second bigint scalar value to compare.\n * @returns True if 'a' is greater than 'b', false otherwise.\n */\nfunction gt(a, b) {\n    return a > b;\n}\n/**\n * Converts a bigint scalar value into an array of bits, represented as numbers.\n * This function is particularly useful for examining the binary structure of bigints,\n * which can be necessary for bit manipulation and understanding the representation\n * of numbers at a lower level.\n * @param n The bigint scalar value to convert into bits.\n * @returns An array of numbers representing the bits of 'n', starting from the least significant bit.\n */\nfunction bits(n) {\n    const res = [];\n    let E = n;\n    while (E) {\n        if (E & BigInt(1)) {\n            res.push(1);\n        }\n        else {\n            res.push(0);\n        }\n        E >>= BigInt(1);\n    }\n    return res;\n}\n\nvar scalar = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    bits: bits,\n    gt: gt,\n    isOdd: isOdd,\n    isZero: isZero,\n    mul: mul,\n    shiftRight: shiftRight\n});\n\n/**\n * @class F1Field\n * Represents a finite field of order 'order' providing arithmetic operations under modulus.\n * This class includes operations such as addition, subtraction, multiplication, division,\n * and inversion, all performed modulo the field's order. It's designed to work with bigints,\n * supporting large numbers for cryptographic purposes and other applications requiring\n * modular arithmetic.\n * Note that the outputs of the functions will always be within the field if and only if\n * the input values are within the field. Devs need to make sure of that.\n *\n * @property one Represents the scalar value 1 in the field.\n * @property zero Represents the scalar value 0 in the field.\n * @property _order The order of the finite field (i.e., the modulus).\n * @property _half Half the order of the field, used for certain comparisons.\n * @property _negone The scalar value -1 in the field, represented positively.\n */\nclass F1Field {\n    constructor(order) {\n        this.one = 1n;\n        this.zero = 0n;\n        this._order = order;\n        this._half = order >> this.one;\n        this._negone = this._order - this.one;\n    }\n    /**\n     * Ensures a given result falls within the field by applying modular reduction.\n     * This method also handles negative inputs, correctly mapping them into the field.\n     * @param res The result to be normalized to the field.\n     * @returns The equivalent value within the field.\n     */\n    e(res) {\n        res %= this._order;\n        return res < 0 ? res + this._order : res;\n    }\n    /**\n     * Performs modular multiplication of two bigint values within the field.\n     * @param a The first value.\n     * @param b The second value.\n     * @returns The product of 'a' and 'b' modulo the field's order.\n     */\n    mul(a, b) {\n        return (a * b) % this._order;\n    }\n    /**\n     * Subtracts one bigint from another under modulus.\n     * It ensures the result is within the field if and only if the input values are within the field.\n     * @param a The value from which to subtract.\n     * @param b The value to be subtracted.\n     * @returns The difference of 'a' and 'b' modulo the field's order.\n     */\n    sub(a, b) {\n        return a >= b ? a - b : this._order - b + a;\n    }\n    /**\n     * Adds two bigint values together under modulus.\n     * It ensures the result is within the field if and only if the input values are within the field.\n     * @param a The first value.\n     * @param b The second value.\n     * @returns The sum of 'a' and 'b' modulo the field's order.\n     */\n    add(a, b) {\n        const res = a + b;\n        return res >= this._order ? res - this._order : res;\n    }\n    /**\n     * Computes the multiplicative inverse of a given value within the field.\n     * This method uses the Extended Euclidean Algorithm to find the inverse,\n     * ensuring the result is always a positive value less than the field's order.\n     * If the input value is zero, which has no inverse, an error is thrown.\n     * @param a The value for which to compute the inverse.\n     * @returns The multiplicative inverse of 'a' modulo the field's order.\n     * @throws if 'a' is zero.\n     */\n    inv(a) {\n        if (a === this.zero) {\n            throw new Error(\"Zero has no inverse\");\n        }\n        let t = this.zero;\n        let r = this._order;\n        let newt = this.one;\n        let newr = a % this._order;\n        while (newr) {\n            const q = r / newr;\n            [t, newt] = [newt, t - q * newt];\n            [r, newr] = [newr, r - q * newr];\n        }\n        if (t < this.zero) {\n            t += this._order;\n        }\n        return t;\n    }\n    /**\n     * Divides one bigint by another within the field by multiplying the first value\n     * by the multiplicative inverse of the second.\n     * @param a The dividend.\n     * @param b The divisor.\n     * @returns The result of the division of 'a' by 'b' modulo the field's order.\n     */\n    div(a, b) {\n        return this.mul(a, this.inv(b));\n    }\n    /**\n     * Checks if two bigint values are equal within the context of the field.\n     * It ensures the result is within the field if and only if the input values are within the field.\n     * @param a The first value to compare.\n     * @param b The second value to compare.\n     * @returns True if 'a' equals 'b', false otherwise.\n     */\n    eq(a, b) {\n        return a === b;\n    }\n    /**\n     * Squares a bigint value within the field.\n     * This is a specific case of multiplication where the value is multiplied by itself,\n     * optimized for performance where applicable.\n     * It ensures the result is within the field if and only if the input values are within the field.\n     * @param a The value to square.\n     * @returns The square of 'a' modulo the field's order.\n     */\n    square(a) {\n        return (a * a) % this._order;\n    }\n    /**\n     * Compares two bigint values to determine if the first is less than the second,\n     * taking into account the field's order for modular comparison.\n     * It ensures the result is within the field if and only if the input values are within the field.\n     * @param a The first value to compare.\n     * @param b The second value to compare.\n     * @returns True if 'a' is less than 'b', false otherwise.\n     */\n    lt(a, b) {\n        const aa = a > this._half ? a - this._order : a;\n        const bb = b > this._half ? b - this._order : b;\n        return aa < bb;\n    }\n    /**\n     * Compares two bigint values to determine if the first is greater than or equal to the second,\n     * considering the field's modular context.\n     * It ensures the result is within the field if and only if the input values are within the field.\n     * @param a The first value to compare.\n     * @param b The second value to compare.\n     * @returns True if 'a' is greater than or equal to 'b', false otherwise.\n     */\n    geq(a, b) {\n        const aa = a > this._half ? a - this._order : a;\n        const bb = b > this._half ? b - this._order : b;\n        return aa >= bb;\n    }\n    /**\n     * Computes the negation of a bigint value within the field.\n     * The result is the modular additive inverse that, when added to the original value,\n     * yields zero in the field's modulus.\n     * It ensures the result is within the field if and only if the input values are within the field.\n     * @param a The value to negate.\n     * @returns The negation of 'a' modulo the field's order.\n     */\n    neg(a) {\n        return a ? this._order - a : a;\n    }\n    /**\n     * Checks if a bigint value is zero within the context of the field.\n     * @param a The value to check.\n     * @returns True if 'a' is zero, false otherwise.\n     */\n    isZero(a) {\n        return a === this.zero;\n    }\n    /**\n     * Raises a base to an exponent within the field, efficiently computing\n     * scalar exponentiation using the square-and-multiply algorithm.\n     * Supports both positive and negative exponents through the use of the `inv` method for negatives.\n     * @param base The base to be exponentiated.\n     * @param e The exponent.\n     * @returns The result of raising 'base' to the power 'e' modulo the field's order.\n     */\n    pow(base, e) {\n        if (isZero(e)) {\n            return this.one;\n        }\n        if (e < 0n) {\n            base = this.inv(base);\n            e = -e;\n        }\n        const n = bits(e);\n        if (n.length === 0) {\n            return this.one;\n        }\n        let res = base;\n        for (let i = n.length - 2; i >= 0; i -= 1) {\n            res = this.square(res);\n            if (n[i]) {\n                res = this.mul(res, base);\n            }\n        }\n        return res;\n    }\n}\n\n/**\n * @module ProofPacking\n *\n * This module provides utility functions to pack and unpack\n * various types of objects, making it easier to export or use\n * them externally.\n */\n/**\n * Packs a Snarkjs Groth16 proof into a single list usable as calldata in Solidity (public signals are not included).\n * @param proof The Groth16 proof generated with SnarkJS.\n * @returns Solidity calldata.\n */\nfunction packGroth16Proof(proof) {\n    return [\n        proof.pi_a[0],\n        proof.pi_a[1],\n        proof.pi_b[0][1],\n        proof.pi_b[0][0],\n        proof.pi_b[1][1],\n        proof.pi_b[1][0],\n        proof.pi_c[0],\n        proof.pi_c[1]\n    ];\n}\n/**\n * Unpacks a PackedGroth16Proof Solidity calldata into its original form which is a SnarkJS Groth16 proof.\n * @param proof Solidity calldata.\n * @returns The Groth16 proof compatible with SnarkJS.\n */\nfunction unpackGroth16Proof(proof) {\n    return {\n        pi_a: [proof[0], proof[1]],\n        pi_b: [\n            [proof[3], proof[2]],\n            [proof[5], proof[4]]\n        ],\n        pi_c: [proof[6], proof[7]],\n        protocol: \"groth16\",\n        curve: \"bn128\"\n    };\n}\n/**\n * Packs a Snarkjs Plonk proof into a single list usable as calldata in Solidity (public signals are not included).\n * @param proof The Plonk proof generated with SnarkJS.\n * @returns Solidity calldata.\n */\nfunction packPlonkProof(proof) {\n    return [\n        proof.A[0],\n        proof.A[1],\n        proof.B[0],\n        proof.B[1],\n        proof.C[0],\n        proof.C[1],\n        proof.Z[0],\n        proof.Z[1],\n        proof.T1[0],\n        proof.T1[1],\n        proof.T2[0],\n        proof.T2[1],\n        proof.T3[0],\n        proof.T3[1],\n        proof.Wxi[0],\n        proof.Wxi[1],\n        proof.Wxiw[0],\n        proof.Wxiw[1],\n        proof.eval_a,\n        proof.eval_b,\n        proof.eval_c,\n        proof.eval_s1,\n        proof.eval_s2,\n        proof.eval_zw\n    ];\n}\n/**\n * Unpacks a PackedPlonkProof Solidity calldata into its original form which is a SnarkJS Plonk proof.\n * @param proof Solidity calldata.\n * @returns The Plonk proof compatible with SnarkJS.\n */\nfunction unpackPlonkProof(proof) {\n    return {\n        A: [proof[0], proof[1]],\n        B: [proof[2], proof[3]],\n        C: [proof[4], proof[5]],\n        Z: [proof[6], proof[7]],\n        T1: [proof[8], proof[9]],\n        T2: [proof[10], proof[11]],\n        T3: [proof[12], proof[13]],\n        Wxi: [proof[14], proof[15]],\n        Wxiw: [proof[16], proof[17]],\n        eval_a: proof[18],\n        eval_b: proof[19],\n        eval_c: proof[20],\n        eval_s1: proof[21],\n        eval_s2: proof[22],\n        eval_zw: proof[23],\n        protocol: \"plonk\",\n        curve: \"bn128\"\n    };\n}\n/**\n * Packs a Snarkjs Fflonk proof into a single list usable as calldata in Solidity (public signals are not included).\n * @param proof The Fflonk proof generated with SnarkJS.\n * @returns Solidity calldata.\n */\nfunction packFflonkProof(proof) {\n    return [\n        (0,ethers_utils__WEBPACK_IMPORTED_MODULE_2__.zeroPadValue)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBeHex)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof.polynomials.C1[0])), 32),\n        (0,ethers_utils__WEBPACK_IMPORTED_MODULE_2__.zeroPadValue)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBeHex)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof.polynomials.C1[1])), 32),\n        (0,ethers_utils__WEBPACK_IMPORTED_MODULE_2__.zeroPadValue)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBeHex)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof.polynomials.C2[0])), 32),\n        (0,ethers_utils__WEBPACK_IMPORTED_MODULE_2__.zeroPadValue)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBeHex)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof.polynomials.C2[1])), 32),\n        (0,ethers_utils__WEBPACK_IMPORTED_MODULE_2__.zeroPadValue)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBeHex)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof.polynomials.W1[0])), 32),\n        (0,ethers_utils__WEBPACK_IMPORTED_MODULE_2__.zeroPadValue)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBeHex)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof.polynomials.W1[1])), 32),\n        (0,ethers_utils__WEBPACK_IMPORTED_MODULE_2__.zeroPadValue)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBeHex)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof.polynomials.W2[0])), 32),\n        (0,ethers_utils__WEBPACK_IMPORTED_MODULE_2__.zeroPadValue)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBeHex)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof.polynomials.W2[1])), 32),\n        (0,ethers_utils__WEBPACK_IMPORTED_MODULE_2__.zeroPadValue)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBeHex)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof.evaluations.ql)), 32),\n        (0,ethers_utils__WEBPACK_IMPORTED_MODULE_2__.zeroPadValue)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBeHex)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof.evaluations.qr)), 32),\n        (0,ethers_utils__WEBPACK_IMPORTED_MODULE_2__.zeroPadValue)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBeHex)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof.evaluations.qm)), 32),\n        (0,ethers_utils__WEBPACK_IMPORTED_MODULE_2__.zeroPadValue)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBeHex)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof.evaluations.qo)), 32),\n        (0,ethers_utils__WEBPACK_IMPORTED_MODULE_2__.zeroPadValue)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBeHex)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof.evaluations.qc)), 32),\n        (0,ethers_utils__WEBPACK_IMPORTED_MODULE_2__.zeroPadValue)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBeHex)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof.evaluations.s1)), 32),\n        (0,ethers_utils__WEBPACK_IMPORTED_MODULE_2__.zeroPadValue)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBeHex)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof.evaluations.s2)), 32),\n        (0,ethers_utils__WEBPACK_IMPORTED_MODULE_2__.zeroPadValue)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBeHex)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof.evaluations.s3)), 32),\n        (0,ethers_utils__WEBPACK_IMPORTED_MODULE_2__.zeroPadValue)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBeHex)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof.evaluations.a)), 32),\n        (0,ethers_utils__WEBPACK_IMPORTED_MODULE_2__.zeroPadValue)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBeHex)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof.evaluations.b)), 32),\n        (0,ethers_utils__WEBPACK_IMPORTED_MODULE_2__.zeroPadValue)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBeHex)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof.evaluations.c)), 32),\n        (0,ethers_utils__WEBPACK_IMPORTED_MODULE_2__.zeroPadValue)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBeHex)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof.evaluations.z)), 32),\n        (0,ethers_utils__WEBPACK_IMPORTED_MODULE_2__.zeroPadValue)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBeHex)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof.evaluations.zw)), 32),\n        (0,ethers_utils__WEBPACK_IMPORTED_MODULE_2__.zeroPadValue)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBeHex)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof.evaluations.t1w)), 32),\n        (0,ethers_utils__WEBPACK_IMPORTED_MODULE_2__.zeroPadValue)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBeHex)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof.evaluations.t2w)), 32),\n        (0,ethers_utils__WEBPACK_IMPORTED_MODULE_2__.zeroPadValue)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBeHex)((0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof.evaluations.inv)), 32)\n    ];\n}\n/**\n * Unpacks a PackedFflonkProof Solidity calldata into its original form which is a SnarkJS Fflonk proof.\n * @param proof Solidity calldata.\n * @returns The Fflonk proof compatible with SnarkJS.\n */\nfunction unpackFflonkProof(proof) {\n    return {\n        polynomials: {\n            C1: [(0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof[0]).toString(), (0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof[1]).toString()],\n            C2: [(0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof[2]).toString(), (0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof[3]).toString()],\n            W1: [(0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof[4]).toString(), (0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof[5]).toString()],\n            W2: [(0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof[6]).toString(), (0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof[7]).toString()]\n        },\n        evaluations: {\n            ql: (0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof[8]).toString(),\n            qr: (0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof[9]).toString(),\n            qm: (0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof[10]).toString(),\n            qo: (0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof[11]).toString(),\n            qc: (0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof[12]).toString(),\n            s1: (0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof[13]).toString(),\n            s2: (0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof[14]).toString(),\n            s3: (0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof[15]).toString(),\n            a: (0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof[16]).toString(),\n            b: (0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof[17]).toString(),\n            c: (0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof[18]).toString(),\n            z: (0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof[19]).toString(),\n            zw: (0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof[20]).toString(),\n            t1w: (0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof[21]).toString(),\n            t2w: (0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof[22]).toString(),\n            inv: (0,ethers_utils__WEBPACK_IMPORTED_MODULE_3__.toBigInt)(proof[23]).toString()\n        },\n        protocol: \"fflonk\",\n        curve: \"bn128\"\n    };\n}\n\nvar proofPacking = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    packFflonkProof: packFflonkProof,\n    packGroth16Proof: packGroth16Proof,\n    packPlonkProof: packPlonkProof,\n    unpackFflonkProof: unpackFflonkProof,\n    unpackGroth16Proof: unpackGroth16Proof,\n    unpackPlonkProof: unpackPlonkProof\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHprLWtpdC91dGlscy9kaXN0L2luZGV4Lm5vZGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ2dDO0FBQ0E7QUFDSztBQUMwQjs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMENBQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxjQUFjLG9DQUFvQyxzQkFBc0I7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGNBQWMscUNBQXFDLHNCQUFzQjtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsY0FBYyxvQ0FBb0Msc0JBQXNCO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxjQUFjLHNDQUFzQyxzQkFBc0I7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsY0FBYyxxQ0FBcUMsc0JBQXNCO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxjQUFjLG9DQUFvQyxzQkFBc0I7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxLQUFLO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGNBQWMsb0NBQW9DLGlCQUFpQjtBQUN6Rzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLElBQUk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxNQUFNO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBDQUFNLDZCQUE2QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMENBQU0sdUNBQXVDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU0sOEJBQThCLFNBQVM7QUFDekU7QUFDQTtBQUNBLG1CQUFtQiwwQ0FBTTtBQUN6QixvQkFBb0IsMENBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTSw4QkFBOEIsU0FBUztBQUN6RTtBQUNBO0FBQ0EsbUJBQW1CLDBDQUFNO0FBQ3pCLG9CQUFvQiwwQ0FBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQ0FBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0EsV0FBVywwQ0FBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBDQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBDQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQ0FBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQ0FBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMENBQU07QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU07QUFDbEMsbUJBQW1CLG1EQUFXO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMERBQVksQ0FBQyxxREFBTyxDQUFDLHNEQUFRO0FBQ3JDLFFBQVEsMERBQVksQ0FBQyxxREFBTyxDQUFDLHNEQUFRO0FBQ3JDLFFBQVEsMERBQVksQ0FBQyxxREFBTyxDQUFDLHNEQUFRO0FBQ3JDLFFBQVEsMERBQVksQ0FBQyxxREFBTyxDQUFDLHNEQUFRO0FBQ3JDLFFBQVEsMERBQVksQ0FBQyxxREFBTyxDQUFDLHNEQUFRO0FBQ3JDLFFBQVEsMERBQVksQ0FBQyxxREFBTyxDQUFDLHNEQUFRO0FBQ3JDLFFBQVEsMERBQVksQ0FBQyxxREFBTyxDQUFDLHNEQUFRO0FBQ3JDLFFBQVEsMERBQVksQ0FBQyxxREFBTyxDQUFDLHNEQUFRO0FBQ3JDLFFBQVEsMERBQVksQ0FBQyxxREFBTyxDQUFDLHNEQUFRO0FBQ3JDLFFBQVEsMERBQVksQ0FBQyxxREFBTyxDQUFDLHNEQUFRO0FBQ3JDLFFBQVEsMERBQVksQ0FBQyxxREFBTyxDQUFDLHNEQUFRO0FBQ3JDLFFBQVEsMERBQVksQ0FBQyxxREFBTyxDQUFDLHNEQUFRO0FBQ3JDLFFBQVEsMERBQVksQ0FBQyxxREFBTyxDQUFDLHNEQUFRO0FBQ3JDLFFBQVEsMERBQVksQ0FBQyxxREFBTyxDQUFDLHNEQUFRO0FBQ3JDLFFBQVEsMERBQVksQ0FBQyxxREFBTyxDQUFDLHNEQUFRO0FBQ3JDLFFBQVEsMERBQVksQ0FBQyxxREFBTyxDQUFDLHNEQUFRO0FBQ3JDLFFBQVEsMERBQVksQ0FBQyxxREFBTyxDQUFDLHNEQUFRO0FBQ3JDLFFBQVEsMERBQVksQ0FBQyxxREFBTyxDQUFDLHNEQUFRO0FBQ3JDLFFBQVEsMERBQVksQ0FBQyxxREFBTyxDQUFDLHNEQUFRO0FBQ3JDLFFBQVEsMERBQVksQ0FBQyxxREFBTyxDQUFDLHNEQUFRO0FBQ3JDLFFBQVEsMERBQVksQ0FBQyxxREFBTyxDQUFDLHNEQUFRO0FBQ3JDLFFBQVEsMERBQVksQ0FBQyxxREFBTyxDQUFDLHNEQUFRO0FBQ3JDLFFBQVEsMERBQVksQ0FBQyxxREFBTyxDQUFDLHNEQUFRO0FBQ3JDLFFBQVEsMERBQVksQ0FBQyxxREFBTyxDQUFDLHNEQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNEQUFRLHVCQUF1QixzREFBUTtBQUN4RCxpQkFBaUIsc0RBQVEsdUJBQXVCLHNEQUFRO0FBQ3hELGlCQUFpQixzREFBUSx1QkFBdUIsc0RBQVE7QUFDeEQsaUJBQWlCLHNEQUFRLHVCQUF1QixzREFBUTtBQUN4RCxTQUFTO0FBQ1Q7QUFDQSxnQkFBZ0Isc0RBQVE7QUFDeEIsZ0JBQWdCLHNEQUFRO0FBQ3hCLGdCQUFnQixzREFBUTtBQUN4QixnQkFBZ0Isc0RBQVE7QUFDeEIsZ0JBQWdCLHNEQUFRO0FBQ3hCLGdCQUFnQixzREFBUTtBQUN4QixnQkFBZ0Isc0RBQVE7QUFDeEIsZ0JBQWdCLHNEQUFRO0FBQ3hCLGVBQWUsc0RBQVE7QUFDdkIsZUFBZSxzREFBUTtBQUN2QixlQUFlLHNEQUFRO0FBQ3ZCLGVBQWUsc0RBQVE7QUFDdkIsZ0JBQWdCLHNEQUFRO0FBQ3hCLGlCQUFpQixzREFBUTtBQUN6QixpQkFBaUIsc0RBQVE7QUFDekIsaUJBQWlCLHNEQUFRO0FBQ3pCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFdTlCIiwic291cmNlcyI6WyIvVXNlcnMvY2hhbmNlbWNhbGxpc3Rlci9Qcm9qZWN0cy96dXBhc3NodW50L25vZGVfbW9kdWxlcy9Aemsta2l0L3V0aWxzL2Rpc3QvaW5kZXgubm9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgQHprLWtpdC91dGlsc1xuICogQHZlcnNpb24gMS40LjFcbiAqIEBmaWxlIEVzc2VudGlhbCB6ZXJvLWtub3dsZWRnZSB1dGlsaXR5IGxpYnJhcnkgZm9yIEphdmFTY3JpcHQgZGV2ZWxvcGVycy5cbiAqIEBjb3B5cmlnaHQgRXRoZXJldW0gRm91bmRhdGlvbiAyMDI1XG4gKiBAbGljZW5zZSBNSVRcbiAqIEBzZWUgW0dpdGh1Yl17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3ByaXZhY3ktc2NhbGluZy1leHBsb3JhdGlvbnMvemsta2l0L3RyZWUvbWFpbi9wYWNrYWdlcy91dGlsc31cbiovXG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXInO1xuZXhwb3J0IHsgQnVmZmVyIH0gZnJvbSAnYnVmZmVyJztcbmltcG9ydCB7IHJhbmRvbUJ5dGVzIH0gZnJvbSAnY3J5cHRvJztcbmltcG9ydCB7IHplcm9QYWRWYWx1ZSwgdG9CZUhleCwgdG9CaWdJbnQgfSBmcm9tICdldGhlcnMvdXRpbHMnO1xuXG4vKipcbiAqIEBtb2R1bGUgVHlwZUNoZWNrc1xuICogVGhpcyBtb2R1bGUgcHJvdmlkZXMgdXRpbGl0eSBmdW5jdGlvbnMgdG8gY2hlY2sgZGF0YSB0eXBlcy5cbiAqIEl0IGRlZmluZXMgYSBzZXQgb2Ygc3VwcG9ydGVkIHR5cGVzIGFuZCBpbmNsdWRlcyBmdW5jdGlvbnMgdG8gY2hlY2sgaWZcbiAqIGEgdmFsdWUgaXMgZGVmaW5lZCBhbmQgaWYgaXQgbWF0Y2hlcyBhIHN1cHBvcnRlZCB0eXBlLiBUaGVzZSBmdW5jdGlvbnNcbiAqIGFyZSB1c2VmdWwgZm9yIHR5cGUgY2hlY2tpbmcgYW5kIHZhbGlkYXRpb24gaW4gdGhlIG90aGVyIGxpYnJhcmllcyxcbiAqIGVuaGFuY2luZyBjb2RlIHJvYnVzdG5lc3MgYW5kIHJlbGlhYmlsaXR5LlxuICovXG4vKiogQGludGVybmFsICovXG5jb25zdCBzdXBwb3J0ZWRUeXBlcyA9IFtcbiAgICBcIm51bWJlclwiLFxuICAgIFwiYm9vbGVhblwiLFxuICAgIFwic3RyaW5nXCIsXG4gICAgXCJmdW5jdGlvblwiLFxuICAgIFwiQXJyYXlcIixcbiAgICBcIlVpbnQ4QXJyYXlcIixcbiAgICBcIkJ1ZmZlclwiLFxuICAgIFwib2JqZWN0XCIsXG4gICAgXCJiaWdpbnRcIixcbiAgICBcInN0cmluZ2lmaWVkLWJpZ2ludFwiLFxuICAgIFwiaGV4YWRlY2ltYWxcIixcbiAgICBcImJpZ251bWJlclwiLFxuICAgIFwiYmlnbnVtYmVyaXNoXCJcbl07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgZGVmaW5lZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICovXG5mdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGlzIGEgbnVtYmVyLCBmYWxzZSBvdGhlcndpc2UuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIjtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhIGJvb2xlYW4sIGZhbHNlIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqL1xuZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCI7XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmcsIGZhbHNlIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGZhbHNlIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QsIGZhbHNlIG90aGVyd2lzZS5cbiAqIFBsZWFzZSwgbm90ZSB0aGF0IGFycmF5cyBhcmUgYWxzbyBvYmplY3RzIGluIEphdmFTY3JpcHQuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhbiBBcnJheSBpbnN0YW5jZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICovXG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhIFVpbnQ4QXJyYXkgaW5zdGFuY2UsIGZhbHNlIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqL1xuZnVuY3Rpb24gaXNVaW50OEFycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhIEJ1ZmZlciBpbnN0YW5jZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICovXG5mdW5jdGlvbiBpc0J1ZmZlcih2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuaXNCdWZmZXIodmFsdWUpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGlzIGEgYmlnaW50LCBmYWxzZSBvdGhlcndpc2UuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKi9cbmZ1bmN0aW9uIGlzQmlnSW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIjtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSB2YWxpZCBiaWdpbnQuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGNoZWNrZWQgaWYgaXQncyBhIHN0cmluZ2lmaWVkIGJpZ2ludC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmdpZmllZEJpZ0ludCh2YWx1ZSkge1xuICAgIC8vIENoZWNrIGlmIHZhbHVlIGlzIGEgc3RyaW5nIGZpcnN0LlxuICAgIGlmICghaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gQXR0ZW1wdCB0byBjb252ZXJ0IHRoZSBzdHJpbmcgdG8gQmlnSW50LlxuICAgICAgICBCaWdJbnQodmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdHJpbmcgaXMgYSB2YWxpZCBoZXhhZGVjaW1hbCBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gKiBJZiAncHJlZml4JyBpcyAndHJ1ZScsIHRoZSBzdHJpbmcgbXVzdCBzdGFydCB3aXRoICcweCcgb3IgJzBYJyBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZVxuICogaGV4YWRlY2ltYWwgZGlnaXRzICgwLTksIGEtZiwgQS1GKSwgb3RoZXJ3aXNlIG5vIHByZWZpeCBpcyBleHBlY3RlZC4gJ3ByZWZpeCcgaXMgb3B0aW9uYWwgYW5kXG4gKiBpZiBpdHMgdmFsdWUgaXQgaXMgbm90IGV4cGxpY2l0bHkgZGVmaW5lZCBpdCB3aWxsIGJlIHNldCB0byAndHJ1ZScgYnkgZGVmYXVsdC5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgc3RyaW5nIHRvIGJlIHRlc3RlZC5cbiAqIEBwYXJhbSBwcmVmaXggQSBib29sZWFuIHRvIGluY2x1ZGUgb3Igbm90IGEgJzB4JyBvciAnMFgnIHByZWZpeC5cbiAqL1xuZnVuY3Rpb24gaXNIZXhhZGVjaW1hbCh2YWx1ZSwgcHJlZml4ID0gdHJ1ZSkge1xuICAgIGlmICghaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gL14oMHh8MFgpWzAtOWEtZkEtRl0rJC8udGVzdCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiAvXlswLTlhLWZBLUZdKyQvLnRlc3QodmFsdWUpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbHVlIGNhbiBiZSBjb25zaWRlcmVkIGFzIEJpZ051bWJlci5cbiAqIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhIEJpZ051bWJlciBpZiBpdCBpcyBhIGJpZ2ludCBvciBhIHN0cmluZ1xuICogdGhhdCBjYW4gYmUgY29udmVydGVkIHRvIGEgYmlnaW50ICh2aWEgYEJpZ2ludChzKWApLlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqL1xuZnVuY3Rpb24gaXNCaWdOdW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gaXNCaWdJbnQodmFsdWUpIHx8IGlzU3RyaW5naWZpZWRCaWdJbnQodmFsdWUpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbHVlIGNhbiBiZSBjb25zaWRlcmVkIGFzIEJpZ051bWJlcmlzaC5cbiAqIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBCaWdOdW1iZXJpc2ggaWYgaXQgbWVldHNcbiAqIGFueSBvZiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6IGl0J3MgYSBudW1iZXIsIGEgYmlnaW50LCBhIHN0cmluZ1xuICogdGhhdCBjYW4gYmUgY29udmVydGVkIHRvIGEgYmlnaW50LCBhIGhleGFkZWNpbWFsXG4gKiBzdHJpbmcsIG9yIGEgQnVmZmVyIG9iamVjdC5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKi9cbmZ1bmN0aW9uIGlzQmlnTnVtYmVyaXNoKHZhbHVlKSB7XG4gICAgcmV0dXJuIChpc051bWJlcih2YWx1ZSkgfHxcbiAgICAgICAgaXNCaWdJbnQodmFsdWUpIHx8XG4gICAgICAgIGlzU3RyaW5naWZpZWRCaWdJbnQodmFsdWUpIHx8XG4gICAgICAgIGlzSGV4YWRlY2ltYWwodmFsdWUpIHx8XG4gICAgICAgIGlzQnVmZmVyKHZhbHVlKSB8fFxuICAgICAgICBpc1VpbnQ4QXJyYXkodmFsdWUpKTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSB0eXBlIGlzIHRoZSBzYW1lIGFzIHRoZSB0eXBlIHBhc3NlZFxuICogYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB2YWx1ZVxuICogQHBhcmFtIHR5cGUgVGhlIGV4cGVjdGVkIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzVHlwZSh2YWx1ZSwgdHlwZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICByZXR1cm4gaXNOdW1iZXIodmFsdWUpO1xuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgcmV0dXJuIGlzQm9vbGVhbih2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBpc1N0cmluZyh2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24odmFsdWUpO1xuICAgICAgICBjYXNlIFwiQXJyYXlcIjpcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKTtcbiAgICAgICAgY2FzZSBcIlVpbnQ4QXJyYXlcIjpcbiAgICAgICAgICAgIHJldHVybiBpc1VpbnQ4QXJyYXkodmFsdWUpO1xuICAgICAgICBjYXNlIFwiQnVmZmVyXCI6XG4gICAgICAgICAgICByZXR1cm4gaXNCdWZmZXIodmFsdWUpO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpO1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgICAgICByZXR1cm4gaXNCaWdJbnQodmFsdWUpO1xuICAgICAgICBjYXNlIFwic3RyaW5naWZpZWQtYmlnaW50XCI6XG4gICAgICAgICAgICByZXR1cm4gaXNTdHJpbmdpZmllZEJpZ0ludCh2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJoZXhhZGVjaW1hbFwiOlxuICAgICAgICAgICAgcmV0dXJuIGlzSGV4YWRlY2ltYWwodmFsdWUpO1xuICAgICAgICBjYXNlIFwiYmlnbnVtYmVyXCI6XG4gICAgICAgICAgICByZXR1cm4gaXNCaWdOdW1iZXIodmFsdWUpO1xuICAgICAgICBjYXNlIFwiYmlnbnVtYmVyaXNoXCI6XG4gICAgICAgICAgICByZXR1cm4gaXNCaWdOdW1iZXJpc2godmFsdWUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB0eXBlIGlzIGJlaW5nIHN1cHBvcnRlZCBieSB0aGlzIHV0aWxpdHlcbiAqIGZ1bmN0aW9ucywgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgdG8gYmUgY2hlY2tlZC5cbiAqL1xuZnVuY3Rpb24gaXNTdXBwb3J0ZWRUeXBlKHR5cGUpIHtcbiAgICByZXR1cm4gc3VwcG9ydGVkVHlwZXMuaW5jbHVkZXModHlwZSk7XG59XG5cbnZhciB0eXBlQ2hlY2tzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBpc0FycmF5OiBpc0FycmF5LFxuICAgIGlzQmlnSW50OiBpc0JpZ0ludCxcbiAgICBpc0JpZ051bWJlcjogaXNCaWdOdW1iZXIsXG4gICAgaXNCaWdOdW1iZXJpc2g6IGlzQmlnTnVtYmVyaXNoLFxuICAgIGlzQm9vbGVhbjogaXNCb29sZWFuLFxuICAgIGlzQnVmZmVyOiBpc0J1ZmZlcixcbiAgICBpc0RlZmluZWQ6IGlzRGVmaW5lZCxcbiAgICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICAgIGlzSGV4YWRlY2ltYWw6IGlzSGV4YWRlY2ltYWwsXG4gICAgaXNOdW1iZXI6IGlzTnVtYmVyLFxuICAgIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgICBpc1N0cmluZzogaXNTdHJpbmcsXG4gICAgaXNTdHJpbmdpZmllZEJpZ0ludDogaXNTdHJpbmdpZmllZEJpZ0ludCxcbiAgICBpc1N1cHBvcnRlZFR5cGU6IGlzU3VwcG9ydGVkVHlwZSxcbiAgICBpc1R5cGU6IGlzVHlwZSxcbiAgICBpc1VpbnQ4QXJyYXk6IGlzVWludDhBcnJheSxcbiAgICBzdXBwb3J0ZWRUeXBlczogc3VwcG9ydGVkVHlwZXNcbn0pO1xuXG4vKipcbiAqIEBtb2R1bGUgRXJyb3JIYW5kbGVyc1xuICogVGhpcyBtb2R1bGUgaXMgZGVzaWduZWQgdG8gcHJvdmlkZSB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgdmFsaWRhdGluZ1xuICogZnVuY3Rpb24gcGFyYW1ldGVycy4gSXQgaW5jbHVkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3cgdHlwZSBlcnJvcnMgaWZcbiAqIHRoZSBwYXJhbWV0ZXJzIGRvIG5vdCBtZWV0IHNwZWNpZmllZCBjcml0ZXJpYSwgc3VjaCBhcyBiZWluZyBkZWZpbmVkLFxuICogYSBudW1iZXIsIGEgc3RyaW5nLCBhIGZ1bmN0aW9uLCBvciBhbiBhcnJheS4gVGhpcyBtb2R1bGUgaGVscHMgZW5zdXJlXG4gKiB0aGF0IGZ1bmN0aW9ucyByZWNlaXZlIHRoZSBjb3JyZWN0IHR5cGVzIG9mIGlucHV0cywgZW5oYW5jaW5nIGNvZGVcbiAqIHJlbGlhYmlsaXR5IGFuZCByZWR1Y2luZyBydW50aW1lIGVycm9ycy5cbiAqL1xuLyoqXG4gKiBAdGhyb3dzIFRocm93cyBhIHR5cGUgZXJyb3IgaWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBoYXMgbm90IGJlZW4gZGVmaW5lZC5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJWYWx1ZSBUaGUgcGFyYW1ldGVyIHZhbHVlLlxuICogQHBhcmFtIHBhcmFtZXRlck5hbWUgVGhlIHBhcmFtZXRlciBuYW1lLlxuICovXG5mdW5jdGlvbiByZXF1aXJlRGVmaW5lZChwYXJhbWV0ZXJWYWx1ZSwgcGFyYW1ldGVyTmFtZSkge1xuICAgIGlmICghaXNEZWZpbmVkKHBhcmFtZXRlclZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJyR7cGFyYW1ldGVyTmFtZX0nIGlzIG5vdCBkZWZpbmVkYCk7XG4gICAgfVxufVxuLyoqXG4gKiBAdGhyb3dzIFRocm93cyBhIHR5cGUgZXJyb3IgaWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBpcyBub3QgYSBudW1iZXIuXG4gKiBAcGFyYW0gcGFyYW1ldGVyVmFsdWUgVGhlIHBhcmFtZXRlciB2YWx1ZS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJOYW1lIFRoZSBwYXJhbWV0ZXIgbmFtZS5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZU51bWJlcihwYXJhbWV0ZXJWYWx1ZSwgcGFyYW1ldGVyTmFtZSkge1xuICAgIGlmICghaXNOdW1iZXIocGFyYW1ldGVyVmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAnJHtwYXJhbWV0ZXJOYW1lfScgaXMgbm90IGEgbnVtYmVyLCByZWNlaXZlZCB0eXBlOiAke3R5cGVvZiBwYXJhbWV0ZXJWYWx1ZX1gKTtcbiAgICB9XG59XG4vKipcbiAqIEB0aHJvd3MgVGhyb3dzIGEgdHlwZSBlcnJvciBpZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIG5vdCBhIGJvb2xlYW4uXG4gKiBAcGFyYW0gcGFyYW1ldGVyVmFsdWUgVGhlIHBhcmFtZXRlciB2YWx1ZS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJOYW1lIFRoZSBwYXJhbWV0ZXIgbmFtZS5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZUJvb2xlYW4ocGFyYW1ldGVyVmFsdWUsIHBhcmFtZXRlck5hbWUpIHtcbiAgICBpZiAoIWlzQm9vbGVhbihwYXJhbWV0ZXJWYWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGFyYW1ldGVyICcke3BhcmFtZXRlck5hbWV9JyBpcyBub3QgYSBib29sZWFuLCByZWNlaXZlZCB0eXBlOiAke3R5cGVvZiBwYXJhbWV0ZXJWYWx1ZX1gKTtcbiAgICB9XG59XG4vKipcbiAqIEB0aHJvd3MgVGhyb3dzIGEgdHlwZSBlcnJvciBpZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIG5vdCBhIHN0cmluZy5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJWYWx1ZSBUaGUgcGFyYW1ldGVyIHZhbHVlLlxuICogQHBhcmFtIHBhcmFtZXRlck5hbWUgVGhlIHBhcmFtZXRlciBuYW1lLlxuICovXG5mdW5jdGlvbiByZXF1aXJlU3RyaW5nKHBhcmFtZXRlclZhbHVlLCBwYXJhbWV0ZXJOYW1lKSB7XG4gICAgaWYgKCFpc1N0cmluZyhwYXJhbWV0ZXJWYWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGFyYW1ldGVyICcke3BhcmFtZXRlck5hbWV9JyBpcyBub3QgYSBzdHJpbmcsIHJlY2VpdmVkIHR5cGU6ICR7dHlwZW9mIHBhcmFtZXRlclZhbHVlfWApO1xuICAgIH1cbn1cbi8qKlxuICogQHRocm93cyBUaHJvd3MgYSB0eXBlIGVycm9yIGlmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgaXMgbm90IGEgZnVuY3Rpb24uXG4gKiBAcGFyYW0gcGFyYW1ldGVyVmFsdWUgVGhlIHBhcmFtZXRlciB2YWx1ZS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJOYW1lIFRoZSBwYXJhbWV0ZXIgbmFtZS5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZUZ1bmN0aW9uKHBhcmFtZXRlclZhbHVlLCBwYXJhbWV0ZXJOYW1lKSB7XG4gICAgaWYgKCFpc0Z1bmN0aW9uKHBhcmFtZXRlclZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJyR7cGFyYW1ldGVyTmFtZX0nIGlzIG5vdCBhIGZ1bmN0aW9uLCByZWNlaXZlZCB0eXBlOiAke3R5cGVvZiBwYXJhbWV0ZXJWYWx1ZX1gKTtcbiAgICB9XG59XG4vKipcbiAqIEB0aHJvd3MgVGhyb3dzIGEgdHlwZSBlcnJvciBpZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIG5vdCBhbiBBcnJheS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJWYWx1ZSBUaGUgcGFyYW1ldGVyIHZhbHVlLlxuICogQHBhcmFtIHBhcmFtZXRlck5hbWUgVGhlIHBhcmFtZXRlciBuYW1lLlxuICovXG5mdW5jdGlvbiByZXF1aXJlQXJyYXkocGFyYW1ldGVyVmFsdWUsIHBhcmFtZXRlck5hbWUpIHtcbiAgICBpZiAoIWlzQXJyYXkocGFyYW1ldGVyVmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAnJHtwYXJhbWV0ZXJOYW1lfScgaXMgbm90IGFuIEFycmF5IGluc3RhbmNlYCk7XG4gICAgfVxufVxuLyoqXG4gKiBAdGhyb3dzIFRocm93cyBhIHR5cGUgZXJyb3IgaWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBpcyBub3QgYSBVaW50OEFycmF5LlxuICogQHBhcmFtIHBhcmFtZXRlclZhbHVlIFRoZSBwYXJhbWV0ZXIgdmFsdWUuXG4gKiBAcGFyYW0gcGFyYW1ldGVyTmFtZSBUaGUgcGFyYW1ldGVyIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVVaW50OEFycmF5KHBhcmFtZXRlclZhbHVlLCBwYXJhbWV0ZXJOYW1lKSB7XG4gICAgaWYgKCFpc1VpbnQ4QXJyYXkocGFyYW1ldGVyVmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAnJHtwYXJhbWV0ZXJOYW1lfScgaXMgbm90IGEgVWludDhBcnJheSBpbnN0YW5jZWApO1xuICAgIH1cbn1cbi8qKlxuICogQHRocm93cyBUaHJvd3MgYSB0eXBlIGVycm9yIGlmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgaXMgbm90IGEgQnVmZmVyLlxuICogQHBhcmFtIHBhcmFtZXRlclZhbHVlIFRoZSBwYXJhbWV0ZXIgdmFsdWUuXG4gKiBAcGFyYW0gcGFyYW1ldGVyTmFtZSBUaGUgcGFyYW1ldGVyIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVCdWZmZXIocGFyYW1ldGVyVmFsdWUsIHBhcmFtZXRlck5hbWUpIHtcbiAgICBpZiAoIWlzQnVmZmVyKHBhcmFtZXRlclZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJyR7cGFyYW1ldGVyTmFtZX0nIGlzIG5vdCBhIEJ1ZmZlciBpbnN0YW5jZWApO1xuICAgIH1cbn1cbi8qKlxuICogQHRocm93cyBUaHJvd3MgYSB0eXBlIGVycm9yIGlmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgaXMgbm90IGFuIG9iamVjdC5cbiAqIFBsZWFzZSwgbm90ZSB0aGF0IGFycmF5cyBhcmUgYWxzbyBvYmplY3RzIGluIEphdmFTY3JpcHQuXG4gKiBAcGFyYW0gcGFyYW1ldGVyVmFsdWUgVGhlIHBhcmFtZXRlciB2YWx1ZS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJOYW1lIFRoZSBwYXJhbWV0ZXIgbmFtZS5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZU9iamVjdChwYXJhbWV0ZXJWYWx1ZSwgcGFyYW1ldGVyTmFtZSkge1xuICAgIGlmICghaXNPYmplY3QocGFyYW1ldGVyVmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAnJHtwYXJhbWV0ZXJOYW1lfScgaXMgbm90IGFuIG9iamVjdCwgcmVjZWl2ZWQgdHlwZTogJHt0eXBlb2YgcGFyYW1ldGVyVmFsdWV9YCk7XG4gICAgfVxufVxuLyoqXG4gKiBAdGhyb3dzIFRocm93cyBhIHR5cGUgZXJyb3IgaWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBpcyBub3QgYSBiaWdpbnQuXG4gKiBAcGFyYW0gcGFyYW1ldGVyVmFsdWUgVGhlIHBhcmFtZXRlciB2YWx1ZS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJOYW1lIFRoZSBwYXJhbWV0ZXIgbmFtZS5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZUJpZ0ludChwYXJhbWV0ZXJWYWx1ZSwgcGFyYW1ldGVyTmFtZSkge1xuICAgIGlmICghaXNCaWdJbnQocGFyYW1ldGVyVmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAnJHtwYXJhbWV0ZXJOYW1lfScgaXMgbm90IGEgYmlnaW50LCByZWNlaXZlZCB0eXBlOiAke3R5cGVvZiBwYXJhbWV0ZXJWYWx1ZX1gKTtcbiAgICB9XG59XG4vKipcbiAqIEB0aHJvd3MgVGhyb3dzIGEgdHlwZSBlcnJvciBpZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIG5vdCBhIHN0cmluZ2lmaWVkIGJpZ2ludC5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJWYWx1ZSBUaGUgcGFyYW1ldGVyIHZhbHVlLlxuICogQHBhcmFtIHBhcmFtZXRlck5hbWUgVGhlIHBhcmFtZXRlciBuYW1lLlxuICovXG5mdW5jdGlvbiByZXF1aXJlU3RyaW5naWZpZWRCaWdJbnQocGFyYW1ldGVyVmFsdWUsIHBhcmFtZXRlck5hbWUpIHtcbiAgICBpZiAoIWlzU3RyaW5naWZpZWRCaWdJbnQocGFyYW1ldGVyVmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAnJHtwYXJhbWV0ZXJOYW1lfScgaXMgbm90IGEgc3RyaW5naWZpZWQgYmlnaW50YCk7XG4gICAgfVxufVxuLyoqXG4gKiBAdGhyb3dzIFRocm93cyBhIHR5cGUgZXJyb3IgaWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBpcyBub3QgYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKiBJZiAncHJlZml4JyBpcyAndHJ1ZScsIHRoZSBzdHJpbmcgbXVzdCBzdGFydCB3aXRoICcweCcgb3IgJzBYJyBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZVxuICogaGV4YWRlY2ltYWwgZGlnaXRzICgwLTksIGEtZiwgQS1GKSwgb3RoZXJ3aXNlIG5vIHByZWZpeCBpcyBleHBlY3RlZC4gJ3ByZWZpeCcgaXMgb3B0aW9uYWwgYW5kXG4gKiBpZiBpdHMgdmFsdWUgaXQgaXMgbm90IGV4cGxpY2l0bHkgZGVmaW5lZCBpdCB3aWxsIGJlIHNldCB0byAndHJ1ZScgYnkgZGVmYXVsdC5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJWYWx1ZSBUaGUgcGFyYW1ldGVyIHZhbHVlLlxuICogQHBhcmFtIHBhcmFtZXRlck5hbWUgVGhlIHBhcmFtZXRlciBuYW1lLlxuICogQHBhcmFtIHByZWZpeCBBIGJvb2xlYW4gdG8gaW5jbHVkZSBvciBub3QgYSAnMHgnIG9yICcwWCcgcHJlZml4LlxuICovXG5mdW5jdGlvbiByZXF1aXJlSGV4YWRlY2ltYWwocGFyYW1ldGVyVmFsdWUsIHBhcmFtZXRlck5hbWUsIHByZWZpeCA9IHRydWUpIHtcbiAgICBpZiAoIWlzSGV4YWRlY2ltYWwocGFyYW1ldGVyVmFsdWUsIHByZWZpeCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGFyYW1ldGVyICcke3BhcmFtZXRlck5hbWV9JyBpcyBub3QgYSBoZXhhZGVjaW1hbCBzdHJpbmdgKTtcbiAgICB9XG59XG4vKipcbiAqIEB0aHJvd3MgVGhyb3dzIGEgdHlwZSBlcnJvciBpZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIG5vdCBhIGJpZ251bWJlci5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJWYWx1ZSBUaGUgcGFyYW1ldGVyIHZhbHVlLlxuICogQHBhcmFtIHBhcmFtZXRlck5hbWUgVGhlIHBhcmFtZXRlciBuYW1lLlxuICovXG5mdW5jdGlvbiByZXF1aXJlQmlnTnVtYmVyKHBhcmFtZXRlclZhbHVlLCBwYXJhbWV0ZXJOYW1lKSB7XG4gICAgaWYgKCFpc0JpZ051bWJlcihwYXJhbWV0ZXJWYWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUGFyYW1ldGVyICcke3BhcmFtZXRlck5hbWV9JyBpcyBub3QgYSBiaWdudW1iZXJgKTtcbiAgICB9XG59XG4vKipcbiAqIEB0aHJvd3MgVGhyb3dzIGEgdHlwZSBlcnJvciBpZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIG5vdCBhIGJpZ251bWJlci1pc2guXG4gKiBAcGFyYW0gcGFyYW1ldGVyVmFsdWUgVGhlIHBhcmFtZXRlciB2YWx1ZS5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJOYW1lIFRoZSBwYXJhbWV0ZXIgbmFtZS5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZUJpZ051bWJlcmlzaChwYXJhbWV0ZXJWYWx1ZSwgcGFyYW1ldGVyTmFtZSkge1xuICAgIGlmICghaXNCaWdOdW1iZXJpc2gocGFyYW1ldGVyVmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAnJHtwYXJhbWV0ZXJOYW1lfScgaXMgbm90IGEgYmlnbnVtYmVyLWlzaGApO1xuICAgIH1cbn1cbi8qKlxuICogQHRocm93cyBUaHJvd3MgYSB0eXBlIGVycm9yIGlmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgdHlwZSBpcyBub3QgcGFydCBvZiB0aGUgbGlzdCBvZiB0eXBlcy5cbiAqIEBwYXJhbSBwYXJhbWV0ZXJWYWx1ZSBUaGUgcGFyYW1ldGVyIHZhbHVlLlxuICogQHBhcmFtIHBhcmFtZXRlck5hbWUgVGhlIHBhcmFtZXRlciBuYW1lLlxuICovXG5mdW5jdGlvbiByZXF1aXJlVHlwZXMocGFyYW1ldGVyVmFsdWUsIHBhcmFtZXRlck5hbWUsIHR5cGVzKSB7XG4gICAgZm9yIChjb25zdCB0eXBlIG9mIHR5cGVzKSB7XG4gICAgICAgIGlmICghaXNTdXBwb3J0ZWRUeXBlKHR5cGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFR5cGUgJyR7dHlwZX0nIGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgdHlwZXMpIHtcbiAgICAgICAgaWYgKGlzVHlwZShwYXJhbWV0ZXJWYWx1ZSwgdHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJyR7cGFyYW1ldGVyTmFtZX0nIGlzIG5vbmUgb2YgdGhlIGZvbGxvd2luZyB0eXBlczogJHt0eXBlcy5qb2luKFwiLCBcIil9YCk7XG59XG5cbnZhciBlcnJvckhhbmRsZXJzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICByZXF1aXJlQXJyYXk6IHJlcXVpcmVBcnJheSxcbiAgICByZXF1aXJlQmlnSW50OiByZXF1aXJlQmlnSW50LFxuICAgIHJlcXVpcmVCaWdOdW1iZXI6IHJlcXVpcmVCaWdOdW1iZXIsXG4gICAgcmVxdWlyZUJpZ051bWJlcmlzaDogcmVxdWlyZUJpZ051bWJlcmlzaCxcbiAgICByZXF1aXJlQm9vbGVhbjogcmVxdWlyZUJvb2xlYW4sXG4gICAgcmVxdWlyZUJ1ZmZlcjogcmVxdWlyZUJ1ZmZlcixcbiAgICByZXF1aXJlRGVmaW5lZDogcmVxdWlyZURlZmluZWQsXG4gICAgcmVxdWlyZUZ1bmN0aW9uOiByZXF1aXJlRnVuY3Rpb24sXG4gICAgcmVxdWlyZUhleGFkZWNpbWFsOiByZXF1aXJlSGV4YWRlY2ltYWwsXG4gICAgcmVxdWlyZU51bWJlcjogcmVxdWlyZU51bWJlcixcbiAgICByZXF1aXJlT2JqZWN0OiByZXF1aXJlT2JqZWN0LFxuICAgIHJlcXVpcmVTdHJpbmc6IHJlcXVpcmVTdHJpbmcsXG4gICAgcmVxdWlyZVN0cmluZ2lmaWVkQmlnSW50OiByZXF1aXJlU3RyaW5naWZpZWRCaWdJbnQsXG4gICAgcmVxdWlyZVR5cGVzOiByZXF1aXJlVHlwZXMsXG4gICAgcmVxdWlyZVVpbnQ4QXJyYXk6IHJlcXVpcmVVaW50OEFycmF5XG59KTtcblxuLyoqXG4gKiBAbW9kdWxlIENvbnZlcnNpb25zXG4gKiBUaGlzIG1vZHVsZSBwcm92aWRlcyBhIGNvbGxlY3Rpb24gb2YgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIGNvbnZlcnRpbmdcbiAqIGJldHdlZW4gZGlmZmVyZW50IG51bWVyaWNhbCBmb3JtYXRzLCBwYXJ0aWN1bGFybHkgZm9jdXNpbmcgb25cbiAqIGNvbnZlcnNpb25zIGludm9sdmluZyBiaWdpbnRzLCBoZXhhZGVjaW1hbHMgYW5kIGJ1ZmZlcnMuXG4gKiBUaGUgbW9kdWxlIGlzIHN0cnVjdHVyZWQgd2l0aCBjbGVhciBmdW5jdGlvbiBuYW1pbmcgdG8gaW5kaWNhdGVcbiAqIHRoZSBjb252ZXJzaW9uIGRpcmVjdGlvbiAoZS5nLiwgYGJpZ0ludFRvSGV4YWRlY2ltYWxgIGZvciBCaWdJbnRcbiAqIHRvIGhleGFkZWNpbWFsLCBgYnVmZmVyVG9CaWdJbnRgIGZvciBidWZmZXIgdG8gYmlnaW50KSBhbmQgZW1wbG95c1xuICogdHlwZSBjaGVja3MgdG8gZW5zdXJlIHRoZSBjb3JyZWN0IGhhbmRsaW5nIG9mIHZhcmlvdXMgaW5wdXQgdHlwZXMuXG4gKiBJdCBhbHNvIGluY2x1ZGVzIHZhcmlhdGlvbnMgZm9yIGJvdGggYmlnLWVuZGlhbiAoYGJlYCkgYW5kIGxpdHRsZS1lbmRpYW5cbiAqIChgbGVgKSBjb252ZXJzaW9ucy4gSXQgaXMgaW1wb3J0YW50IHRvIG5vdGUgdGhhdCB3aGVuIHRoZXJlIGlzIG5vIHByZWZpeCxcbiAqIHRoZSBvcmRlciBvZiBieXRlcyBpcyBhbHdheXMgYmlnLWVuZGlhbi5cbiAqL1xuLyoqXG4gKiBDb252ZXJ0cyBhIGJpZ2ludCB0byBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgYmlnaW50IHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgaGV4YWRlY2ltYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGJpZ2ludC5cbiAqL1xuZnVuY3Rpb24gYmlnSW50VG9IZXhhZGVjaW1hbCh2YWx1ZSkge1xuICAgIHJlcXVpcmVCaWdJbnQodmFsdWUsIFwidmFsdWVcIik7XG4gICAgbGV0IGhleCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICAvLyBFbnN1cmUgZXZlbiBsZW5ndGguXG4gICAgaWYgKGhleC5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgIGhleCA9IGAwJHtoZXh9YDtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8qKlxuICogQ29udmVydHMgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBiaWdpbnQuIFRoZSBpbnB1dCBpcyBpbnRlcnByZXRlZCBhcyBoZXhhZGVjaW1hbFxuICogd2l0aCBvciB3aXRob3V0IGEgJzB4JyBwcmVmaXguIEl0IHVzZXMgYmlnLWVuZGlhbiBieXRlIG9yZGVyLlxuICogQHBhcmFtIHZhbHVlIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBiaWdpbnQgcmVwcmVzZW50YXRpb24gb2YgdGhlIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gaGV4YWRlY2ltYWxUb0JpZ0ludCh2YWx1ZSkge1xuICAgIGlmICghaXNIZXhhZGVjaW1hbCh2YWx1ZSkgJiYgIWlzSGV4YWRlY2ltYWwodmFsdWUsIGZhbHNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJ3ZhbHVlJyBpcyBub3QgYSBoZXhhZGVjaW1hbCBzdHJpbmdgKTtcbiAgICB9XG4gICAgLy8gRW5zdXJlIHRoZSBoZXggc3RyaW5nIHN0YXJ0cyB3aXRoICcweCcuXG4gICAgY29uc3QgZm9ybWF0dGVkSGV4U3RyaW5nID0gdmFsdWUuc3RhcnRzV2l0aChcIjB4XCIpID8gdmFsdWUgOiBgMHgke3ZhbHVlfWA7XG4gICAgcmV0dXJuIEJpZ0ludChmb3JtYXR0ZWRIZXhTdHJpbmcpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGJ1ZmZlciBvZiBieXRlcyB0byBhIGJpZ2ludCB1c2luZyBiaWctZW5kaWFuIGJ5dGUgb3JkZXIuXG4gKiBJdCBhY2NlcHRzICdCdWZmZXInIG9yICdVaW50OEFycmF5Jy5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgYnVmZmVyIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgYmlnaW50IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBidWZmZXIncyBjb250ZW50cy5cbiAqL1xuZnVuY3Rpb24gYmVCdWZmZXJUb0JpZ0ludCh2YWx1ZSkge1xuICAgIHJlcXVpcmVUeXBlcyh2YWx1ZSwgXCJ2YWx1ZVwiLCBbXCJCdWZmZXJcIiwgXCJVaW50OEFycmF5XCJdKTtcbiAgICByZXR1cm4gQmlnSW50KGAweCR7QnVmZmVyLmZyb20odmFsdWUpLnRvU3RyaW5nKFwiaGV4XCIpfWApO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGJ1ZmZlciB0byBhIGJpZ2ludCB1c2luZyBsaXR0bGUtZW5kaWFuIGJ5dGUgb3JkZXIuXG4gKiBJdCBhY2NlcHRzICdCdWZmZXInIG9yICdVaW50OEFycmF5Jy5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgYnVmZmVyIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgYmlnaW50IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBidWZmZXIncyBjb250ZW50cyBpbiBsaXR0bGUtZW5kaWFuLlxuICovXG5mdW5jdGlvbiBsZUJ1ZmZlclRvQmlnSW50KHZhbHVlKSB7XG4gICAgcmVxdWlyZVR5cGVzKHZhbHVlLCBcInZhbHVlXCIsIFtcIkJ1ZmZlclwiLCBcIlVpbnQ4QXJyYXlcIl0pO1xuICAgIHJldHVybiBCaWdJbnQoYDB4JHtCdWZmZXIuZnJvbSh2YWx1ZSkucmV2ZXJzZSgpLnRvU3RyaW5nKFwiaGV4XCIpfWApO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGJ1ZmZlciB0byBhIGJpZ2ludC4gQWxpYXMgZm9yIGJlQnVmZmVyVG9CaWdJbnQuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIGJ1ZmZlciB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGJpZ2ludCByZXByZXNlbnRhdGlvbiBvZiB0aGUgYnVmZmVyJ3MgY29udGVudHMuXG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlclRvQmlnSW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIGJlQnVmZmVyVG9CaWdJbnQodmFsdWUpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGJpZ2ludCB0byBhIGJ1ZmZlciBhbmQgZmlsbHMgd2l0aCB6ZXJvcyBpZiBhIHZhbGlkXG4gKiBzaXplIChpLmUuIG51bWJlciBvZiBieXRlcykgaXMgc3BlY2lmaWVkLiBJZiB0aGUgc2l6ZSBpcyBub3QgZGVmaW5lZCxcbiAqIGl0IGdldHMgdGhlIHNpemUgZnJvbSB0aGUgZ2l2ZW4gYmlnaW50LiBJZiB0aGUgc3BlY2lmaWVkIHNpemUgaXMgc21hbGxlciB0aGFuXG4gKiB0aGUgc2l6ZSBvZiB0aGUgYmlnaW50IChpLmUuIGBtaW5TaXplYCksIGFuIGVycm9yIGlzIHRocm93bi5cbiAqIEl0IHVzZXMgYmlnLWVuZGlhbiBieXRlIG9yZGVyLlxuICogQHBhcmFtIHZhbHVlIFRoZSBiaWdpbnQgdG8gY29udmVydC5cbiAqIEBwYXJhbSBzaXplIFRoZSBudW1iZXIgb2YgYnl0ZXMgb2YgdGhlIGJ1ZmZlciB0byByZXR1cm4uXG4gKiBAcmV0dXJucyBUaGUgYnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBiaWdpbnQuXG4gKi9cbmZ1bmN0aW9uIGJlQmlnSW50VG9CdWZmZXIodmFsdWUsIHNpemUpIHtcbiAgICBjb25zdCBoZXggPSBiaWdJbnRUb0hleGFkZWNpbWFsKHZhbHVlKTtcbiAgICAvLyBDYWxjdWxhdGUgdGhlIG1pbmltdW0gYnVmZmVyIHNpemUgcmVxdWlyZWQgdG8gcmVwcmVzZW50ICduJyBpbiBieXRlcy5cbiAgICAvLyBFYWNoIGhleGFkZWNpbWFsIGNoYXJhY3RlciByZXByZXNlbnRzIDQgYml0cywgc28gMiBjaGFyYWN0ZXJzIGFyZSAxIGJ5dGUuXG4gICAgY29uc3QgbWluU2l6ZSA9IE1hdGguY2VpbChoZXgubGVuZ3RoIC8gMik7XG4gICAgaWYgKCFzaXplKSB7XG4gICAgICAgIHNpemUgPSBtaW5TaXplO1xuICAgIH1cbiAgICBlbHNlIGlmIChzaXplIDwgbWluU2l6ZSkge1xuICAgICAgICB0aHJvdyBFcnJvcihgU2l6ZSAke3NpemV9IGlzIHRvbyBzbWFsbCwgbmVlZCBhdCBsZWFzdCAke21pblNpemV9IGJ5dGVzYCk7XG4gICAgfVxuICAgIC8vIEFsbG9jYXRlIGJ1ZmZlciBvZiB0aGUgZGVzaXJlZCBzaXplLCBmaWxsZWQgd2l0aCB6ZXJvcy5cbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2Moc2l6ZSwgMCk7XG4gICAgY29uc3QgZnJvbUhleCA9IEJ1ZmZlci5mcm9tKGhleCwgXCJoZXhcIik7XG4gICAgZnJvbUhleC5jb3B5KGJ1ZmZlciwgc2l6ZSAtIGZyb21IZXgubGVuZ3RoKTtcbiAgICByZXR1cm4gYnVmZmVyO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGJpZ2ludCB0byBhIGJ1ZmZlciBhbmQgZmlsbHMgd2l0aCB6ZXJvcyBpZiBhIHZhbGlkXG4gKiBzaXplIChpLmUuIG51bWJlciBvZiBieXRlcykgaXMgc3BlY2lmaWVkLiBJZiB0aGUgc2l6ZSBpcyBub3QgZGVmaW5lZCxcbiAqIGl0IGdldHMgdGhlIHNpemUgZnJvbSB0aGUgZ2l2ZW4gYmlnaW50LiBJZiB0aGUgc3BlY2lmaWVkIHNpemUgaXMgc21hbGxlciB0aGFuXG4gKiB0aGUgc2l6ZSBvZiB0aGUgYmlnaW50IChpLmUuIGBtaW5TaXplYCksIGFuIGVycm9yIGlzIHRocm93bi5cbiAqIEl0IHVzZXMgbGl0dGxlLWVuZGlhbiBieXRlIG9yZGVyLlxuICogQHBhcmFtIHZhbHVlIFRoZSBiaWdpbnQgdG8gY29udmVydC5cbiAqIEBwYXJhbSBzaXplIFRoZSBudW1iZXIgb2YgYnl0ZXMgb2YgdGhlIGJ1ZmZlciB0byByZXR1cm4uXG4gKiBAcmV0dXJucyBUaGUgYnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBiaWdpbnQgaW4gbGl0dGxlLWVuZGlhbi5cbiAqL1xuZnVuY3Rpb24gbGVCaWdJbnRUb0J1ZmZlcih2YWx1ZSwgc2l6ZSkge1xuICAgIGNvbnN0IGhleCA9IGJpZ0ludFRvSGV4YWRlY2ltYWwodmFsdWUpO1xuICAgIC8vIENhbGN1bGF0ZSB0aGUgbWluaW11bSBidWZmZXIgc2l6ZSByZXF1aXJlZCB0byByZXByZXNlbnQgJ24nIGluIGJ5dGVzLlxuICAgIC8vIEVhY2ggaGV4YWRlY2ltYWwgY2hhcmFjdGVyIHJlcHJlc2VudHMgNCBiaXRzLCBzbyAyIGNoYXJhY3RlcnMgYXJlIDEgYnl0ZS5cbiAgICBjb25zdCBtaW5TaXplID0gTWF0aC5jZWlsKGhleC5sZW5ndGggLyAyKTtcbiAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgc2l6ZSA9IG1pblNpemU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNpemUgPCBtaW5TaXplKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBTaXplICR7c2l6ZX0gaXMgdG9vIHNtYWxsLCBuZWVkIGF0IGxlYXN0ICR7bWluU2l6ZX0gYnl0ZXNgKTtcbiAgICB9XG4gICAgLy8gQWxsb2NhdGUgYnVmZmVyIG9mIHRoZSBkZXNpcmVkIHNpemUsIGZpbGxlZCB3aXRoIHplcm9zLlxuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhzaXplLCAwKTtcbiAgICBjb25zdCBmcm9tSGV4ID0gQnVmZmVyLmZyb20oaGV4LCBcImhleFwiKS5yZXZlcnNlKCk7XG4gICAgZnJvbUhleC5jb3B5KGJ1ZmZlciwgMCk7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cbi8qKlxuICogQ29udmVydHMgYSBiaWdpbnQgdG8gYSBidWZmZXIuIEFsaWFzIGZvciBiZUJpZ0ludFRvQnVmZmVyLlxuICogQHBhcmFtIHZhbHVlIFRoZSBiaWdpbnQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBidWZmZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIGJpZ2ludC5cbiAqL1xuZnVuY3Rpb24gYmlnSW50VG9CdWZmZXIodmFsdWUpIHtcbiAgICByZXR1cm4gYmVCaWdJbnRUb0J1ZmZlcih2YWx1ZSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgQmlnTnVtYmVyaXNoIHR5cGUgdG8gYSBiaWdpbnQuIElmIHRoZSBpbnB1dCBpcyBhbHJlYWR5IGEgYmlnaW50LFxuICogdGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIHRoZSBiaWdpbnQgaXRzZWxmLCBvdGhlcndpc2UgaXQgd2lsbCBiZSBjb252ZXJ0ZWRcbiAqIHRvIGEgYmlnaW50IHVzaW5nIGJpZy1lbmRpYW4gYnl0ZSBvcmRlci5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgQmlnTnVtYmVyaXNoIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgYmlnaW50IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBCaWdOdW1iZXJpc2ggdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJpZ051bWJlcmlzaFRvQmlnSW50KHZhbHVlKSB7XG4gICAgcmVxdWlyZUJpZ051bWJlcmlzaCh2YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICBpZiAoaXNCdWZmZXIodmFsdWUpIHx8IGlzVWludDhBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlclRvQmlnSW50KHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgQmlnTnVtYmVyaXNoIHR5cGUgdG8gYSBidWZmZXIuIElmIHRoZSBpbnB1dCBpcyBhbHJlYWR5IGEgYnVmZmVyLFxuICogdGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIHRoZSBidWZmZXIgaXRzZWxmLCBvdGhlcndpc2UgaXQgd2lsbCBiZSBjb252ZXJ0ZWRcbiAqIHRvIGEgYnVmZmVyIHVzaW5nIGJpZy1lbmRpYW4gYnl0ZSBvcmRlci5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgQmlnTnVtYmVyaXNoIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgYnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBCaWdOdW1iZXJpc2ggdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJpZ051bWJlcmlzaFRvQnVmZmVyKHZhbHVlKSB7XG4gICAgcmVxdWlyZUJpZ051bWJlcmlzaCh2YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICBpZiAoaXNCdWZmZXIodmFsdWUpIHx8IGlzVWludDhBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGJpZ0ludFRvQnVmZmVyKGJpZ051bWJlcmlzaFRvQmlnSW50KHZhbHVlKSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIGhleGFkZWNpbWFsIHN0cmluZyB0byBhIGJ1ZmZlci4gVGhlIGhleGFkZWNpbWFsIHN0cmluZ1xuICogc2hvdWxkIG5vdCBzdGFydCB3aXRoICcweCcgb3IgJzBYJy4gSXQga2VlcHMgdGhlIGJ5dGVzIGluIHRoZSBzYW1lIG9yZGVyLlxuICogQHBhcmFtIHZhbHVlIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBidWZmZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gaGV4YWRlY2ltYWxUb0J1ZmZlcih2YWx1ZSkge1xuICAgIHJlcXVpcmVIZXhhZGVjaW1hbCh2YWx1ZSwgXCJ2YWx1ZVwiLCBmYWxzZSk7XG4gICAgLy8gRW5zdXJlIGV2ZW4gbGVuZ3RoIGJlZm9yZSBjb252ZXJ0aW5nIHRvIGJ1ZmZlci5cbiAgICBpZiAodmFsdWUubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICB2YWx1ZSA9IGAwJHt2YWx1ZX1gO1xuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUsIFwiaGV4XCIpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGJ1ZmZlciB0byBhIGhleGFkZWNpbWFsIHN0cmluZy4gSXQgYWNjZXB0cyAnQnVmZmVyJyBvciAnVWludDhBcnJheScuXG4gKiBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHdpbGwgbm90IHN0YXJ0IHdpdGggJzB4JyBvciAnMFgnLiBJdCBrZWVwcyB0aGUgYnl0ZXMgaW4gdGhlIHNhbWUgb3JkZXIuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIGJ1ZmZlciB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlclRvSGV4YWRlY2ltYWwodmFsdWUpIHtcbiAgICByZXF1aXJlVHlwZXModmFsdWUsIFwidmFsdWVcIiwgW1wiQnVmZmVyXCIsIFwiVWludDhBcnJheVwiXSk7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlKS50b1N0cmluZyhcImhleFwiKTtcbn1cbi8qKlxuICogQ29udmVydHMgYnl0ZXMgdG8gYSBiYXNlNjQgc3RyaW5nLiBJdCBhY2NlcHRzICdCdWZmZXInIG9yICdVaW50OEFycmF5Jy5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgYnl0ZXMgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBjb252ZXJ0ZWQgYmFzZTY0IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYnVmZmVyVG9CYXNlNjQodmFsdWUpIHtcbiAgICByZXF1aXJlVHlwZXModmFsdWUsIFwidmFsdWVcIiwgW1wiQnVmZmVyXCIsIFwiVWludDhBcnJheVwiXSk7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBiYXNlNjQgc3RyaW5nIHRvIGJ5dGVzIChpLmUuIGEgYnVmZmVyKS4gVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBjaGVja1xuICogaWYgdGhlIGlucHV0IHZhbHVlIGlzIGEgdmFsaWQgYmFzZTY0IHN0cmluZy4gSWYgdGhlcmUgYXJlIHVuc3VwcG9ydGVkIGNoYXJhY3RlcnNcbiAqIHRoZXkgd2lsbCBiZSBpZ25vcmVkLlxuICogQHBhcmFtIHZhbHVlIFRoZSBiYXNlNjQgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgY29udmVydGVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gYmFzZTY0VG9CdWZmZXIodmFsdWUpIHtcbiAgICByZXF1aXJlU3RyaW5nKHZhbHVlLCBcInZhbHVlXCIpO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZSwgXCJiYXNlNjRcIik7XG59XG4vKipcbiAqIENvbnZlcnRzIHRleHQgKHV0ZjgpIHRvIGEgYmFzZTY0IHN0cmluZy5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdGV4dCB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCBiYXNlNjQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB0ZXh0VG9CYXNlNjQodmFsdWUpIHtcbiAgICByZXF1aXJlU3RyaW5nKHZhbHVlLCBcInZhbHVlXCIpO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZSwgXCJ1dGY4XCIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGJhc2U2NCBzdHJpbmcgdG8gdGV4dCAodXRmOCkuIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgY2hlY2tcbiAqIGlmIHRoZSBpbnB1dCB2YWx1ZSBpcyBhIHZhbGlkIGJhc2U2NCBzdHJpbmcuIElmIHRoZXJlIGFyZSB1bnN1cHBvcnRlZCBjaGFyYWN0ZXJzXG4gKiB0aGV5IGNvdWxkIGJlIGlnbm9yZWQgYW5kIHRoZSByZXN1bHQgbWF5IGJlIHVuZXhwZWN0ZWQuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIGJhc2U2NCBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBjb252ZXJ0ZWQgdGV4dC5cbiAqL1xuZnVuY3Rpb24gYmFzZTY0VG9UZXh0KHZhbHVlKSB7XG4gICAgcmVxdWlyZVN0cmluZyh2YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKFwidXRmOFwiKTtcbn1cblxudmFyIGNvbnZlcnNpb25zID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBiYXNlNjRUb0J1ZmZlcjogYmFzZTY0VG9CdWZmZXIsXG4gICAgYmFzZTY0VG9UZXh0OiBiYXNlNjRUb1RleHQsXG4gICAgYmVCaWdJbnRUb0J1ZmZlcjogYmVCaWdJbnRUb0J1ZmZlcixcbiAgICBiZUJ1ZmZlclRvQmlnSW50OiBiZUJ1ZmZlclRvQmlnSW50LFxuICAgIGJpZ0ludFRvQnVmZmVyOiBiaWdJbnRUb0J1ZmZlcixcbiAgICBiaWdJbnRUb0hleGFkZWNpbWFsOiBiaWdJbnRUb0hleGFkZWNpbWFsLFxuICAgIGJpZ051bWJlcmlzaFRvQmlnSW50OiBiaWdOdW1iZXJpc2hUb0JpZ0ludCxcbiAgICBiaWdOdW1iZXJpc2hUb0J1ZmZlcjogYmlnTnVtYmVyaXNoVG9CdWZmZXIsXG4gICAgYnVmZmVyVG9CYXNlNjQ6IGJ1ZmZlclRvQmFzZTY0LFxuICAgIGJ1ZmZlclRvQmlnSW50OiBidWZmZXJUb0JpZ0ludCxcbiAgICBidWZmZXJUb0hleGFkZWNpbWFsOiBidWZmZXJUb0hleGFkZWNpbWFsLFxuICAgIGhleGFkZWNpbWFsVG9CaWdJbnQ6IGhleGFkZWNpbWFsVG9CaWdJbnQsXG4gICAgaGV4YWRlY2ltYWxUb0J1ZmZlcjogaGV4YWRlY2ltYWxUb0J1ZmZlcixcbiAgICBsZUJpZ0ludFRvQnVmZmVyOiBsZUJpZ0ludFRvQnVmZmVyLFxuICAgIGxlQnVmZmVyVG9CaWdJbnQ6IGxlQnVmZmVyVG9CaWdJbnQsXG4gICAgdGV4dFRvQmFzZTY0OiB0ZXh0VG9CYXNlNjRcbn0pO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSBzZXF1ZW5jZSBvZiBieXRlcyBzZWN1cmVseSB1c2luZyBOb2RlLmpzJ3MgY3J5cHRvIG1vZHVsZS5cbiAqIEBwYXJhbSBzaXplIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gZ2VuZXJhdGUuXG4gKiBAcmV0dXJucyBBIFVpbnQ4QXJyYXkgY29udGFpbmluZyB0aGUgZ2VuZXJhdGVkIHJhbmRvbSBieXRlcy5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L3ByZWZlci1kZWZhdWx0LWV4cG9ydCAqL1xuZnVuY3Rpb24gZ2V0UmFuZG9tVmFsdWVzKHNpemUpIHtcbiAgICBpZiAoc2l6ZSA8PSAwKVxuICAgICAgICB0aHJvdyBFcnJvcihgc2l6ZSAke3NpemV9IGlzIHRvbyBzbWFsbCwgbmVlZCBhdCBsZWFzdCAxYCk7XG4gICAgY29uc3QgYnVmZmVyID0gcmFuZG9tQnl0ZXMoc2l6ZSk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlci5idWZmZXIsIGJ1ZmZlci5ieXRlT2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aCk7XG59XG5cbnZhciBjcnlwdG9fbm9kZSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZ2V0UmFuZG9tVmFsdWVzOiBnZXRSYW5kb21WYWx1ZXNcbn0pO1xuXG4vKipcbiAqIEBtb2R1bGUgU2NhbGFyXG4gKiBUaGlzIG1vZHVsZSBwcm92aWRlcyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgcGVyZm9ybWluZyBzY2FsYXIgb3BlcmF0aW9uc1xuICogd2l0aGluIGEgZmllbGQsIGVzcGVjaWFsbHkgZGVzaWduZWQgdG8gaGFuZGxlIG9wZXJhdGlvbnMgb24gYmlnaW50cy5cbiAqIFRoZSBvcGVyYXRpb25zIGluY2x1ZGUgc2NhbGFyIGludmVyc2lvbiAoYGludmApLCBzY2FsYXIgZXhwb25lbnRpYXRpb24gKGBwb3dgKSxcbiAqIGFuZCBtb2R1bGFyIHJlZHVjdGlvbi4gRnVuY3Rpb25zIGFyZSBjYXJlZnVsbHkgaW1wbGVtZW50ZWQgdG8gZW5zdXJlXG4gKiBtYXRoZW1hdGljYWwgY29ycmVjdG5lc3MgYW5kIGVmZmljaWVuY3ksIHN1cHBvcnRpbmcgYm90aCBwb3NpdGl2ZSBhbmRcbiAqIG5lZ2F0aXZlIGJpZ2ludCB2YWx1ZXMuIFRoZSBtb2R1bGUgYWltcyB0byBwcm92aWRlIHJvYnVzdCB0b29scyBmb3JcbiAqIGNyeXB0b2dyYXBoaWMgY2FsY3VsYXRpb25zIGFuZCBvdGhlciBhcHBsaWNhdGlvbnMgcmVxdWlyaW5nIGhpZ2gtcHJlY2lzaW9uXG4gKiBhcml0aG1ldGljIGluIGZpZWxkcy5cbiAqL1xuLyoqXG4gKiBDaGVja3MgaWYgYSBiaWdpbnQgc2NhbGFyIHZhbHVlIGlzIHplcm8uXG4gKiBAcGFyYW0gYSBUaGUgYmlnaW50IHNjYWxhciB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFRydWUgaWYgJ2EnIGlzIHplcm8sIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNaZXJvKGEpIHtcbiAgICByZXR1cm4gIWE7XG59XG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhIGJpZ2ludCBzY2FsYXIgdmFsdWUgaXMgb2RkLlxuICogQHBhcmFtIGEgVGhlIGJpZ2ludCBzY2FsYXIgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBUcnVlIGlmICdhJyBpcyBvZGQsIGZhbHNlIGlmIGl0IGlzIGV2ZW4uXG4gKi9cbmZ1bmN0aW9uIGlzT2RkKGEpIHtcbiAgICByZXR1cm4gKGEgJiBCaWdJbnQoMSkpID09PSBCaWdJbnQoMSk7XG59XG4vKipcbiAqIFBlcmZvcm1zIGEgYml0d2lzZSByaWdodCBzaGlmdCBvbiBhIGJpZ2ludCBzY2FsYXIgdmFsdWUuXG4gKiBUaGlzIG9wZXJhdGlvbiBpcyBlcXVpdmFsZW50IHRvIGRpdmlkaW5nIGJ5IDJebiwgYnV0IGl0IG9wZXJhdGVzIGRpcmVjdGx5XG4gKiBvbiB0aGUgYmluYXJ5IHJlcHJlc2VudGF0aW9uLCBtYWtpbmcgaXQgZWZmaWNpZW50IGZvciBjZXJ0YWluIHR5cGVzIG9mIGNhbGN1bGF0aW9ucy5cbiAqIEBwYXJhbSBhIFRoZSBiaWdpbnQgc2NhbGFyIHZhbHVlIHRvIHNoaWZ0LlxuICogQHBhcmFtIG4gVGhlIG51bWJlciBvZiBiaXRzIHRvIHNoaWZ0ICdhJyBieS5cbiAqIEByZXR1cm5zIFRoZSByZXN1bHQgb2Ygc2hpZnRpbmcgJ2EnIHJpZ2h0IGJ5ICduJyBiaXRzLlxuICovXG5mdW5jdGlvbiBzaGlmdFJpZ2h0KGEsIG4pIHtcbiAgICByZXR1cm4gYSA+PiBuO1xufVxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBiaWdpbnQgc2NhbGFyIHZhbHVlcy5cbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCBiaWdpbnQgc2NhbGFyIHZhbHVlLlxuICogQHBhcmFtIGIgVGhlIHNlY29uZCBiaWdpbnQgc2NhbGFyIHZhbHVlLlxuICogQHJldHVybnMgVGhlIHByb2R1Y3Qgb2YgJ2EnIGFuZCAnYicuXG4gKi9cbmZ1bmN0aW9uIG11bChhLCBiKSB7XG4gICAgcmV0dXJuIGEgKiBiO1xufVxuLyoqXG4gKiBDb21wYXJlcyB0d28gYmlnaW50IHNjYWxhciB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZSBmaXJzdCBpcyBncmVhdGVyIHRoYW4gdGhlIHNlY29uZC5cbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCBiaWdpbnQgc2NhbGFyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0gYiBUaGUgc2Vjb25kIGJpZ2ludCBzY2FsYXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIFRydWUgaWYgJ2EnIGlzIGdyZWF0ZXIgdGhhbiAnYicsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gZ3QoYSwgYikge1xuICAgIHJldHVybiBhID4gYjtcbn1cbi8qKlxuICogQ29udmVydHMgYSBiaWdpbnQgc2NhbGFyIHZhbHVlIGludG8gYW4gYXJyYXkgb2YgYml0cywgcmVwcmVzZW50ZWQgYXMgbnVtYmVycy5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3IgZXhhbWluaW5nIHRoZSBiaW5hcnkgc3RydWN0dXJlIG9mIGJpZ2ludHMsXG4gKiB3aGljaCBjYW4gYmUgbmVjZXNzYXJ5IGZvciBiaXQgbWFuaXB1bGF0aW9uIGFuZCB1bmRlcnN0YW5kaW5nIHRoZSByZXByZXNlbnRhdGlvblxuICogb2YgbnVtYmVycyBhdCBhIGxvd2VyIGxldmVsLlxuICogQHBhcmFtIG4gVGhlIGJpZ2ludCBzY2FsYXIgdmFsdWUgdG8gY29udmVydCBpbnRvIGJpdHMuXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBudW1iZXJzIHJlcHJlc2VudGluZyB0aGUgYml0cyBvZiAnbicsIHN0YXJ0aW5nIGZyb20gdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdC5cbiAqL1xuZnVuY3Rpb24gYml0cyhuKSB7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgbGV0IEUgPSBuO1xuICAgIHdoaWxlIChFKSB7XG4gICAgICAgIGlmIChFICYgQmlnSW50KDEpKSB7XG4gICAgICAgICAgICByZXMucHVzaCgxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICAgIEUgPj49IEJpZ0ludCgxKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxudmFyIHNjYWxhciA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgYml0czogYml0cyxcbiAgICBndDogZ3QsXG4gICAgaXNPZGQ6IGlzT2RkLFxuICAgIGlzWmVybzogaXNaZXJvLFxuICAgIG11bDogbXVsLFxuICAgIHNoaWZ0UmlnaHQ6IHNoaWZ0UmlnaHRcbn0pO1xuXG4vKipcbiAqIEBjbGFzcyBGMUZpZWxkXG4gKiBSZXByZXNlbnRzIGEgZmluaXRlIGZpZWxkIG9mIG9yZGVyICdvcmRlcicgcHJvdmlkaW5nIGFyaXRobWV0aWMgb3BlcmF0aW9ucyB1bmRlciBtb2R1bHVzLlxuICogVGhpcyBjbGFzcyBpbmNsdWRlcyBvcGVyYXRpb25zIHN1Y2ggYXMgYWRkaXRpb24sIHN1YnRyYWN0aW9uLCBtdWx0aXBsaWNhdGlvbiwgZGl2aXNpb24sXG4gKiBhbmQgaW52ZXJzaW9uLCBhbGwgcGVyZm9ybWVkIG1vZHVsbyB0aGUgZmllbGQncyBvcmRlci4gSXQncyBkZXNpZ25lZCB0byB3b3JrIHdpdGggYmlnaW50cyxcbiAqIHN1cHBvcnRpbmcgbGFyZ2UgbnVtYmVycyBmb3IgY3J5cHRvZ3JhcGhpYyBwdXJwb3NlcyBhbmQgb3RoZXIgYXBwbGljYXRpb25zIHJlcXVpcmluZ1xuICogbW9kdWxhciBhcml0aG1ldGljLlxuICogTm90ZSB0aGF0IHRoZSBvdXRwdXRzIG9mIHRoZSBmdW5jdGlvbnMgd2lsbCBhbHdheXMgYmUgd2l0aGluIHRoZSBmaWVsZCBpZiBhbmQgb25seSBpZlxuICogdGhlIGlucHV0IHZhbHVlcyBhcmUgd2l0aGluIHRoZSBmaWVsZC4gRGV2cyBuZWVkIHRvIG1ha2Ugc3VyZSBvZiB0aGF0LlxuICpcbiAqIEBwcm9wZXJ0eSBvbmUgUmVwcmVzZW50cyB0aGUgc2NhbGFyIHZhbHVlIDEgaW4gdGhlIGZpZWxkLlxuICogQHByb3BlcnR5IHplcm8gUmVwcmVzZW50cyB0aGUgc2NhbGFyIHZhbHVlIDAgaW4gdGhlIGZpZWxkLlxuICogQHByb3BlcnR5IF9vcmRlciBUaGUgb3JkZXIgb2YgdGhlIGZpbml0ZSBmaWVsZCAoaS5lLiwgdGhlIG1vZHVsdXMpLlxuICogQHByb3BlcnR5IF9oYWxmIEhhbGYgdGhlIG9yZGVyIG9mIHRoZSBmaWVsZCwgdXNlZCBmb3IgY2VydGFpbiBjb21wYXJpc29ucy5cbiAqIEBwcm9wZXJ0eSBfbmVnb25lIFRoZSBzY2FsYXIgdmFsdWUgLTEgaW4gdGhlIGZpZWxkLCByZXByZXNlbnRlZCBwb3NpdGl2ZWx5LlxuICovXG5jbGFzcyBGMUZpZWxkIHtcbiAgICBjb25zdHJ1Y3RvcihvcmRlcikge1xuICAgICAgICB0aGlzLm9uZSA9IDFuO1xuICAgICAgICB0aGlzLnplcm8gPSAwbjtcbiAgICAgICAgdGhpcy5fb3JkZXIgPSBvcmRlcjtcbiAgICAgICAgdGhpcy5faGFsZiA9IG9yZGVyID4+IHRoaXMub25lO1xuICAgICAgICB0aGlzLl9uZWdvbmUgPSB0aGlzLl9vcmRlciAtIHRoaXMub25lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmVzIGEgZ2l2ZW4gcmVzdWx0IGZhbGxzIHdpdGhpbiB0aGUgZmllbGQgYnkgYXBwbHlpbmcgbW9kdWxhciByZWR1Y3Rpb24uXG4gICAgICogVGhpcyBtZXRob2QgYWxzbyBoYW5kbGVzIG5lZ2F0aXZlIGlucHV0cywgY29ycmVjdGx5IG1hcHBpbmcgdGhlbSBpbnRvIHRoZSBmaWVsZC5cbiAgICAgKiBAcGFyYW0gcmVzIFRoZSByZXN1bHQgdG8gYmUgbm9ybWFsaXplZCB0byB0aGUgZmllbGQuXG4gICAgICogQHJldHVybnMgVGhlIGVxdWl2YWxlbnQgdmFsdWUgd2l0aGluIHRoZSBmaWVsZC5cbiAgICAgKi9cbiAgICBlKHJlcykge1xuICAgICAgICByZXMgJT0gdGhpcy5fb3JkZXI7XG4gICAgICAgIHJldHVybiByZXMgPCAwID8gcmVzICsgdGhpcy5fb3JkZXIgOiByZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIG1vZHVsYXIgbXVsdGlwbGljYXRpb24gb2YgdHdvIGJpZ2ludCB2YWx1ZXMgd2l0aGluIHRoZSBmaWVsZC5cbiAgICAgKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmFsdWUuXG4gICAgICogQHBhcmFtIGIgVGhlIHNlY29uZCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgcHJvZHVjdCBvZiAnYScgYW5kICdiJyBtb2R1bG8gdGhlIGZpZWxkJ3Mgb3JkZXIuXG4gICAgICovXG4gICAgbXVsKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIChhICogYikgJSB0aGlzLl9vcmRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIG9uZSBiaWdpbnQgZnJvbSBhbm90aGVyIHVuZGVyIG1vZHVsdXMuXG4gICAgICogSXQgZW5zdXJlcyB0aGUgcmVzdWx0IGlzIHdpdGhpbiB0aGUgZmllbGQgaWYgYW5kIG9ubHkgaWYgdGhlIGlucHV0IHZhbHVlcyBhcmUgd2l0aGluIHRoZSBmaWVsZC5cbiAgICAgKiBAcGFyYW0gYSBUaGUgdmFsdWUgZnJvbSB3aGljaCB0byBzdWJ0cmFjdC5cbiAgICAgKiBAcGFyYW0gYiBUaGUgdmFsdWUgdG8gYmUgc3VidHJhY3RlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgZGlmZmVyZW5jZSBvZiAnYScgYW5kICdiJyBtb2R1bG8gdGhlIGZpZWxkJ3Mgb3JkZXIuXG4gICAgICovXG4gICAgc3ViKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPj0gYiA/IGEgLSBiIDogdGhpcy5fb3JkZXIgLSBiICsgYTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyB0d28gYmlnaW50IHZhbHVlcyB0b2dldGhlciB1bmRlciBtb2R1bHVzLlxuICAgICAqIEl0IGVuc3VyZXMgdGhlIHJlc3VsdCBpcyB3aXRoaW4gdGhlIGZpZWxkIGlmIGFuZCBvbmx5IGlmIHRoZSBpbnB1dCB2YWx1ZXMgYXJlIHdpdGhpbiB0aGUgZmllbGQuXG4gICAgICogQHBhcmFtIGEgVGhlIGZpcnN0IHZhbHVlLlxuICAgICAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmFsdWUuXG4gICAgICogQHJldHVybnMgVGhlIHN1bSBvZiAnYScgYW5kICdiJyBtb2R1bG8gdGhlIGZpZWxkJ3Mgb3JkZXIuXG4gICAgICovXG4gICAgYWRkKGEsIGIpIHtcbiAgICAgICAgY29uc3QgcmVzID0gYSArIGI7XG4gICAgICAgIHJldHVybiByZXMgPj0gdGhpcy5fb3JkZXIgPyByZXMgLSB0aGlzLl9vcmRlciA6IHJlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG11bHRpcGxpY2F0aXZlIGludmVyc2Ugb2YgYSBnaXZlbiB2YWx1ZSB3aXRoaW4gdGhlIGZpZWxkLlxuICAgICAqIFRoaXMgbWV0aG9kIHVzZXMgdGhlIEV4dGVuZGVkIEV1Y2xpZGVhbiBBbGdvcml0aG0gdG8gZmluZCB0aGUgaW52ZXJzZSxcbiAgICAgKiBlbnN1cmluZyB0aGUgcmVzdWx0IGlzIGFsd2F5cyBhIHBvc2l0aXZlIHZhbHVlIGxlc3MgdGhhbiB0aGUgZmllbGQncyBvcmRlci5cbiAgICAgKiBJZiB0aGUgaW5wdXQgdmFsdWUgaXMgemVybywgd2hpY2ggaGFzIG5vIGludmVyc2UsIGFuIGVycm9yIGlzIHRocm93bi5cbiAgICAgKiBAcGFyYW0gYSBUaGUgdmFsdWUgZm9yIHdoaWNoIHRvIGNvbXB1dGUgdGhlIGludmVyc2UuXG4gICAgICogQHJldHVybnMgVGhlIG11bHRpcGxpY2F0aXZlIGludmVyc2Ugb2YgJ2EnIG1vZHVsbyB0aGUgZmllbGQncyBvcmRlci5cbiAgICAgKiBAdGhyb3dzIGlmICdhJyBpcyB6ZXJvLlxuICAgICAqL1xuICAgIGludihhKSB7XG4gICAgICAgIGlmIChhID09PSB0aGlzLnplcm8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlplcm8gaGFzIG5vIGludmVyc2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHQgPSB0aGlzLnplcm87XG4gICAgICAgIGxldCByID0gdGhpcy5fb3JkZXI7XG4gICAgICAgIGxldCBuZXd0ID0gdGhpcy5vbmU7XG4gICAgICAgIGxldCBuZXdyID0gYSAlIHRoaXMuX29yZGVyO1xuICAgICAgICB3aGlsZSAobmV3cikge1xuICAgICAgICAgICAgY29uc3QgcSA9IHIgLyBuZXdyO1xuICAgICAgICAgICAgW3QsIG5ld3RdID0gW25ld3QsIHQgLSBxICogbmV3dF07XG4gICAgICAgICAgICBbciwgbmV3cl0gPSBbbmV3ciwgciAtIHEgKiBuZXdyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodCA8IHRoaXMuemVybykge1xuICAgICAgICAgICAgdCArPSB0aGlzLl9vcmRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBvbmUgYmlnaW50IGJ5IGFub3RoZXIgd2l0aGluIHRoZSBmaWVsZCBieSBtdWx0aXBseWluZyB0aGUgZmlyc3QgdmFsdWVcbiAgICAgKiBieSB0aGUgbXVsdGlwbGljYXRpdmUgaW52ZXJzZSBvZiB0aGUgc2Vjb25kLlxuICAgICAqIEBwYXJhbSBhIFRoZSBkaXZpZGVuZC5cbiAgICAgKiBAcGFyYW0gYiBUaGUgZGl2aXNvci5cbiAgICAgKiBAcmV0dXJucyBUaGUgcmVzdWx0IG9mIHRoZSBkaXZpc2lvbiBvZiAnYScgYnkgJ2InIG1vZHVsbyB0aGUgZmllbGQncyBvcmRlci5cbiAgICAgKi9cbiAgICBkaXYoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5tdWwoYSwgdGhpcy5pbnYoYikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdHdvIGJpZ2ludCB2YWx1ZXMgYXJlIGVxdWFsIHdpdGhpbiB0aGUgY29udGV4dCBvZiB0aGUgZmllbGQuXG4gICAgICogSXQgZW5zdXJlcyB0aGUgcmVzdWx0IGlzIHdpdGhpbiB0aGUgZmllbGQgaWYgYW5kIG9ubHkgaWYgdGhlIGlucHV0IHZhbHVlcyBhcmUgd2l0aGluIHRoZSBmaWVsZC5cbiAgICAgKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiAnYScgZXF1YWxzICdiJywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGVxKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNxdWFyZXMgYSBiaWdpbnQgdmFsdWUgd2l0aGluIHRoZSBmaWVsZC5cbiAgICAgKiBUaGlzIGlzIGEgc3BlY2lmaWMgY2FzZSBvZiBtdWx0aXBsaWNhdGlvbiB3aGVyZSB0aGUgdmFsdWUgaXMgbXVsdGlwbGllZCBieSBpdHNlbGYsXG4gICAgICogb3B0aW1pemVkIGZvciBwZXJmb3JtYW5jZSB3aGVyZSBhcHBsaWNhYmxlLlxuICAgICAqIEl0IGVuc3VyZXMgdGhlIHJlc3VsdCBpcyB3aXRoaW4gdGhlIGZpZWxkIGlmIGFuZCBvbmx5IGlmIHRoZSBpbnB1dCB2YWx1ZXMgYXJlIHdpdGhpbiB0aGUgZmllbGQuXG4gICAgICogQHBhcmFtIGEgVGhlIHZhbHVlIHRvIHNxdWFyZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgc3F1YXJlIG9mICdhJyBtb2R1bG8gdGhlIGZpZWxkJ3Mgb3JkZXIuXG4gICAgICovXG4gICAgc3F1YXJlKGEpIHtcbiAgICAgICAgcmV0dXJuIChhICogYSkgJSB0aGlzLl9vcmRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdHdvIGJpZ2ludCB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZSBmaXJzdCBpcyBsZXNzIHRoYW4gdGhlIHNlY29uZCxcbiAgICAgKiB0YWtpbmcgaW50byBhY2NvdW50IHRoZSBmaWVsZCdzIG9yZGVyIGZvciBtb2R1bGFyIGNvbXBhcmlzb24uXG4gICAgICogSXQgZW5zdXJlcyB0aGUgcmVzdWx0IGlzIHdpdGhpbiB0aGUgZmllbGQgaWYgYW5kIG9ubHkgaWYgdGhlIGlucHV0IHZhbHVlcyBhcmUgd2l0aGluIHRoZSBmaWVsZC5cbiAgICAgKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiAnYScgaXMgbGVzcyB0aGFuICdiJywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGx0KGEsIGIpIHtcbiAgICAgICAgY29uc3QgYWEgPSBhID4gdGhpcy5faGFsZiA/IGEgLSB0aGlzLl9vcmRlciA6IGE7XG4gICAgICAgIGNvbnN0IGJiID0gYiA+IHRoaXMuX2hhbGYgPyBiIC0gdGhpcy5fb3JkZXIgOiBiO1xuICAgICAgICByZXR1cm4gYWEgPCBiYjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdHdvIGJpZ2ludCB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZSBmaXJzdCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHNlY29uZCxcbiAgICAgKiBjb25zaWRlcmluZyB0aGUgZmllbGQncyBtb2R1bGFyIGNvbnRleHQuXG4gICAgICogSXQgZW5zdXJlcyB0aGUgcmVzdWx0IGlzIHdpdGhpbiB0aGUgZmllbGQgaWYgYW5kIG9ubHkgaWYgdGhlIGlucHV0IHZhbHVlcyBhcmUgd2l0aGluIHRoZSBmaWVsZC5cbiAgICAgKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiAnYScgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICdiJywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGdlcShhLCBiKSB7XG4gICAgICAgIGNvbnN0IGFhID0gYSA+IHRoaXMuX2hhbGYgPyBhIC0gdGhpcy5fb3JkZXIgOiBhO1xuICAgICAgICBjb25zdCBiYiA9IGIgPiB0aGlzLl9oYWxmID8gYiAtIHRoaXMuX29yZGVyIDogYjtcbiAgICAgICAgcmV0dXJuIGFhID49IGJiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbmVnYXRpb24gb2YgYSBiaWdpbnQgdmFsdWUgd2l0aGluIHRoZSBmaWVsZC5cbiAgICAgKiBUaGUgcmVzdWx0IGlzIHRoZSBtb2R1bGFyIGFkZGl0aXZlIGludmVyc2UgdGhhdCwgd2hlbiBhZGRlZCB0byB0aGUgb3JpZ2luYWwgdmFsdWUsXG4gICAgICogeWllbGRzIHplcm8gaW4gdGhlIGZpZWxkJ3MgbW9kdWx1cy5cbiAgICAgKiBJdCBlbnN1cmVzIHRoZSByZXN1bHQgaXMgd2l0aGluIHRoZSBmaWVsZCBpZiBhbmQgb25seSBpZiB0aGUgaW5wdXQgdmFsdWVzIGFyZSB3aXRoaW4gdGhlIGZpZWxkLlxuICAgICAqIEBwYXJhbSBhIFRoZSB2YWx1ZSB0byBuZWdhdGUuXG4gICAgICogQHJldHVybnMgVGhlIG5lZ2F0aW9uIG9mICdhJyBtb2R1bG8gdGhlIGZpZWxkJ3Mgb3JkZXIuXG4gICAgICovXG4gICAgbmVnKGEpIHtcbiAgICAgICAgcmV0dXJuIGEgPyB0aGlzLl9vcmRlciAtIGEgOiBhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBiaWdpbnQgdmFsdWUgaXMgemVybyB3aXRoaW4gdGhlIGNvbnRleHQgb2YgdGhlIGZpZWxkLlxuICAgICAqIEBwYXJhbSBhIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmICdhJyBpcyB6ZXJvLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNaZXJvKGEpIHtcbiAgICAgICAgcmV0dXJuIGEgPT09IHRoaXMuemVybztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmFpc2VzIGEgYmFzZSB0byBhbiBleHBvbmVudCB3aXRoaW4gdGhlIGZpZWxkLCBlZmZpY2llbnRseSBjb21wdXRpbmdcbiAgICAgKiBzY2FsYXIgZXhwb25lbnRpYXRpb24gdXNpbmcgdGhlIHNxdWFyZS1hbmQtbXVsdGlwbHkgYWxnb3JpdGhtLlxuICAgICAqIFN1cHBvcnRzIGJvdGggcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIGV4cG9uZW50cyB0aHJvdWdoIHRoZSB1c2Ugb2YgdGhlIGBpbnZgIG1ldGhvZCBmb3IgbmVnYXRpdmVzLlxuICAgICAqIEBwYXJhbSBiYXNlIFRoZSBiYXNlIHRvIGJlIGV4cG9uZW50aWF0ZWQuXG4gICAgICogQHBhcmFtIGUgVGhlIGV4cG9uZW50LlxuICAgICAqIEByZXR1cm5zIFRoZSByZXN1bHQgb2YgcmFpc2luZyAnYmFzZScgdG8gdGhlIHBvd2VyICdlJyBtb2R1bG8gdGhlIGZpZWxkJ3Mgb3JkZXIuXG4gICAgICovXG4gICAgcG93KGJhc2UsIGUpIHtcbiAgICAgICAgaWYgKGlzWmVybyhlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub25lO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlIDwgMG4pIHtcbiAgICAgICAgICAgIGJhc2UgPSB0aGlzLmludihiYXNlKTtcbiAgICAgICAgICAgIGUgPSAtZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuID0gYml0cyhlKTtcbiAgICAgICAgaWYgKG4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbmU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlcyA9IGJhc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSBuLmxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgICByZXMgPSB0aGlzLnNxdWFyZShyZXMpO1xuICAgICAgICAgICAgaWYgKG5baV0pIHtcbiAgICAgICAgICAgICAgICByZXMgPSB0aGlzLm11bChyZXMsIGJhc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuXG4vKipcbiAqIEBtb2R1bGUgUHJvb2ZQYWNraW5nXG4gKlxuICogVGhpcyBtb2R1bGUgcHJvdmlkZXMgdXRpbGl0eSBmdW5jdGlvbnMgdG8gcGFjayBhbmQgdW5wYWNrXG4gKiB2YXJpb3VzIHR5cGVzIG9mIG9iamVjdHMsIG1ha2luZyBpdCBlYXNpZXIgdG8gZXhwb3J0IG9yIHVzZVxuICogdGhlbSBleHRlcm5hbGx5LlxuICovXG4vKipcbiAqIFBhY2tzIGEgU25hcmtqcyBHcm90aDE2IHByb29mIGludG8gYSBzaW5nbGUgbGlzdCB1c2FibGUgYXMgY2FsbGRhdGEgaW4gU29saWRpdHkgKHB1YmxpYyBzaWduYWxzIGFyZSBub3QgaW5jbHVkZWQpLlxuICogQHBhcmFtIHByb29mIFRoZSBHcm90aDE2IHByb29mIGdlbmVyYXRlZCB3aXRoIFNuYXJrSlMuXG4gKiBAcmV0dXJucyBTb2xpZGl0eSBjYWxsZGF0YS5cbiAqL1xuZnVuY3Rpb24gcGFja0dyb3RoMTZQcm9vZihwcm9vZikge1xuICAgIHJldHVybiBbXG4gICAgICAgIHByb29mLnBpX2FbMF0sXG4gICAgICAgIHByb29mLnBpX2FbMV0sXG4gICAgICAgIHByb29mLnBpX2JbMF1bMV0sXG4gICAgICAgIHByb29mLnBpX2JbMF1bMF0sXG4gICAgICAgIHByb29mLnBpX2JbMV1bMV0sXG4gICAgICAgIHByb29mLnBpX2JbMV1bMF0sXG4gICAgICAgIHByb29mLnBpX2NbMF0sXG4gICAgICAgIHByb29mLnBpX2NbMV1cbiAgICBdO1xufVxuLyoqXG4gKiBVbnBhY2tzIGEgUGFja2VkR3JvdGgxNlByb29mIFNvbGlkaXR5IGNhbGxkYXRhIGludG8gaXRzIG9yaWdpbmFsIGZvcm0gd2hpY2ggaXMgYSBTbmFya0pTIEdyb3RoMTYgcHJvb2YuXG4gKiBAcGFyYW0gcHJvb2YgU29saWRpdHkgY2FsbGRhdGEuXG4gKiBAcmV0dXJucyBUaGUgR3JvdGgxNiBwcm9vZiBjb21wYXRpYmxlIHdpdGggU25hcmtKUy5cbiAqL1xuZnVuY3Rpb24gdW5wYWNrR3JvdGgxNlByb29mKHByb29mKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGlfYTogW3Byb29mWzBdLCBwcm9vZlsxXV0sXG4gICAgICAgIHBpX2I6IFtcbiAgICAgICAgICAgIFtwcm9vZlszXSwgcHJvb2ZbMl1dLFxuICAgICAgICAgICAgW3Byb29mWzVdLCBwcm9vZls0XV1cbiAgICAgICAgXSxcbiAgICAgICAgcGlfYzogW3Byb29mWzZdLCBwcm9vZls3XV0sXG4gICAgICAgIHByb3RvY29sOiBcImdyb3RoMTZcIixcbiAgICAgICAgY3VydmU6IFwiYm4xMjhcIlxuICAgIH07XG59XG4vKipcbiAqIFBhY2tzIGEgU25hcmtqcyBQbG9uayBwcm9vZiBpbnRvIGEgc2luZ2xlIGxpc3QgdXNhYmxlIGFzIGNhbGxkYXRhIGluIFNvbGlkaXR5IChwdWJsaWMgc2lnbmFscyBhcmUgbm90IGluY2x1ZGVkKS5cbiAqIEBwYXJhbSBwcm9vZiBUaGUgUGxvbmsgcHJvb2YgZ2VuZXJhdGVkIHdpdGggU25hcmtKUy5cbiAqIEByZXR1cm5zIFNvbGlkaXR5IGNhbGxkYXRhLlxuICovXG5mdW5jdGlvbiBwYWNrUGxvbmtQcm9vZihwcm9vZikge1xuICAgIHJldHVybiBbXG4gICAgICAgIHByb29mLkFbMF0sXG4gICAgICAgIHByb29mLkFbMV0sXG4gICAgICAgIHByb29mLkJbMF0sXG4gICAgICAgIHByb29mLkJbMV0sXG4gICAgICAgIHByb29mLkNbMF0sXG4gICAgICAgIHByb29mLkNbMV0sXG4gICAgICAgIHByb29mLlpbMF0sXG4gICAgICAgIHByb29mLlpbMV0sXG4gICAgICAgIHByb29mLlQxWzBdLFxuICAgICAgICBwcm9vZi5UMVsxXSxcbiAgICAgICAgcHJvb2YuVDJbMF0sXG4gICAgICAgIHByb29mLlQyWzFdLFxuICAgICAgICBwcm9vZi5UM1swXSxcbiAgICAgICAgcHJvb2YuVDNbMV0sXG4gICAgICAgIHByb29mLld4aVswXSxcbiAgICAgICAgcHJvb2YuV3hpWzFdLFxuICAgICAgICBwcm9vZi5XeGl3WzBdLFxuICAgICAgICBwcm9vZi5XeGl3WzFdLFxuICAgICAgICBwcm9vZi5ldmFsX2EsXG4gICAgICAgIHByb29mLmV2YWxfYixcbiAgICAgICAgcHJvb2YuZXZhbF9jLFxuICAgICAgICBwcm9vZi5ldmFsX3MxLFxuICAgICAgICBwcm9vZi5ldmFsX3MyLFxuICAgICAgICBwcm9vZi5ldmFsX3p3XG4gICAgXTtcbn1cbi8qKlxuICogVW5wYWNrcyBhIFBhY2tlZFBsb25rUHJvb2YgU29saWRpdHkgY2FsbGRhdGEgaW50byBpdHMgb3JpZ2luYWwgZm9ybSB3aGljaCBpcyBhIFNuYXJrSlMgUGxvbmsgcHJvb2YuXG4gKiBAcGFyYW0gcHJvb2YgU29saWRpdHkgY2FsbGRhdGEuXG4gKiBAcmV0dXJucyBUaGUgUGxvbmsgcHJvb2YgY29tcGF0aWJsZSB3aXRoIFNuYXJrSlMuXG4gKi9cbmZ1bmN0aW9uIHVucGFja1Bsb25rUHJvb2YocHJvb2YpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBBOiBbcHJvb2ZbMF0sIHByb29mWzFdXSxcbiAgICAgICAgQjogW3Byb29mWzJdLCBwcm9vZlszXV0sXG4gICAgICAgIEM6IFtwcm9vZls0XSwgcHJvb2ZbNV1dLFxuICAgICAgICBaOiBbcHJvb2ZbNl0sIHByb29mWzddXSxcbiAgICAgICAgVDE6IFtwcm9vZls4XSwgcHJvb2ZbOV1dLFxuICAgICAgICBUMjogW3Byb29mWzEwXSwgcHJvb2ZbMTFdXSxcbiAgICAgICAgVDM6IFtwcm9vZlsxMl0sIHByb29mWzEzXV0sXG4gICAgICAgIFd4aTogW3Byb29mWzE0XSwgcHJvb2ZbMTVdXSxcbiAgICAgICAgV3hpdzogW3Byb29mWzE2XSwgcHJvb2ZbMTddXSxcbiAgICAgICAgZXZhbF9hOiBwcm9vZlsxOF0sXG4gICAgICAgIGV2YWxfYjogcHJvb2ZbMTldLFxuICAgICAgICBldmFsX2M6IHByb29mWzIwXSxcbiAgICAgICAgZXZhbF9zMTogcHJvb2ZbMjFdLFxuICAgICAgICBldmFsX3MyOiBwcm9vZlsyMl0sXG4gICAgICAgIGV2YWxfenc6IHByb29mWzIzXSxcbiAgICAgICAgcHJvdG9jb2w6IFwicGxvbmtcIixcbiAgICAgICAgY3VydmU6IFwiYm4xMjhcIlxuICAgIH07XG59XG4vKipcbiAqIFBhY2tzIGEgU25hcmtqcyBGZmxvbmsgcHJvb2YgaW50byBhIHNpbmdsZSBsaXN0IHVzYWJsZSBhcyBjYWxsZGF0YSBpbiBTb2xpZGl0eSAocHVibGljIHNpZ25hbHMgYXJlIG5vdCBpbmNsdWRlZCkuXG4gKiBAcGFyYW0gcHJvb2YgVGhlIEZmbG9uayBwcm9vZiBnZW5lcmF0ZWQgd2l0aCBTbmFya0pTLlxuICogQHJldHVybnMgU29saWRpdHkgY2FsbGRhdGEuXG4gKi9cbmZ1bmN0aW9uIHBhY2tGZmxvbmtQcm9vZihwcm9vZikge1xuICAgIHJldHVybiBbXG4gICAgICAgIHplcm9QYWRWYWx1ZSh0b0JlSGV4KHRvQmlnSW50KHByb29mLnBvbHlub21pYWxzLkMxWzBdKSksIDMyKSxcbiAgICAgICAgemVyb1BhZFZhbHVlKHRvQmVIZXgodG9CaWdJbnQocHJvb2YucG9seW5vbWlhbHMuQzFbMV0pKSwgMzIpLFxuICAgICAgICB6ZXJvUGFkVmFsdWUodG9CZUhleCh0b0JpZ0ludChwcm9vZi5wb2x5bm9taWFscy5DMlswXSkpLCAzMiksXG4gICAgICAgIHplcm9QYWRWYWx1ZSh0b0JlSGV4KHRvQmlnSW50KHByb29mLnBvbHlub21pYWxzLkMyWzFdKSksIDMyKSxcbiAgICAgICAgemVyb1BhZFZhbHVlKHRvQmVIZXgodG9CaWdJbnQocHJvb2YucG9seW5vbWlhbHMuVzFbMF0pKSwgMzIpLFxuICAgICAgICB6ZXJvUGFkVmFsdWUodG9CZUhleCh0b0JpZ0ludChwcm9vZi5wb2x5bm9taWFscy5XMVsxXSkpLCAzMiksXG4gICAgICAgIHplcm9QYWRWYWx1ZSh0b0JlSGV4KHRvQmlnSW50KHByb29mLnBvbHlub21pYWxzLlcyWzBdKSksIDMyKSxcbiAgICAgICAgemVyb1BhZFZhbHVlKHRvQmVIZXgodG9CaWdJbnQocHJvb2YucG9seW5vbWlhbHMuVzJbMV0pKSwgMzIpLFxuICAgICAgICB6ZXJvUGFkVmFsdWUodG9CZUhleCh0b0JpZ0ludChwcm9vZi5ldmFsdWF0aW9ucy5xbCkpLCAzMiksXG4gICAgICAgIHplcm9QYWRWYWx1ZSh0b0JlSGV4KHRvQmlnSW50KHByb29mLmV2YWx1YXRpb25zLnFyKSksIDMyKSxcbiAgICAgICAgemVyb1BhZFZhbHVlKHRvQmVIZXgodG9CaWdJbnQocHJvb2YuZXZhbHVhdGlvbnMucW0pKSwgMzIpLFxuICAgICAgICB6ZXJvUGFkVmFsdWUodG9CZUhleCh0b0JpZ0ludChwcm9vZi5ldmFsdWF0aW9ucy5xbykpLCAzMiksXG4gICAgICAgIHplcm9QYWRWYWx1ZSh0b0JlSGV4KHRvQmlnSW50KHByb29mLmV2YWx1YXRpb25zLnFjKSksIDMyKSxcbiAgICAgICAgemVyb1BhZFZhbHVlKHRvQmVIZXgodG9CaWdJbnQocHJvb2YuZXZhbHVhdGlvbnMuczEpKSwgMzIpLFxuICAgICAgICB6ZXJvUGFkVmFsdWUodG9CZUhleCh0b0JpZ0ludChwcm9vZi5ldmFsdWF0aW9ucy5zMikpLCAzMiksXG4gICAgICAgIHplcm9QYWRWYWx1ZSh0b0JlSGV4KHRvQmlnSW50KHByb29mLmV2YWx1YXRpb25zLnMzKSksIDMyKSxcbiAgICAgICAgemVyb1BhZFZhbHVlKHRvQmVIZXgodG9CaWdJbnQocHJvb2YuZXZhbHVhdGlvbnMuYSkpLCAzMiksXG4gICAgICAgIHplcm9QYWRWYWx1ZSh0b0JlSGV4KHRvQmlnSW50KHByb29mLmV2YWx1YXRpb25zLmIpKSwgMzIpLFxuICAgICAgICB6ZXJvUGFkVmFsdWUodG9CZUhleCh0b0JpZ0ludChwcm9vZi5ldmFsdWF0aW9ucy5jKSksIDMyKSxcbiAgICAgICAgemVyb1BhZFZhbHVlKHRvQmVIZXgodG9CaWdJbnQocHJvb2YuZXZhbHVhdGlvbnMueikpLCAzMiksXG4gICAgICAgIHplcm9QYWRWYWx1ZSh0b0JlSGV4KHRvQmlnSW50KHByb29mLmV2YWx1YXRpb25zLnp3KSksIDMyKSxcbiAgICAgICAgemVyb1BhZFZhbHVlKHRvQmVIZXgodG9CaWdJbnQocHJvb2YuZXZhbHVhdGlvbnMudDF3KSksIDMyKSxcbiAgICAgICAgemVyb1BhZFZhbHVlKHRvQmVIZXgodG9CaWdJbnQocHJvb2YuZXZhbHVhdGlvbnMudDJ3KSksIDMyKSxcbiAgICAgICAgemVyb1BhZFZhbHVlKHRvQmVIZXgodG9CaWdJbnQocHJvb2YuZXZhbHVhdGlvbnMuaW52KSksIDMyKVxuICAgIF07XG59XG4vKipcbiAqIFVucGFja3MgYSBQYWNrZWRGZmxvbmtQcm9vZiBTb2xpZGl0eSBjYWxsZGF0YSBpbnRvIGl0cyBvcmlnaW5hbCBmb3JtIHdoaWNoIGlzIGEgU25hcmtKUyBGZmxvbmsgcHJvb2YuXG4gKiBAcGFyYW0gcHJvb2YgU29saWRpdHkgY2FsbGRhdGEuXG4gKiBAcmV0dXJucyBUaGUgRmZsb25rIHByb29mIGNvbXBhdGlibGUgd2l0aCBTbmFya0pTLlxuICovXG5mdW5jdGlvbiB1bnBhY2tGZmxvbmtQcm9vZihwcm9vZikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHBvbHlub21pYWxzOiB7XG4gICAgICAgICAgICBDMTogW3RvQmlnSW50KHByb29mWzBdKS50b1N0cmluZygpLCB0b0JpZ0ludChwcm9vZlsxXSkudG9TdHJpbmcoKV0sXG4gICAgICAgICAgICBDMjogW3RvQmlnSW50KHByb29mWzJdKS50b1N0cmluZygpLCB0b0JpZ0ludChwcm9vZlszXSkudG9TdHJpbmcoKV0sXG4gICAgICAgICAgICBXMTogW3RvQmlnSW50KHByb29mWzRdKS50b1N0cmluZygpLCB0b0JpZ0ludChwcm9vZls1XSkudG9TdHJpbmcoKV0sXG4gICAgICAgICAgICBXMjogW3RvQmlnSW50KHByb29mWzZdKS50b1N0cmluZygpLCB0b0JpZ0ludChwcm9vZls3XSkudG9TdHJpbmcoKV1cbiAgICAgICAgfSxcbiAgICAgICAgZXZhbHVhdGlvbnM6IHtcbiAgICAgICAgICAgIHFsOiB0b0JpZ0ludChwcm9vZls4XSkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHFyOiB0b0JpZ0ludChwcm9vZls5XSkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHFtOiB0b0JpZ0ludChwcm9vZlsxMF0pLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBxbzogdG9CaWdJbnQocHJvb2ZbMTFdKS50b1N0cmluZygpLFxuICAgICAgICAgICAgcWM6IHRvQmlnSW50KHByb29mWzEyXSkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHMxOiB0b0JpZ0ludChwcm9vZlsxM10pLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBzMjogdG9CaWdJbnQocHJvb2ZbMTRdKS50b1N0cmluZygpLFxuICAgICAgICAgICAgczM6IHRvQmlnSW50KHByb29mWzE1XSkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGE6IHRvQmlnSW50KHByb29mWzE2XSkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGI6IHRvQmlnSW50KHByb29mWzE3XSkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGM6IHRvQmlnSW50KHByb29mWzE4XSkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHo6IHRvQmlnSW50KHByb29mWzE5XSkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHp3OiB0b0JpZ0ludChwcm9vZlsyMF0pLnRvU3RyaW5nKCksXG4gICAgICAgICAgICB0MXc6IHRvQmlnSW50KHByb29mWzIxXSkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHQydzogdG9CaWdJbnQocHJvb2ZbMjJdKS50b1N0cmluZygpLFxuICAgICAgICAgICAgaW52OiB0b0JpZ0ludChwcm9vZlsyM10pLnRvU3RyaW5nKClcbiAgICAgICAgfSxcbiAgICAgICAgcHJvdG9jb2w6IFwiZmZsb25rXCIsXG4gICAgICAgIGN1cnZlOiBcImJuMTI4XCJcbiAgICB9O1xufVxuXG52YXIgcHJvb2ZQYWNraW5nID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBwYWNrRmZsb25rUHJvb2Y6IHBhY2tGZmxvbmtQcm9vZixcbiAgICBwYWNrR3JvdGgxNlByb29mOiBwYWNrR3JvdGgxNlByb29mLFxuICAgIHBhY2tQbG9ua1Byb29mOiBwYWNrUGxvbmtQcm9vZixcbiAgICB1bnBhY2tGZmxvbmtQcm9vZjogdW5wYWNrRmZsb25rUHJvb2YsXG4gICAgdW5wYWNrR3JvdGgxNlByb29mOiB1bnBhY2tHcm90aDE2UHJvb2YsXG4gICAgdW5wYWNrUGxvbmtQcm9vZjogdW5wYWNrUGxvbmtQcm9vZlxufSk7XG5cbmV4cG9ydCB7IEYxRmllbGQsIGJhc2U2NFRvQnVmZmVyLCBiYXNlNjRUb1RleHQsIGJlQmlnSW50VG9CdWZmZXIsIGJlQnVmZmVyVG9CaWdJbnQsIGJpZ0ludFRvQnVmZmVyLCBiaWdJbnRUb0hleGFkZWNpbWFsLCBiaWdOdW1iZXJpc2hUb0JpZ0ludCwgYmlnTnVtYmVyaXNoVG9CdWZmZXIsIGJ1ZmZlclRvQmFzZTY0LCBidWZmZXJUb0JpZ0ludCwgYnVmZmVyVG9IZXhhZGVjaW1hbCwgY29udmVyc2lvbnMsIGNyeXB0b19ub2RlIGFzIGNyeXB0bywgZXJyb3JIYW5kbGVycywgaGV4YWRlY2ltYWxUb0JpZ0ludCwgaGV4YWRlY2ltYWxUb0J1ZmZlciwgaXNBcnJheSwgaXNCaWdJbnQsIGlzQmlnTnVtYmVyLCBpc0JpZ051bWJlcmlzaCwgaXNCb29sZWFuLCBpc0J1ZmZlciwgaXNEZWZpbmVkLCBpc0Z1bmN0aW9uLCBpc0hleGFkZWNpbWFsLCBpc051bWJlciwgaXNPYmplY3QsIGlzU3RyaW5nLCBpc1N0cmluZ2lmaWVkQmlnSW50LCBpc1N1cHBvcnRlZFR5cGUsIGlzVHlwZSwgaXNVaW50OEFycmF5LCBsZUJpZ0ludFRvQnVmZmVyLCBsZUJ1ZmZlclRvQmlnSW50LCBwYWNrRmZsb25rUHJvb2YsIHBhY2tHcm90aDE2UHJvb2YsIHBhY2tQbG9ua1Byb29mLCBwcm9vZlBhY2tpbmcgYXMgcGFja2luZywgcmVxdWlyZUFycmF5LCByZXF1aXJlQmlnSW50LCByZXF1aXJlQmlnTnVtYmVyLCByZXF1aXJlQmlnTnVtYmVyaXNoLCByZXF1aXJlQm9vbGVhbiwgcmVxdWlyZUJ1ZmZlciwgcmVxdWlyZURlZmluZWQsIHJlcXVpcmVGdW5jdGlvbiwgcmVxdWlyZUhleGFkZWNpbWFsLCByZXF1aXJlTnVtYmVyLCByZXF1aXJlT2JqZWN0LCByZXF1aXJlU3RyaW5nLCByZXF1aXJlU3RyaW5naWZpZWRCaWdJbnQsIHJlcXVpcmVUeXBlcywgcmVxdWlyZVVpbnQ4QXJyYXksIHNjYWxhciwgc3VwcG9ydGVkVHlwZXMsIHRleHRUb0Jhc2U2NCwgdHlwZUNoZWNrcywgdW5wYWNrRmZsb25rUHJvb2YsIHVucGFja0dyb3RoMTZQcm9vZiwgdW5wYWNrUGxvbmtQcm9vZiB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@zk-kit/utils/dist/index.node.js\n");

/***/ })

};
;