/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/popup/page"],{

/***/ "(app-pages-browser)/./node_modules/@pcd/passport-interface/dist/esm/src/PassportPopup/core.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@pcd/passport-interface/dist/esm/src/PassportPopup/core.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   openZupassPopup: () => (/* binding */ openZupassPopup),\n/* harmony export */   openZupassPopupUrl: () => (/* binding */ openZupassPopupUrl),\n/* harmony export */   receiveZupassPopupMessage: () => (/* binding */ receiveZupassPopupMessage),\n/* harmony export */   zupassPopupExecute: () => (/* binding */ zupassPopupExecute),\n/* harmony export */   zupassPopupSetup: () => (/* binding */ zupassPopupSetup)\n/* harmony export */ });\n/*\n * Call this function on a dedicated /popup page in your app to integrate your\n * app with the Zupass proving/auth popup flow. The popup flow is optional,\n * as you could also just redirect to Zupass in the same page, but the popup\n * gives authentication a more oauth feel, which users are already familiar\n * with.\n *\n * Navigates the current window to a `proofUrl` provided in the query\n * parameters (if any), or posts a message to the window's opener if the query\n * parameters contain a valid result (either an encoded PCD or an encoded\n * pending PCD). If a message is sent, the current window is also closed\n * immediately. This functionality is only valid in a popup window.\n *\n * The /popup page's URL is provided to {@link openZupassPopup} as the popupUrl\n * parameter.\n */\nasync function zupassPopupSetup() {\n    if (!window.opener) {\n        return \"zupassPopupSetup() can only be called from within a popup window\";\n    }\n    let params;\n    // Hash routing is commonly used in web applications to enable client-side\n    // routing without requiring server-side configuration, typically single-page applications.\n    // Without hash routing, the server should always serve the same index.html file for any route.\n    // Some providers, like Github Pages, don't provide this feature.\n    // To read the parameters of a URL with hash routing, the hash must first be removed.\n    if (window.location.href.includes(window.location.origin + \"/#/\")) {\n        const url = new URL(window.location.href.replace(\"#\", \"\"));\n        params = url.searchParams;\n    }\n    else {\n        params = new URLSearchParams(window.location.search);\n    }\n    const paramsProofUrl = params.get(\"proofUrl\");\n    const paramsProof = params.get(\"proof\");\n    const paramsEncodingPendingPCD = params.get(\"encodedPendingPCD\");\n    const finished = params.get(\"finished\");\n    // If we have a proof URL, we should direct the user to that URL first.\n    if (paramsProofUrl) {\n        window.location.href = paramsProofUrl;\n    }\n    else if (finished) {\n        // Later, Zupass redirects back with a result. Send it to our parent.\n        if (paramsProof) {\n            window.opener.postMessage({ encodedPCD: paramsProof }, \"*\");\n        }\n        window.close();\n        // Almost certainly the window will close. But if, for some reason, it\n        // does not then we should return a string that will be shown as an error\n        // message. Wait a few seconds, so the error message doesn't \"flash\" up as\n        // the screen is closing.\n        await new Promise((resolve) => window.setTimeout(() => resolve(), 1000 * 3));\n        return \"Finished. Please close this window.\";\n    }\n    else if (paramsEncodingPendingPCD) {\n        // Later, Zupass redirects back with a encodedPendingPCD. Send it to our parent.\n        window.opener.postMessage({ encodedPendingPCD: paramsEncodingPendingPCD }, \"*\");\n        window.close();\n        await new Promise((resolve) => window.setTimeout(() => resolve(), 1000 * 3));\n        return \"Finished. Please close this window.\";\n    }\n}\n/**\n * Open up a Zupass popup window on a local popup page, which will redirect to\n * Zupass. Once the action is complete, Zupass will redirect back, and the\n * local page will send a message to its opener and close itself. See\n * {@link zupassPopupSetup} and {@link receiveZupassPopupMessage}.\n *\n * @param {string} popupUrl is a URL to the local page that hosts some\n * JavaScript calling {@link zupassPopupSetup}\n * @param {string} proofUrl is a URL pointing to Zupass, and should be\n * generated using the construct*url() functions in ../PassportInterface.ts\n */\nfunction openZupassPopup(popupUrl, proofUrl) {\n    const url = `${popupUrl}?proofUrl=${encodeURIComponent(proofUrl)}`;\n    return openZupassPopupUrl(url);\n}\n/**\n * Opens a Zupass popup window to a given URL. Can be used to open Zupass\n * directly, allowing Zupass to send a message back and bypassing the need for\n * a special page to redirect.\n */\nfunction openZupassPopupUrl(url) {\n    // Calling window.open from within a React hook can cause problems.\n    // The workaround is to do it asynchronously, as per:\n    // https://stackoverflow.com/questions/76944918/should-not-already-be-working-on-window-open-in-simple-react-app\n    return new Promise((resolve) => window.setTimeout(() => resolve(window.open(url, \"_blank\", \"width=450,height=600,top=100,popup\")), 0));\n}\n/**\n * Asynchronous function that listens for PCDs and PendingPCDs from a Zupass\n * popup window using message passing and event listeners.\n */\nfunction receiveZupassPopupMessage(signal) {\n    return new Promise((resolve) => {\n        const receiveMessage = (ev) => {\n            if (ev.data.encodedPCD) {\n                resolve({ type: \"pcd\", pcdStr: ev.data.encodedPCD });\n                window.removeEventListener(\"message\", receiveMessage);\n            }\n            else if (ev.data.encodedPendingPCD) {\n                resolve({\n                    type: \"pendingPcd\",\n                    pendingPcdStr: ev.data.encodedPendingPCD\n                });\n                window.removeEventListener(\"message\", receiveMessage);\n            }\n            else if (ev.data.multiplePCDs) {\n                resolve({\n                    type: \"multi-pcd\",\n                    pcds: JSON.parse(ev.data.multiplePCDs)\n                });\n                window.removeEventListener(\"message\", receiveMessage);\n            }\n        };\n        window.addEventListener(\"message\", receiveMessage, {\n            // Remove this event listener automatically if abort signal fires.\n            signal\n        });\n        signal.addEventListener(\"abort\", () => {\n            resolve({ type: \"aborted\" });\n        });\n    });\n}\n/**\n * An asynchronous function that opens a Zupass popup window, and returns a\n * {@link PopupActionResult} containing either:\n * - An encoded PCD\n * - An encoded pending PCD\n * - An indication that the popup was closed with no result\n * - An indication that the popup was blocked from opening\n *\n * By detecting popup blockers and the popup being closed without result, this\n * offers broader functionality than calling {@link openZupassPopupWithLocalRedirect} and\n * {@link receiveZupassPopupMessage} separately. It is added as a new API to\n * avoid breaking backwards-compatibility for existing code.\n */\nasync function zupassPopupExecute(proofUrl, popupUrl) {\n    const popup = await (popupUrl\n        ? openZupassPopup(proofUrl, popupUrl)\n        : openZupassPopupUrl(proofUrl));\n    // If we did not get a window from `openZupassPopup`, it was blocked\n    // See https://developer.mozilla.org/en-US/docs/Web/API/Window/open#return_value\n    // This allows the caller to gracefully handle this, e.g. by notifying the\n    // user\n    if (!popup) {\n        return { type: \"popupBlocked\" };\n    }\n    // If the popup is closed, the promise waiting for an event from the popup\n    // will not know that this has happened, and so will remain unresolved\n    // forever, leaking memory. To avoid this, we pass in an AbortController to\n    // receiveZupassPopupMessage(), which allows it to resolve.\n    // This is necessary even when using Promise.race(), as Promise.race() will\n    // not clean up the unresolved promises even after they have definitely\n    // \"lost\" the race.\n    const abortReceiveMessage = new AbortController();\n    // There's no way to receive an event indicating that a popup window has been\n    // closed, and we can't rely on the code running inside the popup to send us\n    // a message, so instead we have to check for it on a timer.\n    // We are doing this in order to detect cases in which the popup window is\n    // closed without any action being taken (e.g. a proof being generated).\n    const closePromise = new Promise((resolve) => {\n        const closeCheckInterval = window.setInterval(() => {\n            if (popup.closed) {\n                clearInterval(closeCheckInterval);\n                // In the case where an action is completed, the popup will send a\n                // message, and then close itself. In testing, it seems that the\n                // message is always received before we pick up on the fact that the\n                // popup is closed. However, for safety, we will avoid resolving this\n                // promise for another 250ms, to ensure that the other promise\n                // (containing the received message) definitely resolves first.\n                window.setTimeout(() => {\n                    resolve({ type: \"popupClosed\" });\n                    // In the event that the message-receiving promise has *not*\n                    // resolved, we need to tell it to resolve now, to avoid a memory\n                    // leak.\n                    abortReceiveMessage.abort();\n                }, 250);\n            }\n        }, 100);\n    });\n    // Race the closing of the window against the receipt of a message, and\n    // return whichever resolves first.\n    return Promise.race([\n        closePromise,\n        receiveZupassPopupMessage(abortReceiveMessage.signal)\n    ]);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGNkL3Bhc3Nwb3J0LWludGVyZmFjZS9kaXN0L2VzbS9zcmMvUGFzc3BvcnRQb3B1cC9jb3JlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsdUJBQXVCO0FBQ2hFO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx5QkFBeUI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw2Q0FBNkM7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3QkFBd0IsS0FBSyxnQ0FBZ0M7QUFDakU7QUFDQSxXQUFXLFFBQVE7QUFDbkIsdUJBQXVCO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ087QUFDUCxtQkFBbUIsU0FBUyxZQUFZLDZCQUE2QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIseUNBQXlDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QyxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUkseUJBQXlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx3Q0FBd0M7QUFDdEYsSUFBSSxpQ0FBaUM7QUFDckM7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixxQkFBcUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvY2hhbmNlbWNhbGxpc3Rlci9Qcm9qZWN0cy96dXBhc3NodW50L25vZGVfbW9kdWxlcy9AcGNkL3Bhc3Nwb3J0LWludGVyZmFjZS9kaXN0L2VzbS9zcmMvUGFzc3BvcnRQb3B1cC9jb3JlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDYWxsIHRoaXMgZnVuY3Rpb24gb24gYSBkZWRpY2F0ZWQgL3BvcHVwIHBhZ2UgaW4geW91ciBhcHAgdG8gaW50ZWdyYXRlIHlvdXJcbiAqIGFwcCB3aXRoIHRoZSBadXBhc3MgcHJvdmluZy9hdXRoIHBvcHVwIGZsb3cuIFRoZSBwb3B1cCBmbG93IGlzIG9wdGlvbmFsLFxuICogYXMgeW91IGNvdWxkIGFsc28ganVzdCByZWRpcmVjdCB0byBadXBhc3MgaW4gdGhlIHNhbWUgcGFnZSwgYnV0IHRoZSBwb3B1cFxuICogZ2l2ZXMgYXV0aGVudGljYXRpb24gYSBtb3JlIG9hdXRoIGZlZWwsIHdoaWNoIHVzZXJzIGFyZSBhbHJlYWR5IGZhbWlsaWFyXG4gKiB3aXRoLlxuICpcbiAqIE5hdmlnYXRlcyB0aGUgY3VycmVudCB3aW5kb3cgdG8gYSBgcHJvb2ZVcmxgIHByb3ZpZGVkIGluIHRoZSBxdWVyeVxuICogcGFyYW1ldGVycyAoaWYgYW55KSwgb3IgcG9zdHMgYSBtZXNzYWdlIHRvIHRoZSB3aW5kb3cncyBvcGVuZXIgaWYgdGhlIHF1ZXJ5XG4gKiBwYXJhbWV0ZXJzIGNvbnRhaW4gYSB2YWxpZCByZXN1bHQgKGVpdGhlciBhbiBlbmNvZGVkIFBDRCBvciBhbiBlbmNvZGVkXG4gKiBwZW5kaW5nIFBDRCkuIElmIGEgbWVzc2FnZSBpcyBzZW50LCB0aGUgY3VycmVudCB3aW5kb3cgaXMgYWxzbyBjbG9zZWRcbiAqIGltbWVkaWF0ZWx5LiBUaGlzIGZ1bmN0aW9uYWxpdHkgaXMgb25seSB2YWxpZCBpbiBhIHBvcHVwIHdpbmRvdy5cbiAqXG4gKiBUaGUgL3BvcHVwIHBhZ2UncyBVUkwgaXMgcHJvdmlkZWQgdG8ge0BsaW5rIG9wZW5adXBhc3NQb3B1cH0gYXMgdGhlIHBvcHVwVXJsXG4gKiBwYXJhbWV0ZXIuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB6dXBhc3NQb3B1cFNldHVwKCkge1xuICAgIGlmICghd2luZG93Lm9wZW5lcikge1xuICAgICAgICByZXR1cm4gXCJ6dXBhc3NQb3B1cFNldHVwKCkgY2FuIG9ubHkgYmUgY2FsbGVkIGZyb20gd2l0aGluIGEgcG9wdXAgd2luZG93XCI7XG4gICAgfVxuICAgIGxldCBwYXJhbXM7XG4gICAgLy8gSGFzaCByb3V0aW5nIGlzIGNvbW1vbmx5IHVzZWQgaW4gd2ViIGFwcGxpY2F0aW9ucyB0byBlbmFibGUgY2xpZW50LXNpZGVcbiAgICAvLyByb3V0aW5nIHdpdGhvdXQgcmVxdWlyaW5nIHNlcnZlci1zaWRlIGNvbmZpZ3VyYXRpb24sIHR5cGljYWxseSBzaW5nbGUtcGFnZSBhcHBsaWNhdGlvbnMuXG4gICAgLy8gV2l0aG91dCBoYXNoIHJvdXRpbmcsIHRoZSBzZXJ2ZXIgc2hvdWxkIGFsd2F5cyBzZXJ2ZSB0aGUgc2FtZSBpbmRleC5odG1sIGZpbGUgZm9yIGFueSByb3V0ZS5cbiAgICAvLyBTb21lIHByb3ZpZGVycywgbGlrZSBHaXRodWIgUGFnZXMsIGRvbid0IHByb3ZpZGUgdGhpcyBmZWF0dXJlLlxuICAgIC8vIFRvIHJlYWQgdGhlIHBhcmFtZXRlcnMgb2YgYSBVUkwgd2l0aCBoYXNoIHJvdXRpbmcsIHRoZSBoYXNoIG11c3QgZmlyc3QgYmUgcmVtb3ZlZC5cbiAgICBpZiAod2luZG93LmxvY2F0aW9uLmhyZWYuaW5jbHVkZXMod2luZG93LmxvY2F0aW9uLm9yaWdpbiArIFwiLyMvXCIpKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYucmVwbGFjZShcIiNcIiwgXCJcIikpO1xuICAgICAgICBwYXJhbXMgPSB1cmwuc2VhcmNoUGFyYW1zO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1zUHJvb2ZVcmwgPSBwYXJhbXMuZ2V0KFwicHJvb2ZVcmxcIik7XG4gICAgY29uc3QgcGFyYW1zUHJvb2YgPSBwYXJhbXMuZ2V0KFwicHJvb2ZcIik7XG4gICAgY29uc3QgcGFyYW1zRW5jb2RpbmdQZW5kaW5nUENEID0gcGFyYW1zLmdldChcImVuY29kZWRQZW5kaW5nUENEXCIpO1xuICAgIGNvbnN0IGZpbmlzaGVkID0gcGFyYW1zLmdldChcImZpbmlzaGVkXCIpO1xuICAgIC8vIElmIHdlIGhhdmUgYSBwcm9vZiBVUkwsIHdlIHNob3VsZCBkaXJlY3QgdGhlIHVzZXIgdG8gdGhhdCBVUkwgZmlyc3QuXG4gICAgaWYgKHBhcmFtc1Byb29mVXJsKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gcGFyYW1zUHJvb2ZVcmw7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpbmlzaGVkKSB7XG4gICAgICAgIC8vIExhdGVyLCBadXBhc3MgcmVkaXJlY3RzIGJhY2sgd2l0aCBhIHJlc3VsdC4gU2VuZCBpdCB0byBvdXIgcGFyZW50LlxuICAgICAgICBpZiAocGFyYW1zUHJvb2YpIHtcbiAgICAgICAgICAgIHdpbmRvdy5vcGVuZXIucG9zdE1lc3NhZ2UoeyBlbmNvZGVkUENEOiBwYXJhbXNQcm9vZiB9LCBcIipcIik7XG4gICAgICAgIH1cbiAgICAgICAgd2luZG93LmNsb3NlKCk7XG4gICAgICAgIC8vIEFsbW9zdCBjZXJ0YWlubHkgdGhlIHdpbmRvdyB3aWxsIGNsb3NlLiBCdXQgaWYsIGZvciBzb21lIHJlYXNvbiwgaXRcbiAgICAgICAgLy8gZG9lcyBub3QgdGhlbiB3ZSBzaG91bGQgcmV0dXJuIGEgc3RyaW5nIHRoYXQgd2lsbCBiZSBzaG93biBhcyBhbiBlcnJvclxuICAgICAgICAvLyBtZXNzYWdlLiBXYWl0IGEgZmV3IHNlY29uZHMsIHNvIHRoZSBlcnJvciBtZXNzYWdlIGRvZXNuJ3QgXCJmbGFzaFwiIHVwIGFzXG4gICAgICAgIC8vIHRoZSBzY3JlZW4gaXMgY2xvc2luZy5cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHJlc29sdmUoKSwgMTAwMCAqIDMpKTtcbiAgICAgICAgcmV0dXJuIFwiRmluaXNoZWQuIFBsZWFzZSBjbG9zZSB0aGlzIHdpbmRvdy5cIjtcbiAgICB9XG4gICAgZWxzZSBpZiAocGFyYW1zRW5jb2RpbmdQZW5kaW5nUENEKSB7XG4gICAgICAgIC8vIExhdGVyLCBadXBhc3MgcmVkaXJlY3RzIGJhY2sgd2l0aCBhIGVuY29kZWRQZW5kaW5nUENELiBTZW5kIGl0IHRvIG91ciBwYXJlbnQuXG4gICAgICAgIHdpbmRvdy5vcGVuZXIucG9zdE1lc3NhZ2UoeyBlbmNvZGVkUGVuZGluZ1BDRDogcGFyYW1zRW5jb2RpbmdQZW5kaW5nUENEIH0sIFwiKlwiKTtcbiAgICAgICAgd2luZG93LmNsb3NlKCk7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKCksIDEwMDAgKiAzKSk7XG4gICAgICAgIHJldHVybiBcIkZpbmlzaGVkLiBQbGVhc2UgY2xvc2UgdGhpcyB3aW5kb3cuXCI7XG4gICAgfVxufVxuLyoqXG4gKiBPcGVuIHVwIGEgWnVwYXNzIHBvcHVwIHdpbmRvdyBvbiBhIGxvY2FsIHBvcHVwIHBhZ2UsIHdoaWNoIHdpbGwgcmVkaXJlY3QgdG9cbiAqIFp1cGFzcy4gT25jZSB0aGUgYWN0aW9uIGlzIGNvbXBsZXRlLCBadXBhc3Mgd2lsbCByZWRpcmVjdCBiYWNrLCBhbmQgdGhlXG4gKiBsb2NhbCBwYWdlIHdpbGwgc2VuZCBhIG1lc3NhZ2UgdG8gaXRzIG9wZW5lciBhbmQgY2xvc2UgaXRzZWxmLiBTZWVcbiAqIHtAbGluayB6dXBhc3NQb3B1cFNldHVwfSBhbmQge0BsaW5rIHJlY2VpdmVadXBhc3NQb3B1cE1lc3NhZ2V9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwb3B1cFVybCBpcyBhIFVSTCB0byB0aGUgbG9jYWwgcGFnZSB0aGF0IGhvc3RzIHNvbWVcbiAqIEphdmFTY3JpcHQgY2FsbGluZyB7QGxpbmsgenVwYXNzUG9wdXBTZXR1cH1cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9vZlVybCBpcyBhIFVSTCBwb2ludGluZyB0byBadXBhc3MsIGFuZCBzaG91bGQgYmVcbiAqIGdlbmVyYXRlZCB1c2luZyB0aGUgY29uc3RydWN0KnVybCgpIGZ1bmN0aW9ucyBpbiAuLi9QYXNzcG9ydEludGVyZmFjZS50c1xuICovXG5leHBvcnQgZnVuY3Rpb24gb3Blblp1cGFzc1BvcHVwKHBvcHVwVXJsLCBwcm9vZlVybCkge1xuICAgIGNvbnN0IHVybCA9IGAke3BvcHVwVXJsfT9wcm9vZlVybD0ke2VuY29kZVVSSUNvbXBvbmVudChwcm9vZlVybCl9YDtcbiAgICByZXR1cm4gb3Blblp1cGFzc1BvcHVwVXJsKHVybCk7XG59XG4vKipcbiAqIE9wZW5zIGEgWnVwYXNzIHBvcHVwIHdpbmRvdyB0byBhIGdpdmVuIFVSTC4gQ2FuIGJlIHVzZWQgdG8gb3BlbiBadXBhc3NcbiAqIGRpcmVjdGx5LCBhbGxvd2luZyBadXBhc3MgdG8gc2VuZCBhIG1lc3NhZ2UgYmFjayBhbmQgYnlwYXNzaW5nIHRoZSBuZWVkIGZvclxuICogYSBzcGVjaWFsIHBhZ2UgdG8gcmVkaXJlY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvcGVuWnVwYXNzUG9wdXBVcmwodXJsKSB7XG4gICAgLy8gQ2FsbGluZyB3aW5kb3cub3BlbiBmcm9tIHdpdGhpbiBhIFJlYWN0IGhvb2sgY2FuIGNhdXNlIHByb2JsZW1zLlxuICAgIC8vIFRoZSB3b3JrYXJvdW5kIGlzIHRvIGRvIGl0IGFzeW5jaHJvbm91c2x5LCBhcyBwZXI6XG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzY5NDQ5MTgvc2hvdWxkLW5vdC1hbHJlYWR5LWJlLXdvcmtpbmctb24td2luZG93LW9wZW4taW4tc2ltcGxlLXJlYWN0LWFwcFxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gd2luZG93LnNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZSh3aW5kb3cub3Blbih1cmwsIFwiX2JsYW5rXCIsIFwid2lkdGg9NDUwLGhlaWdodD02MDAsdG9wPTEwMCxwb3B1cFwiKSksIDApKTtcbn1cbi8qKlxuICogQXN5bmNocm9ub3VzIGZ1bmN0aW9uIHRoYXQgbGlzdGVucyBmb3IgUENEcyBhbmQgUGVuZGluZ1BDRHMgZnJvbSBhIFp1cGFzc1xuICogcG9wdXAgd2luZG93IHVzaW5nIG1lc3NhZ2UgcGFzc2luZyBhbmQgZXZlbnQgbGlzdGVuZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVjZWl2ZVp1cGFzc1BvcHVwTWVzc2FnZShzaWduYWwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY29uc3QgcmVjZWl2ZU1lc3NhZ2UgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGlmIChldi5kYXRhLmVuY29kZWRQQ0QpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHsgdHlwZTogXCJwY2RcIiwgcGNkU3RyOiBldi5kYXRhLmVuY29kZWRQQ0QgfSk7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHJlY2VpdmVNZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2LmRhdGEuZW5jb2RlZFBlbmRpbmdQQ0QpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJwZW5kaW5nUGNkXCIsXG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdQY2RTdHI6IGV2LmRhdGEuZW5jb2RlZFBlbmRpbmdQQ0RcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgcmVjZWl2ZU1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXYuZGF0YS5tdWx0aXBsZVBDRHMpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJtdWx0aS1wY2RcIixcbiAgICAgICAgICAgICAgICAgICAgcGNkczogSlNPTi5wYXJzZShldi5kYXRhLm11bHRpcGxlUENEcylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgcmVjZWl2ZU1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgcmVjZWl2ZU1lc3NhZ2UsIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGlzIGV2ZW50IGxpc3RlbmVyIGF1dG9tYXRpY2FsbHkgaWYgYWJvcnQgc2lnbmFsIGZpcmVzLlxuICAgICAgICAgICAgc2lnbmFsXG4gICAgICAgIH0pO1xuICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoeyB0eXBlOiBcImFib3J0ZWRcIiB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4vKipcbiAqIEFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0aGF0IG9wZW5zIGEgWnVwYXNzIHBvcHVwIHdpbmRvdywgYW5kIHJldHVybnMgYVxuICoge0BsaW5rIFBvcHVwQWN0aW9uUmVzdWx0fSBjb250YWluaW5nIGVpdGhlcjpcbiAqIC0gQW4gZW5jb2RlZCBQQ0RcbiAqIC0gQW4gZW5jb2RlZCBwZW5kaW5nIFBDRFxuICogLSBBbiBpbmRpY2F0aW9uIHRoYXQgdGhlIHBvcHVwIHdhcyBjbG9zZWQgd2l0aCBubyByZXN1bHRcbiAqIC0gQW4gaW5kaWNhdGlvbiB0aGF0IHRoZSBwb3B1cCB3YXMgYmxvY2tlZCBmcm9tIG9wZW5pbmdcbiAqXG4gKiBCeSBkZXRlY3RpbmcgcG9wdXAgYmxvY2tlcnMgYW5kIHRoZSBwb3B1cCBiZWluZyBjbG9zZWQgd2l0aG91dCByZXN1bHQsIHRoaXNcbiAqIG9mZmVycyBicm9hZGVyIGZ1bmN0aW9uYWxpdHkgdGhhbiBjYWxsaW5nIHtAbGluayBvcGVuWnVwYXNzUG9wdXBXaXRoTG9jYWxSZWRpcmVjdH0gYW5kXG4gKiB7QGxpbmsgcmVjZWl2ZVp1cGFzc1BvcHVwTWVzc2FnZX0gc2VwYXJhdGVseS4gSXQgaXMgYWRkZWQgYXMgYSBuZXcgQVBJIHRvXG4gKiBhdm9pZCBicmVha2luZyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgZXhpc3RpbmcgY29kZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHp1cGFzc1BvcHVwRXhlY3V0ZShwcm9vZlVybCwgcG9wdXBVcmwpIHtcbiAgICBjb25zdCBwb3B1cCA9IGF3YWl0IChwb3B1cFVybFxuICAgICAgICA/IG9wZW5adXBhc3NQb3B1cChwcm9vZlVybCwgcG9wdXBVcmwpXG4gICAgICAgIDogb3Blblp1cGFzc1BvcHVwVXJsKHByb29mVXJsKSk7XG4gICAgLy8gSWYgd2UgZGlkIG5vdCBnZXQgYSB3aW5kb3cgZnJvbSBgb3Blblp1cGFzc1BvcHVwYCwgaXQgd2FzIGJsb2NrZWRcbiAgICAvLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy9vcGVuI3JldHVybl92YWx1ZVxuICAgIC8vIFRoaXMgYWxsb3dzIHRoZSBjYWxsZXIgdG8gZ3JhY2VmdWxseSBoYW5kbGUgdGhpcywgZS5nLiBieSBub3RpZnlpbmcgdGhlXG4gICAgLy8gdXNlclxuICAgIGlmICghcG9wdXApIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJwb3B1cEJsb2NrZWRcIiB9O1xuICAgIH1cbiAgICAvLyBJZiB0aGUgcG9wdXAgaXMgY2xvc2VkLCB0aGUgcHJvbWlzZSB3YWl0aW5nIGZvciBhbiBldmVudCBmcm9tIHRoZSBwb3B1cFxuICAgIC8vIHdpbGwgbm90IGtub3cgdGhhdCB0aGlzIGhhcyBoYXBwZW5lZCwgYW5kIHNvIHdpbGwgcmVtYWluIHVucmVzb2x2ZWRcbiAgICAvLyBmb3JldmVyLCBsZWFraW5nIG1lbW9yeS4gVG8gYXZvaWQgdGhpcywgd2UgcGFzcyBpbiBhbiBBYm9ydENvbnRyb2xsZXIgdG9cbiAgICAvLyByZWNlaXZlWnVwYXNzUG9wdXBNZXNzYWdlKCksIHdoaWNoIGFsbG93cyBpdCB0byByZXNvbHZlLlxuICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGV2ZW4gd2hlbiB1c2luZyBQcm9taXNlLnJhY2UoKSwgYXMgUHJvbWlzZS5yYWNlKCkgd2lsbFxuICAgIC8vIG5vdCBjbGVhbiB1cCB0aGUgdW5yZXNvbHZlZCBwcm9taXNlcyBldmVuIGFmdGVyIHRoZXkgaGF2ZSBkZWZpbml0ZWx5XG4gICAgLy8gXCJsb3N0XCIgdGhlIHJhY2UuXG4gICAgY29uc3QgYWJvcnRSZWNlaXZlTWVzc2FnZSA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAvLyBUaGVyZSdzIG5vIHdheSB0byByZWNlaXZlIGFuIGV2ZW50IGluZGljYXRpbmcgdGhhdCBhIHBvcHVwIHdpbmRvdyBoYXMgYmVlblxuICAgIC8vIGNsb3NlZCwgYW5kIHdlIGNhbid0IHJlbHkgb24gdGhlIGNvZGUgcnVubmluZyBpbnNpZGUgdGhlIHBvcHVwIHRvIHNlbmQgdXNcbiAgICAvLyBhIG1lc3NhZ2UsIHNvIGluc3RlYWQgd2UgaGF2ZSB0byBjaGVjayBmb3IgaXQgb24gYSB0aW1lci5cbiAgICAvLyBXZSBhcmUgZG9pbmcgdGhpcyBpbiBvcmRlciB0byBkZXRlY3QgY2FzZXMgaW4gd2hpY2ggdGhlIHBvcHVwIHdpbmRvdyBpc1xuICAgIC8vIGNsb3NlZCB3aXRob3V0IGFueSBhY3Rpb24gYmVpbmcgdGFrZW4gKGUuZy4gYSBwcm9vZiBiZWluZyBnZW5lcmF0ZWQpLlxuICAgIGNvbnN0IGNsb3NlUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsb3NlQ2hlY2tJbnRlcnZhbCA9IHdpbmRvdy5zZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAocG9wdXAuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChjbG9zZUNoZWNrSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIHdoZXJlIGFuIGFjdGlvbiBpcyBjb21wbGV0ZWQsIHRoZSBwb3B1cCB3aWxsIHNlbmQgYVxuICAgICAgICAgICAgICAgIC8vIG1lc3NhZ2UsIGFuZCB0aGVuIGNsb3NlIGl0c2VsZi4gSW4gdGVzdGluZywgaXQgc2VlbXMgdGhhdCB0aGVcbiAgICAgICAgICAgICAgICAvLyBtZXNzYWdlIGlzIGFsd2F5cyByZWNlaXZlZCBiZWZvcmUgd2UgcGljayB1cCBvbiB0aGUgZmFjdCB0aGF0IHRoZVxuICAgICAgICAgICAgICAgIC8vIHBvcHVwIGlzIGNsb3NlZC4gSG93ZXZlciwgZm9yIHNhZmV0eSwgd2Ugd2lsbCBhdm9pZCByZXNvbHZpbmcgdGhpc1xuICAgICAgICAgICAgICAgIC8vIHByb21pc2UgZm9yIGFub3RoZXIgMjUwbXMsIHRvIGVuc3VyZSB0aGF0IHRoZSBvdGhlciBwcm9taXNlXG4gICAgICAgICAgICAgICAgLy8gKGNvbnRhaW5pbmcgdGhlIHJlY2VpdmVkIG1lc3NhZ2UpIGRlZmluaXRlbHkgcmVzb2x2ZXMgZmlyc3QuXG4gICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHsgdHlwZTogXCJwb3B1cENsb3NlZFwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiB0aGUgZXZlbnQgdGhhdCB0aGUgbWVzc2FnZS1yZWNlaXZpbmcgcHJvbWlzZSBoYXMgKm5vdCpcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzb2x2ZWQsIHdlIG5lZWQgdG8gdGVsbCBpdCB0byByZXNvbHZlIG5vdywgdG8gYXZvaWQgYSBtZW1vcnlcbiAgICAgICAgICAgICAgICAgICAgLy8gbGVhay5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnRSZWNlaXZlTWVzc2FnZS5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIH0sIDI1MCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDEwMCk7XG4gICAgfSk7XG4gICAgLy8gUmFjZSB0aGUgY2xvc2luZyBvZiB0aGUgd2luZG93IGFnYWluc3QgdGhlIHJlY2VpcHQgb2YgYSBtZXNzYWdlLCBhbmRcbiAgICAvLyByZXR1cm4gd2hpY2hldmVyIHJlc29sdmVzIGZpcnN0LlxuICAgIHJldHVybiBQcm9taXNlLnJhY2UoW1xuICAgICAgICBjbG9zZVByb21pc2UsXG4gICAgICAgIHJlY2VpdmVadXBhc3NQb3B1cE1lc3NhZ2UoYWJvcnRSZWNlaXZlTWVzc2FnZS5zaWduYWwpXG4gICAgXSk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@pcd/passport-interface/dist/esm/src/PassportPopup/core.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@pcd/passport-interface/dist/esm/src/PassportPopup/react.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@pcd/passport-interface/dist/esm/src/PassportPopup/react.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useZupassPopupMessages: () => (/* binding */ useZupassPopupMessages),\n/* harmony export */   useZupassPopupSetup: () => (/* binding */ useZupassPopupSetup)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core.js */ \"(app-pages-browser)/./node_modules/@pcd/passport-interface/dist/esm/src/PassportPopup/core.js\");\n\n\n/**\n * React hook that listens for PCDs and PendingPCDs from a Zupass popup window.\n * A thin wrapper around {@link receiveZupassPopupMessage}.\n */\nfunction useZupassPopupMessages() {\n    const [pcdStr, setPCDStr] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [multiPcdStrs, setMultiPcdStrs] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [pendingPCDStr, setPendingPCDStr] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    // Listen for PCDs coming back from the Zupass popup\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        const abortReceiveMessage = new AbortController();\n        (0,_core_js__WEBPACK_IMPORTED_MODULE_1__.receiveZupassPopupMessage)(abortReceiveMessage.signal).then((result) => {\n            if (result.type === \"pcd\") {\n                setPCDStr(result.pcdStr);\n            }\n            else if (result.type === \"pendingPcd\") {\n                setPendingPCDStr(result.pendingPcdStr);\n            }\n            else if (result.type === \"multi-pcd\") {\n                setMultiPcdStrs(result.pcds);\n            }\n        });\n        return () => {\n            // If the hook is unmounted, signal that the message handlers can detach\n            // by aborting.\n            abortReceiveMessage.abort();\n        };\n    }, []);\n    return [pcdStr, pendingPCDStr, multiPcdStrs];\n}\n/**\n * Call this hook on a dedicated /popup page in your app to integrate your\n * app with the Zupass proving/auth popup flow.\n *\n * See {@link zupassPopupSetup} for further details.\n */\nfunction useZupassPopupSetup() {\n    // Usually this page redirects immediately. If not, show an error.\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        (0,_core_js__WEBPACK_IMPORTED_MODULE_1__.zupassPopupSetup)().then((maybeErrorMessage) => {\n            if (maybeErrorMessage) {\n                setError(maybeErrorMessage);\n            }\n        });\n    }, []);\n    return error;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGNkL3Bhc3Nwb3J0LWludGVyZmFjZS9kaXN0L2VzbS9zcmMvUGFzc3BvcnRQb3B1cC9yZWFjdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUE0QztBQUM0QjtBQUN4RTtBQUNBO0FBQ0EsMEJBQTBCLGdDQUFnQztBQUMxRDtBQUNPO0FBQ1AsZ0NBQWdDLCtDQUFRO0FBQ3hDLDRDQUE0QywrQ0FBUTtBQUNwRCw4Q0FBOEMsK0NBQVE7QUFDdEQ7QUFDQSxJQUFJLGdEQUFTO0FBQ2I7QUFDQSxRQUFRLG1FQUF5QjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdCQUF3QjtBQUNoQztBQUNPO0FBQ1A7QUFDQSw4QkFBOEIsK0NBQVE7QUFDdEMsSUFBSSxnREFBUztBQUNiLFFBQVEsMERBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2NoYW5jZW1jYWxsaXN0ZXIvUHJvamVjdHMvenVwYXNzaHVudC9ub2RlX21vZHVsZXMvQHBjZC9wYXNzcG9ydC1pbnRlcmZhY2UvZGlzdC9lc20vc3JjL1Bhc3Nwb3J0UG9wdXAvcmVhY3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgcmVjZWl2ZVp1cGFzc1BvcHVwTWVzc2FnZSwgenVwYXNzUG9wdXBTZXR1cCB9IGZyb20gXCIuL2NvcmUuanNcIjtcbi8qKlxuICogUmVhY3QgaG9vayB0aGF0IGxpc3RlbnMgZm9yIFBDRHMgYW5kIFBlbmRpbmdQQ0RzIGZyb20gYSBadXBhc3MgcG9wdXAgd2luZG93LlxuICogQSB0aGluIHdyYXBwZXIgYXJvdW5kIHtAbGluayByZWNlaXZlWnVwYXNzUG9wdXBNZXNzYWdlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVp1cGFzc1BvcHVwTWVzc2FnZXMoKSB7XG4gICAgY29uc3QgW3BjZFN0ciwgc2V0UENEU3RyXSA9IHVzZVN0YXRlKFwiXCIpO1xuICAgIGNvbnN0IFttdWx0aVBjZFN0cnMsIHNldE11bHRpUGNkU3Ryc10gPSB1c2VTdGF0ZShbXSk7XG4gICAgY29uc3QgW3BlbmRpbmdQQ0RTdHIsIHNldFBlbmRpbmdQQ0RTdHJdID0gdXNlU3RhdGUoXCJcIik7XG4gICAgLy8gTGlzdGVuIGZvciBQQ0RzIGNvbWluZyBiYWNrIGZyb20gdGhlIFp1cGFzcyBwb3B1cFxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGFib3J0UmVjZWl2ZU1lc3NhZ2UgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIHJlY2VpdmVadXBhc3NQb3B1cE1lc3NhZ2UoYWJvcnRSZWNlaXZlTWVzc2FnZS5zaWduYWwpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcInBjZFwiKSB7XG4gICAgICAgICAgICAgICAgc2V0UENEU3RyKHJlc3VsdC5wY2RTdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LnR5cGUgPT09IFwicGVuZGluZ1BjZFwiKSB7XG4gICAgICAgICAgICAgICAgc2V0UGVuZGluZ1BDRFN0cihyZXN1bHQucGVuZGluZ1BjZFN0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQudHlwZSA9PT0gXCJtdWx0aS1wY2RcIikge1xuICAgICAgICAgICAgICAgIHNldE11bHRpUGNkU3RycyhyZXN1bHQucGNkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGhvb2sgaXMgdW5tb3VudGVkLCBzaWduYWwgdGhhdCB0aGUgbWVzc2FnZSBoYW5kbGVycyBjYW4gZGV0YWNoXG4gICAgICAgICAgICAvLyBieSBhYm9ydGluZy5cbiAgICAgICAgICAgIGFib3J0UmVjZWl2ZU1lc3NhZ2UuYWJvcnQoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIFtwY2RTdHIsIHBlbmRpbmdQQ0RTdHIsIG11bHRpUGNkU3Ryc107XG59XG4vKipcbiAqIENhbGwgdGhpcyBob29rIG9uIGEgZGVkaWNhdGVkIC9wb3B1cCBwYWdlIGluIHlvdXIgYXBwIHRvIGludGVncmF0ZSB5b3VyXG4gKiBhcHAgd2l0aCB0aGUgWnVwYXNzIHByb3ZpbmcvYXV0aCBwb3B1cCBmbG93LlxuICpcbiAqIFNlZSB7QGxpbmsgenVwYXNzUG9wdXBTZXR1cH0gZm9yIGZ1cnRoZXIgZGV0YWlscy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVp1cGFzc1BvcHVwU2V0dXAoKSB7XG4gICAgLy8gVXN1YWxseSB0aGlzIHBhZ2UgcmVkaXJlY3RzIGltbWVkaWF0ZWx5LiBJZiBub3QsIHNob3cgYW4gZXJyb3IuXG4gICAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZShcIlwiKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICB6dXBhc3NQb3B1cFNldHVwKCkudGhlbigobWF5YmVFcnJvck1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIGlmIChtYXliZUVycm9yTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHNldEVycm9yKG1heWJlRXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBlcnJvcjtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@pcd/passport-interface/dist/esm/src/PassportPopup/react.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fchancemcallister%2FProjects%2Fzupasshunt%2Fsrc%2Fapp%2Fpopup%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!***************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fchancemcallister%2FProjects%2Fzupasshunt%2Fsrc%2Fapp%2Fpopup%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \***************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/popup/page.tsx */ \"(app-pages-browser)/./src/app/popup/page.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZjaGFuY2VtY2FsbGlzdGVyJTJGUHJvamVjdHMlMkZ6dXBhc3NodW50JTJGc3JjJTJGYXBwJTJGcG9wdXAlMkZwYWdlLnRzeCUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBLDBLQUF1RyIsInNvdXJjZXMiOlsiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL2NoYW5jZW1jYWxsaXN0ZXIvUHJvamVjdHMvenVwYXNzaHVudC9zcmMvYXBwL3BvcHVwL3BhZ2UudHN4XCIpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fchancemcallister%2FProjects%2Fzupasshunt%2Fsrc%2Fapp%2Fpopup%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n        case REACT_ACTIVITY_TYPE:\n          return \"Activity\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function getTaskName(type) {\n      if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n      if (\n        \"object\" === typeof type &&\n        null !== type &&\n        type.$$typeof === REACT_LAZY_TYPE\n      )\n        return \"<...>\";\n      try {\n        var name = getComponentNameFromType(type);\n        return name ? \"<\" + name + \">\" : \"<...>\";\n      } catch (x) {\n        return \"<...>\";\n      }\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function UnknownOwner() {\n      return Error(\"react-stack-top-frame\");\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(\n      type,\n      key,\n      self,\n      source,\n      owner,\n      props,\n      debugStack,\n      debugTask\n    ) {\n      self = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== self ? self : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.defineProperty(type, \"_debugStack\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugStack\n      });\n      Object.defineProperty(type, \"_debugTask\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugTask\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      debugStack,\n      debugTask\n    ) {\n      var children = config.children;\n      if (void 0 !== children)\n        if (isStaticChildren)\n          if (isArrayImpl(children)) {\n            for (\n              isStaticChildren = 0;\n              isStaticChildren < children.length;\n              isStaticChildren++\n            )\n              validateChildKeys(children[isStaticChildren]);\n            Object.freeze && Object.freeze(children);\n          } else\n            console.error(\n              \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n            );\n        else validateChildKeys(children);\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(\n        type,\n        children,\n        self,\n        source,\n        getOwner(),\n        maybeKey,\n        debugStack,\n        debugTask\n      );\n    }\n    function validateChildKeys(node) {\n      \"object\" === typeof node &&\n        null !== node &&\n        node.$$typeof === REACT_ELEMENT_TYPE &&\n        node._store &&\n        (node._store.validated = 1);\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n    Symbol.for(\"react.provider\");\n    var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      isArrayImpl = Array.isArray,\n      createTask = console.createTask\n        ? console.createTask\n        : function () {\n            return null;\n          };\n    React = {\n      \"react-stack-bottom-frame\": function (callStackForError) {\n        return callStackForError();\n      }\n    };\n    var specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var unknownOwnerDebugStack = React[\"react-stack-bottom-frame\"].bind(\n      React,\n      UnknownOwner\n    )();\n    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n    var didWarnAboutKeySpread = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      var trackActualOwner =\n        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n      return jsxDEVImpl(\n        type,\n        config,\n        maybeKey,\n        isStaticChildren,\n        source,\n        self,\n        trackActualOwner\n          ? Error(\"react-stack-top-frame\")\n          : unknownOwnerDebugStack,\n        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask\n      );\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCwrQ0FBK0MsNkJBQTZCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLGdEQUFnRDtBQUNoRSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0EsZ0NBQWdDLGtDQUFrQyxPQUFPO0FBQ3pFO0FBQ0EsZ0dBQWdHLFNBQVMsVUFBVSxzRkFBc0YsYUFBYSxVQUFVLFVBQVU7QUFDMU87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxzR0FBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQixJQUFJLGNBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHIiwic291cmNlcyI6WyIvVXNlcnMvY2hhbmNlbWNhbGxpc3Rlci9Qcm9qZWN0cy96dXBhc3NodW50L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gdHlwZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9BQ1RJVklUWV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIkFjdGl2aXR5XCI7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgKFwibnVtYmVyXCIgPT09IHR5cGVvZiB0eXBlLnRhZyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgIHR5cGUuJCR0eXBlb2YpXG4gICAgICAgICkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Qcm92aWRlclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHZhciBpbm5lclR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgdHlwZSB8fFxuICAgICAgICAgICAgICAoKHR5cGUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgXCJcIiksXG4gICAgICAgICAgICAgICh0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChpbm5lclR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGwpLFxuICAgICAgICAgICAgICBudWxsICE9PSBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA/IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgIDogZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJNZW1vXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBpbm5lclR5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUoaW5uZXJUeXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgfVxuICAgICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBjb25zb2xlO1xuICAgICAgICB2YXIgSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmVycm9yO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID1cbiAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmXG4gICAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10pIHx8XG4gICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fFxuICAgICAgICAgIFwiT2JqZWN0XCI7XG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdC5jYWxsKFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCxcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUYXNrTmFtZSh0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkgcmV0dXJuIFwiPD5cIjtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgbnVsbCAhPT0gdHlwZSAmJlxuICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEVcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIFwiPC4uLj5cIjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICByZXR1cm4gbmFtZSA/IFwiPFwiICsgbmFtZSArIFwiPlwiIDogXCI8Li4uPlwiO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICByZXR1cm4gXCI8Li4uPlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRPd25lcigpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuQTtcbiAgICAgIHJldHVybiBudWxsID09PSBkaXNwYXRjaGVyID8gbnVsbCA6IGRpc3BhdGNoZXIuZ2V0T3duZXIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVW5rbm93bk93bmVyKCkge1xuICAgICAgcmV0dXJuIEVycm9yKFwicmVhY3Qtc3RhY2stdG9wLWZyYW1lXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCBcImtleVwiKS5nZXQ7XG4gICAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb25maWcua2V5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgICAgIGZ1bmN0aW9uIHdhcm5BYm91dEFjY2Vzc2luZ0tleSgpIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gfHxcbiAgICAgICAgICAoKHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gITApLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9zcGVjaWFsLXByb3BzKVwiLFxuICAgICAgICAgICAgZGlzcGxheU5hbWVcbiAgICAgICAgICApKTtcbiAgICAgIH1cbiAgICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9ICEwO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCBcImtleVwiLCB7XG4gICAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmcoKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0aGlzLnR5cGUpO1xuICAgICAgZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSB8fFxuICAgICAgICAoKGRpZFdhcm5BYm91dEVsZW1lbnRSZWZbY29tcG9uZW50TmFtZV0gPSAhMCksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJBY2Nlc3NpbmcgZWxlbWVudC5yZWYgd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIHJlZiBpcyBub3cgYSByZWd1bGFyIHByb3AuIEl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBKU1ggRWxlbWVudCB0eXBlIGluIGEgZnV0dXJlIHJlbGVhc2UuXCJcbiAgICAgICAgKSk7XG4gICAgICBjb21wb25lbnROYW1lID0gdGhpcy5wcm9wcy5yZWY7XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb21wb25lbnROYW1lID8gY29tcG9uZW50TmFtZSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWN0RWxlbWVudChcbiAgICAgIHR5cGUsXG4gICAgICBrZXksXG4gICAgICBzZWxmLFxuICAgICAgc291cmNlLFxuICAgICAgb3duZXIsXG4gICAgICBwcm9wcyxcbiAgICAgIGRlYnVnU3RhY2ssXG4gICAgICBkZWJ1Z1Rhc2tcbiAgICApIHtcbiAgICAgIHNlbGYgPSBwcm9wcy5yZWY7XG4gICAgICB0eXBlID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICBfb3duZXI6IG93bmVyXG4gICAgICB9O1xuICAgICAgbnVsbCAhPT0gKHZvaWQgMCAhPT0gc2VsZiA/IHNlbGYgOiBudWxsKVxuICAgICAgICA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgIGdldDogZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICB9KVxuICAgICAgICA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7IGVudW1lcmFibGU6ICExLCB2YWx1ZTogbnVsbCB9KTtcbiAgICAgIHR5cGUuX3N0b3JlID0ge307XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZS5fc3RvcmUsIFwidmFsaWRhdGVkXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IDBcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnSW5mb1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z1N0YWNrXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IGRlYnVnU3RhY2tcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnVGFza1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBkZWJ1Z1Rhc2tcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmZyZWV6ZSAmJiAoT2JqZWN0LmZyZWV6ZSh0eXBlLnByb3BzKSwgT2JqZWN0LmZyZWV6ZSh0eXBlKSk7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgZnVuY3Rpb24ganN4REVWSW1wbChcbiAgICAgIHR5cGUsXG4gICAgICBjb25maWcsXG4gICAgICBtYXliZUtleSxcbiAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICBzb3VyY2UsXG4gICAgICBzZWxmLFxuICAgICAgZGVidWdTdGFjayxcbiAgICAgIGRlYnVnVGFza1xuICAgICkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gY29uZmlnLmNoaWxkcmVuO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gY2hpbGRyZW4pXG4gICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKVxuICAgICAgICAgIGlmIChpc0FycmF5SW1wbChjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPSAwO1xuICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuIDwgY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuKytcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baXNTdGF0aWNDaGlsZHJlbl0pO1xuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiBVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICBlbHNlIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuKTtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY29uZmlnKS5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICByZXR1cm4gXCJrZXlcIiAhPT0gaztcbiAgICAgICAgfSk7XG4gICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPVxuICAgICAgICAgIDAgPCBrZXlzLmxlbmd0aFxuICAgICAgICAgICAgPyBcIntrZXk6IHNvbWVLZXksIFwiICsga2V5cy5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCJcbiAgICAgICAgICAgIDogXCJ7a2V5OiBzb21lS2V5fVwiO1xuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSB8fFxuICAgICAgICAgICgoa2V5cyA9XG4gICAgICAgICAgICAwIDwga2V5cy5sZW5ndGggPyBcIntcIiArIGtleXMuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiIDogXCJ7fVwiKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ0EgcHJvcHMgb2JqZWN0IGNvbnRhaW5pbmcgYSBcImtleVwiIHByb3AgaXMgYmVpbmcgc3ByZWFkIGludG8gSlNYOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMgey4uLnByb3BzfSAvPlxcblJlYWN0IGtleXMgbXVzdCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gSlNYIHdpdGhvdXQgdXNpbmcgc3ByZWFkOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JyxcbiAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgIGtleXMsXG4gICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5BYm91dEtleVNwcmVhZFtjaGlsZHJlbiArIGlzU3RhdGljQ2hpbGRyZW5dID0gITApKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgICAgIHZvaWQgMCAhPT0gbWF5YmVLZXkgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgbWF5YmVLZXkpKTtcbiAgICAgIGhhc1ZhbGlkS2V5KGNvbmZpZykgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSksIChjaGlsZHJlbiA9IFwiXCIgKyBjb25maWcua2V5KSk7XG4gICAgICBpZiAoXCJrZXlcIiBpbiBjb25maWcpIHtcbiAgICAgICAgbWF5YmVLZXkgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gY29uZmlnKVxuICAgICAgICAgIFwia2V5XCIgIT09IHByb3BOYW1lICYmIChtYXliZUtleVtwcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdKTtcbiAgICAgIH0gZWxzZSBtYXliZUtleSA9IGNvbmZpZztcbiAgICAgIGNoaWxkcmVuICYmXG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKFxuICAgICAgICAgIG1heWJlS2V5LFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGVcbiAgICAgICAgICAgID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgXCJVbmtub3duXCJcbiAgICAgICAgICAgIDogdHlwZVxuICAgICAgICApO1xuICAgICAgcmV0dXJuIFJlYWN0RWxlbWVudChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHNlbGYsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgZ2V0T3duZXIoKSxcbiAgICAgICAgbWF5YmVLZXksXG4gICAgICAgIGRlYnVnU3RhY2ssXG4gICAgICAgIGRlYnVnVGFza1xuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSkge1xuICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5vZGUgJiZcbiAgICAgICAgbnVsbCAhPT0gbm9kZSAmJlxuICAgICAgICBub2RlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUgJiZcbiAgICAgICAgbm9kZS5fc3RvcmUgJiZcbiAgICAgICAgKG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IDEpO1xuICAgIH1cbiAgICB2YXIgUmVhY3QgPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0XCIpLFxuICAgICAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50XCIpLFxuICAgICAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLFxuICAgICAgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxcbiAgICAgIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksXG4gICAgICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpO1xuICAgIFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKTtcbiAgICB2YXIgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKSxcbiAgICAgIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLFxuICAgICAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSxcbiAgICAgIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLFxuICAgICAgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksXG4gICAgICBSRUFDVF9BQ1RJVklUWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmFjdGl2aXR5XCIpLFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPVxuICAgICAgICBSZWFjdC5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUsXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXksXG4gICAgICBjcmVhdGVUYXNrID0gY29uc29sZS5jcmVhdGVUYXNrXG4gICAgICAgID8gY29uc29sZS5jcmVhdGVUYXNrXG4gICAgICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfTtcbiAgICBSZWFjdCA9IHtcbiAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChjYWxsU3RhY2tGb3JFcnJvcikge1xuICAgICAgICByZXR1cm4gY2FsbFN0YWNrRm9yRXJyb3IoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbiAgICB2YXIgZGlkV2FybkFib3V0RWxlbWVudFJlZiA9IHt9O1xuICAgIHZhciB1bmtub3duT3duZXJEZWJ1Z1N0YWNrID0gUmVhY3RbXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIl0uYmluZChcbiAgICAgIFJlYWN0LFxuICAgICAgVW5rbm93bk93bmVyXG4gICAgKSgpO1xuICAgIHZhciB1bmtub3duT3duZXJEZWJ1Z1Rhc2sgPSBjcmVhdGVUYXNrKGdldFRhc2tOYW1lKFVua25vd25Pd25lcikpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbiAgICBleHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbiAgICBleHBvcnRzLmpzeERFViA9IGZ1bmN0aW9uIChcbiAgICAgIHR5cGUsXG4gICAgICBjb25maWcsXG4gICAgICBtYXliZUtleSxcbiAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICBzb3VyY2UsXG4gICAgICBzZWxmXG4gICAgKSB7XG4gICAgICB2YXIgdHJhY2tBY3R1YWxPd25lciA9XG4gICAgICAgIDFlNCA+IFJlYWN0U2hhcmVkSW50ZXJuYWxzLnJlY2VudGx5Q3JlYXRlZE93bmVyU3RhY2tzKys7XG4gICAgICByZXR1cm4ganN4REVWSW1wbChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBtYXliZUtleSxcbiAgICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgICAgc291cmNlLFxuICAgICAgICBzZWxmLFxuICAgICAgICB0cmFja0FjdHVhbE93bmVyXG4gICAgICAgICAgPyBFcnJvcihcInJlYWN0LXN0YWNrLXRvcC1mcmFtZVwiKVxuICAgICAgICAgIDogdW5rbm93bk93bmVyRGVidWdTdGFjayxcbiAgICAgICAgdHJhY2tBY3R1YWxPd25lciA/IGNyZWF0ZVRhc2soZ2V0VGFza05hbWUodHlwZSkpIDogdW5rbm93bk93bmVyRGVidWdUYXNrXG4gICAgICApO1xuICAgIH07XG4gIH0pKCk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jaGFuY2VtY2FsbGlzdGVyL1Byb2plY3RzL3p1cGFzc2h1bnQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5wcm9kdWN0aW9uLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/popup/page.tsx":
/*!********************************!*\
  !*** ./src/app/popup/page.tsx ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PopupPage)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _pcd_passport_interface_PassportPopup_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pcd/passport-interface/PassportPopup/react */ \"(app-pages-browser)/./node_modules/@pcd/passport-interface/dist/esm/src/PassportPopup/react.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction PopupPage() {\n    _s();\n    // This hook handles all the popup logic\n    const error = (0,_pcd_passport_interface_PassportPopup_react__WEBPACK_IMPORTED_MODULE_1__.useZupassPopupSetup)();\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"h-screen flex items-center justify-center p-4\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"text-center\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                    className: \"text-xl font-bold mb-4\",\n                    children: \"Authenticating with ZuPass\"\n                }, void 0, false, {\n                    fileName: \"/Users/chancemcallister/Projects/zupasshunt/src/app/popup/page.tsx\",\n                    lineNumber: 12,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                    className: \"text-gray-600\",\n                    children: \"This window will close automatically once authentication is complete.\"\n                }, void 0, false, {\n                    fileName: \"/Users/chancemcallister/Projects/zupasshunt/src/app/popup/page.tsx\",\n                    lineNumber: 13,\n                    columnNumber: 9\n                }, this),\n                error && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"p-3 bg-red-100 text-red-700 rounded-md mt-4\",\n                    children: error\n                }, void 0, false, {\n                    fileName: \"/Users/chancemcallister/Projects/zupasshunt/src/app/popup/page.tsx\",\n                    lineNumber: 17,\n                    columnNumber: 11\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/chancemcallister/Projects/zupasshunt/src/app/popup/page.tsx\",\n            lineNumber: 11,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/chancemcallister/Projects/zupasshunt/src/app/popup/page.tsx\",\n        lineNumber: 10,\n        columnNumber: 5\n    }, this);\n}\n_s(PopupPage, \"PtX+avwPUr5JBqFSqPGtL/wVrOA=\", false, function() {\n    return [\n        _pcd_passport_interface_PassportPopup_react__WEBPACK_IMPORTED_MODULE_1__.useZupassPopupSetup\n    ];\n});\n_c = PopupPage;\nvar _c;\n$RefreshReg$(_c, \"PopupPage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvcG9wdXAvcGFnZS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFFa0Y7QUFFbkUsU0FBU0M7O0lBQ3RCLHdDQUF3QztJQUN4QyxNQUFNQyxRQUFRRixnR0FBbUJBO0lBRWpDLHFCQUNFLDhEQUFDRztRQUFJQyxXQUFVO2tCQUNiLDRFQUFDRDtZQUFJQyxXQUFVOzs4QkFDYiw4REFBQ0M7b0JBQUdELFdBQVU7OEJBQXlCOzs7Ozs7OEJBQ3ZDLDhEQUFDRTtvQkFBRUYsV0FBVTs4QkFBZ0I7Ozs7OztnQkFHNUJGLHVCQUNDLDhEQUFDQztvQkFBSUMsV0FBVTs4QkFDWkY7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTWI7R0FuQndCRDs7UUFFUkQsNEZBQW1CQTs7O0tBRlhDIiwic291cmNlcyI6WyIvVXNlcnMvY2hhbmNlbWNhbGxpc3Rlci9Qcm9qZWN0cy96dXBhc3NodW50L3NyYy9hcHAvcG9wdXAvcGFnZS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB7IHVzZVp1cGFzc1BvcHVwU2V0dXAgfSBmcm9tIFwiQHBjZC9wYXNzcG9ydC1pbnRlcmZhY2UvUGFzc3BvcnRQb3B1cC9yZWFjdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQb3B1cFBhZ2UoKSB7XG4gIC8vIFRoaXMgaG9vayBoYW5kbGVzIGFsbCB0aGUgcG9wdXAgbG9naWNcbiAgY29uc3QgZXJyb3IgPSB1c2VadXBhc3NQb3B1cFNldHVwKCk7XG4gIFxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiaC1zY3JlZW4gZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgcC00XCI+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtY2VudGVyXCI+XG4gICAgICAgIDxoMSBjbGFzc05hbWU9XCJ0ZXh0LXhsIGZvbnQtYm9sZCBtYi00XCI+QXV0aGVudGljYXRpbmcgd2l0aCBadVBhc3M8L2gxPlxuICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LWdyYXktNjAwXCI+XG4gICAgICAgICAgVGhpcyB3aW5kb3cgd2lsbCBjbG9zZSBhdXRvbWF0aWNhbGx5IG9uY2UgYXV0aGVudGljYXRpb24gaXMgY29tcGxldGUuXG4gICAgICAgIDwvcD5cbiAgICAgICAge2Vycm9yICYmIChcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInAtMyBiZy1yZWQtMTAwIHRleHQtcmVkLTcwMCByb3VuZGVkLW1kIG10LTRcIj5cbiAgICAgICAgICAgIHtlcnJvcn1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKX1cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufSAiXSwibmFtZXMiOlsidXNlWnVwYXNzUG9wdXBTZXR1cCIsIlBvcHVwUGFnZSIsImVycm9yIiwiZGl2IiwiY2xhc3NOYW1lIiwiaDEiLCJwIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/popup/page.tsx\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fchancemcallister%2FProjects%2Fzupasshunt%2Fsrc%2Fapp%2Fpopup%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);