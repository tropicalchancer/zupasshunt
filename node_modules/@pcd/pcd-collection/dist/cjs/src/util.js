"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.escapePathSegment = exports.getNameFromPath = exports.isRootFolder = exports.getParentFolder = exports.normalizePath = exports.joinPath = exports.splitPath = exports.isFolderAncestor = exports.isChild = exports.getAllAncestors = exports.getFoldersInFolder = exports.PATH_SEP = void 0;
const lodash_1 = __importDefault(require("lodash"));
exports.PATH_SEP = "/";
/**
 * Gets the list of folders that are direct descendants of a given
 * path, given a list of directories that are present. For example,
 * if the full list of paths is something like:
 *
 * a/b/c/d
 * a/b/q/r
 *
 * ... then this function would say that the list of child folders of
 * a/b is [a/b/c, a/b/q], even though a/b/c and a/b/q are not explicitly listed.
 */
function getFoldersInFolder(folderPath, allPaths) {
    const descendantsOfFolder = lodash_1.default.uniq(allPaths.filter((p) => isFolderAncestor(p, folderPath)));
    const descendantsWithMissing = lodash_1.default.uniq([
        ...descendantsOfFolder.flatMap((path) => getAllAncestors(path)),
        ...descendantsOfFolder
    ]).filter((a) => a !== "");
    const directDescendants = descendantsWithMissing.filter((d) => isChild(folderPath, d));
    return directDescendants;
}
exports.getFoldersInFolder = getFoldersInFolder;
/**
 * For a path like a/b/c/d, returns a/b/c, a/b, a, and the root
 * denoted by "".
 */
function getAllAncestors(path) {
    const parts = splitPath(path);
    const result = [];
    while (parts.length > 0) {
        parts.pop();
        result.push(parts.join(exports.PATH_SEP));
    }
    return result;
}
exports.getAllAncestors = getAllAncestors;
/**
 * Checks that a particular child path is a direct child of a
 * particular parent.
 */
function isChild(parent, child) {
    const normalizedPath = normalizePath(parent);
    const descendantParts = splitPath(child);
    descendantParts.pop();
    if (normalizedPath === descendantParts.join(exports.PATH_SEP)) {
        return true;
    }
    return false;
}
exports.isChild = isChild;
/**
 * Checks if {@link possibleAncestor} has {@link possibleDescendant} as a
 * descendant.
 * eg. a/b/c/d is a descendant of a/b, but not of a/q.
 */
function isFolderAncestor(possibleDescendant, possibleAncestor) {
    const pathParts = splitPath(possibleDescendant);
    const folderParts = splitPath(possibleAncestor);
    if (folderParts.length >= pathParts.length) {
        return false;
    }
    for (let i = 0; i < folderParts.length; i++) {
        if (folderParts[i] !== pathParts[i]) {
            return false;
        }
    }
    return true;
}
exports.isFolderAncestor = isFolderAncestor;
/**
 * Splits a path via the path separator.
 */
function splitPath(path) {
    return path.split(exports.PATH_SEP).filter((p) => p !== "");
}
exports.splitPath = splitPath;
/**
 * Joins path segments with the separator, escaping each segment.
 */
function joinPath(...segments) {
    return segments.map(escapePathSegment).join(exports.PATH_SEP);
}
exports.joinPath = joinPath;
/**
 * Removes unnecessary path separators from a path.
 */
function normalizePath(path) {
    return splitPath(path).join(exports.PATH_SEP);
}
exports.normalizePath = normalizePath;
/**
 * For a path like a/b/c, returns a/b. for the root returns the root.
 */
function getParentFolder(folderPath) {
    const parts = splitPath(folderPath);
    parts.pop();
    return parts.join(exports.PATH_SEP);
}
exports.getParentFolder = getParentFolder;
/**
 * Returns whether or not this path is the root. Root canonically
 * represented by an empty string, but also normalizes from /, //, ///, etc.
 */
function isRootFolder(folderPath) {
    return normalizePath(folderPath) === "";
}
exports.isRootFolder = isRootFolder;
/**
 * Gets the last path segment of a path. Eg. a/b/c would return c.
 * For root, returns root.
 */
function getNameFromPath(path) {
    const parts = splitPath(path);
    if (parts.length === 0) {
        return "";
    }
    return parts[parts.length - 1];
}
exports.getNameFromPath = getNameFromPath;
/**
 * Removes any path separators from a file name.
 */
function escapePathSegment(name) {
    return name.replace(/\//g, "");
}
exports.escapePathSegment = escapePathSegment;
