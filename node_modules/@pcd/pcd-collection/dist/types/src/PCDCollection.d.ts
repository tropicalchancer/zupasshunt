import { Emitter } from "@pcd/emitter";
import { PCD, PCDPackage, SerializedPCD } from "@pcd/pcd-types";
import { AppendToFolderAction, DeleteFolderAction, PCDAction, ReplaceInFolderAction } from "./actions";
import { AppendToFolderPermission, DeleteFolderPermission, PCDPermission, ReplaceInFolderPermission } from "./permissions";
export type MatchingActionPermission = {
    permission: ReplaceInFolderPermission;
    action: ReplaceInFolderAction;
} | {
    permission: AppendToFolderPermission;
    action: AppendToFolderAction;
} | {
    permission: DeleteFolderPermission;
    action: DeleteFolderAction;
};
type AddPCDOptions = {
    upsert?: boolean;
};
export type MergeFilterPredicate = (pcd: PCD, target: PCDCollection) => boolean;
/**
 * Function type for use in deserialization.  This is a fallback option used
 * when no PCD package is available, or when the named package fails to
 * deserialize.  It could wrap the PCD in a different type, or perform some
 * more expensive parsing.
 *
 * If the fallback function fails (throws) it will cause the deserialization
 * to fail, in the same way (with the same error) as if there were no
 * fallback at all.
 *
 * @param collection the PCDCollection performing the deserialization
 * @param pcdPackage the package for the type of the serialized PCD, if any
 * @param serializedPCD the serialized PCD to deserialize
 * @param deserializeError the error thrown by the deserialize attempt
 * @return a PCD representing or wrapping the serialized PCD
 * @throws if no fallback deserialization is possible
 */
export type FallbackDeserializeFunction = (collection: PCDCollection, pcdPackage: PCDPackage | undefined, serializedPCD: SerializedPCD, deserializeError: unknown) => Promise<PCD>;
export declare function matchActionToPermission(action: PCDAction, permissions: PCDPermission[]): MatchingActionPermission | null;
/**
 * This class represents all the PCDs a user may have, and also
 * contains references to all the relevant {@link PCDPackage}s,
 * which allows this class to effectively make use of all of the
 * PCDs.
 */
export declare class PCDCollection {
    /**
     * Emits an event whenever the contents of this {@link PCDCollection} changes.
     * Does not attempt to filter out changes which result in the same contents.
     */
    readonly changeEmitter: Emitter;
    private packages;
    private pcds;
    folders: Record<string, string>;
    constructor(packages: PCDPackage[], pcds?: PCD[], folders?: Record<string, string>);
    getFoldersInFolder(folderPath: string): string[];
    isValidFolder(folderPath: string): boolean;
    setPCDFolder(pcdId: string, folder: string): void;
    tryExec(action: PCDAction, permissions: PCDPermission[]): Promise<boolean>;
    tryExecutingActionWithPermission(action: PCDAction, permission: PCDPermission): Promise<boolean>;
    getSize(): number;
    getAllFolderNames(): string[];
    bulkSetFolder(pcdIds: string[], folder: string): void;
    setFolder(pcdId: string, folder: string): void;
    getFolderOfPCD(pcdId: string): string | undefined;
    getAllPCDsInFolder(folder: string): PCD[];
    removeAllPCDsInFolder(folder: string): void;
    replacePCDsInFolder(folder: string, pcds: PCD[]): void;
    /**
     * Removes all PCDs within a given folder, and optionally within all
     * subfolders.
     */
    private deleteFolder;
    getPackage<T extends PCDPackage = PCDPackage>(name: string): T | undefined;
    hasPackage(name: string): boolean;
    serialize(pcd: PCD): Promise<SerializedPCD>;
    serializeAll(): Promise<SerializedPCD[]>;
    serializeCollection(): Promise<string>;
    deserialize(serialized: SerializedPCD, options?: {
        fallbackDeserializeFunction?: FallbackDeserializeFunction;
    }): Promise<PCD>;
    deserializeAll(serialized: SerializedPCD[], options?: {
        fallbackDeserializeFunction?: FallbackDeserializeFunction;
    }): Promise<PCD[]>;
    deserializeAllAndAdd(serialized: SerializedPCD[], options?: {
        upsert?: boolean;
        fallbackDeserializeFunction?: FallbackDeserializeFunction;
    }): Promise<void>;
    remove(pcdId: string): Promise<void>;
    deserializeAndAdd(serialized: SerializedPCD, options?: {
        upsert?: boolean;
        fallbackDeserializeFunction?: FallbackDeserializeFunction;
    }): Promise<void>;
    add(pcd: PCD, options?: AddPCDOptions): void;
    addAll(pcds: PCD[], options?: AddPCDOptions): void;
    size(): number;
    getAll(): PCD[];
    getAllIds(): string[];
    getByIds(ids: string[]): PCD[];
    /**
     * Generates a unique hash based on the contents. This hash changes whenever
     * the set of pcds, or the contents of the pcds changes.
     */
    getHash(): Promise<string>;
    getById(id: string): PCD | undefined;
    hasPCDWithId(id: string): boolean;
    getPCDsByType(type: string): PCD[];
    private emitChange;
    static deserialize(packages: PCDPackage[], serialized: string, options?: {
        fallbackDeserializeFunction?: FallbackDeserializeFunction;
    }): Promise<PCDCollection>;
    /**
     * Merges another PCD collection into this one.
     * There is one option:
     * - `shouldInclude` is a function used to filter out PCDs from the other
     *   collection during merging, e.g. to filter out duplicates or PCDs of
     *   a type that should not be copied.
     */
    merge(other: PCDCollection, options?: {
        shouldInclude?: MergeFilterPredicate;
    }): void;
}
/**
 * {@link PCDCollection#serializeCollection} returns a stringified instance
 * of this interface, and {@link PCDCollection.deserialize} takes a stringified
 * instance of this object and returns a new {@link PCDCollection}.
 */
export interface SerializedPCDCollection {
    pcds: SerializedPCD[];
    folders: Record<string, string>;
}
export {};
//# sourceMappingURL=PCDCollection.d.ts.map