import { DisplayOptions, PCDPackage, SerializedPCD } from "@pcd/pcd-types";
import { SemaphoreSignaturePCD, SemaphoreSignaturePCDArgs, SemaphoreSignaturePCDClaim, SemaphoreSignaturePCDInitArgs, SemaphoreSignaturePCDProof } from "./SemaphoreSignaturePCD";
/**
 * All signature PCDs are 'namespaced' to this pseudo-random nullifier,
 * so that they cannot be reused by malicious actors across different
 * applications.
 */
export declare const STATIC_SIGNATURE_PCD_NULLIFIER: bigint;
export declare function init(args: SemaphoreSignaturePCDInitArgs): Promise<void>;
export declare function prove(args: SemaphoreSignaturePCDArgs): Promise<SemaphoreSignaturePCD>;
export declare function verify(pcd: SemaphoreSignaturePCD): Promise<boolean>;
export declare function serialize(pcd: SemaphoreSignaturePCD): Promise<SerializedPCD<SemaphoreSignaturePCD>>;
export declare function deserialize(serialized: string): Promise<SemaphoreSignaturePCD>;
export declare function getDisplayOptions(pcd: SemaphoreSignaturePCD): DisplayOptions;
/**
 * PCD-conforming wrapper to sign messages using one's Semaphore public key. This is a small
 * extension of the existing Semaphore protocol, which is mostly geared at group signatures.
 * Find documentation of Semaphore here: https://semaphore.appliedzkp.org/docs/introduction
 */
export declare const SemaphoreSignaturePCDPackage: PCDPackage<SemaphoreSignaturePCDClaim, SemaphoreSignaturePCDProof, SemaphoreSignaturePCDArgs, SemaphoreSignaturePCDInitArgs>;
//# sourceMappingURL=SemaphoreSignaturePCDPackage.d.ts.map