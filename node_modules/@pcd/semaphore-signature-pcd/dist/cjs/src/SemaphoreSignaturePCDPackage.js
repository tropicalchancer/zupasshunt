"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SemaphoreSignaturePCDPackage = exports.getDisplayOptions = exports.deserialize = exports.serialize = exports.verify = exports.prove = exports.init = exports.STATIC_SIGNATURE_PCD_NULLIFIER = void 0;
const semaphore_identity_pcd_1 = require("@pcd/semaphore-identity-pcd");
const util_1 = require("@pcd/util");
const group_1 = require("@semaphore-protocol/group");
const proof_1 = require("@semaphore-protocol/proof");
const json_bigint_1 = __importDefault(require("json-bigint"));
const uuid_1 = require("uuid");
const SemaphoreSignaturePCD_1 = require("./SemaphoreSignaturePCD");
/**
 * All signature PCDs are 'namespaced' to this pseudo-random nullifier,
 * so that they cannot be reused by malicious actors across different
 * applications.
 */
exports.STATIC_SIGNATURE_PCD_NULLIFIER = (0, util_1.generateSnarkMessageHash)("hardcoded-nullifier");
let initArgs = undefined;
async function init(args) {
    initArgs = args;
}
exports.init = init;
async function prove(args) {
    if (!initArgs) {
        throw new Error("cannot make semaphore signature proof: init has not been called yet");
    }
    const serializedIdentityPCD = args.identity.value?.pcd;
    if (!serializedIdentityPCD) {
        throw new Error("cannot make semaphore signature proof: identity is not set");
    }
    const identityPCD = await semaphore_identity_pcd_1.SemaphoreIdentityPCDPackage.deserialize(serializedIdentityPCD);
    if (args.signedMessage.value === undefined) {
        throw new Error("cannot make semaphore signature proof: signed message is not set");
    }
    // Set up singleton group
    const group = new group_1.Group(1, 16);
    group.addMember(identityPCD.claim.identityV3.commitment);
    // Get Keccak256 hashed version of message for input into Semaphore
    const signal = (0, util_1.generateSnarkMessageHash)(args.signedMessage.value);
    // Set externalNullifier to be identity commitment to avoid nullifier
    // of other groups being exposed. This means that one must not use their
    // identity commitment as an externalNullifier for other groups, if they
    // wish to maintain anonymity.
    const fullProof = await (0, proof_1.generateProof)(identityPCD.claim.identityV3, group, exports.STATIC_SIGNATURE_PCD_NULLIFIER, signal, {
        zkeyFilePath: initArgs.zkeyFilePath,
        wasmFilePath: initArgs.wasmFilePath
    });
    const claim = {
        identityCommitment: identityPCD.claim.identityV3.commitment.toString(),
        signedMessage: args.signedMessage.value,
        nullifierHash: fullProof.nullifierHash + ""
    };
    const proof = fullProof.proof;
    return new SemaphoreSignaturePCD_1.SemaphoreSignaturePCD((0, uuid_1.v4)(), claim, proof);
}
exports.prove = prove;
async function verify(pcd) {
    // Set up singleton group
    const group = new group_1.Group(1, 16);
    group.addMember(pcd.claim.identityCommitment);
    // Convert PCD into Semaphore FullProof
    const fullProof = {
        externalNullifier: exports.STATIC_SIGNATURE_PCD_NULLIFIER.toString(),
        merkleTreeRoot: group.root + "",
        nullifierHash: pcd.claim.nullifierHash,
        proof: pcd.proof,
        signal: (0, util_1.generateSnarkMessageHash)(pcd.claim.signedMessage).toString()
    };
    // check if proof is valid
    const validProof = await (0, proof_1.verifyProof)(fullProof, 16);
    return validProof;
}
exports.verify = verify;
async function serialize(pcd) {
    return {
        type: SemaphoreSignaturePCD_1.SemaphoreSignaturePCDTypeName,
        pcd: (0, json_bigint_1.default)().stringify(pcd)
    };
}
exports.serialize = serialize;
async function deserialize(serialized) {
    const { id, claim, proof } = (0, json_bigint_1.default)().parse(serialized);
    (0, util_1.requireDefinedParameter)(id, "id");
    (0, util_1.requireDefinedParameter)(claim, "claim");
    (0, util_1.requireDefinedParameter)(proof, "proof");
    return new SemaphoreSignaturePCD_1.SemaphoreSignaturePCD(id, claim, proof);
}
exports.deserialize = deserialize;
function getDisplayOptions(pcd) {
    return {
        header: "Semaphore Signature",
        displayName: "semaphore-sig-" + pcd.id.substring(0, 4)
    };
}
exports.getDisplayOptions = getDisplayOptions;
/**
 * PCD-conforming wrapper to sign messages using one's Semaphore public key. This is a small
 * extension of the existing Semaphore protocol, which is mostly geared at group signatures.
 * Find documentation of Semaphore here: https://semaphore.appliedzkp.org/docs/introduction
 */
exports.SemaphoreSignaturePCDPackage = {
    name: SemaphoreSignaturePCD_1.SemaphoreSignaturePCDTypeName,
    getDisplayOptions,
    init,
    prove,
    verify,
    serialize,
    deserialize
};
