"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EdDSATicketPCDPackage = exports.getDisplayOptions = exports.ticketDisplayName = exports.deserialize = exports.serialize = exports.verify = exports.prove = void 0;
const eddsa_pcd_1 = require("@pcd/eddsa-pcd");
const pcd_types_1 = require("@pcd/pcd-types");
const json_bigint_1 = __importDefault(require("json-bigint"));
const lodash_1 = __importDefault(require("lodash"));
const uuid_1 = require("uuid");
const EdDSATicketPCD_1 = require("./EdDSATicketPCD");
const utils_1 = require("./utils");
/**
 * Creates a new {@link EdDSATicketPCD} by generating an {@link EdDSATicketPCDProof}
 * and deriving an {@link EdDSATicketPCDClaim} from the given {@link EdDSATicketPCDArgs}.
 */
async function prove(args) {
    if (!args.privateKey.value) {
        throw new Error("missing private key");
    }
    if (!args.ticket.value) {
        throw new Error("missing ticket value");
    }
    const serializedTicket = (0, utils_1.ticketDataToBigInts)(args.ticket.value);
    // Creates an EdDSA PCD where the message is a serialized ticket,
    const eddsaPCD = await eddsa_pcd_1.EdDSAPCDPackage.prove({
        message: {
            value: serializedTicket.map((b) => b.toString()),
            argumentType: pcd_types_1.ArgumentTypeName.StringArray
        },
        privateKey: {
            value: args.privateKey.value,
            argumentType: pcd_types_1.ArgumentTypeName.String
        },
        id: {
            value: undefined,
            argumentType: pcd_types_1.ArgumentTypeName.String
        }
    });
    const id = args.id.value ?? (0, uuid_1.v4)();
    return new EdDSATicketPCD_1.EdDSATicketPCD(id, { ticket: args.ticket.value }, { eddsaPCD });
}
exports.prove = prove;
/**
 * Verifies an EdDSA Ticket PCD by checking that its {@link EdDSATicketPCDClaim} corresponds to
 * its {@link EdDSATicketPCDProof}. If they match, the function returns true, otherwise false.
 * In most cases, verifying the validity of the PCD with this function is not enough.
 * It may also be necessary to ensure that the parameters of the ticket, such as the
 * productId and eventId, match the expected values, and that the public key of the
 * entity that signed the ticket is indeed the authority for that event.
 */
async function verify(pcd) {
    const messageDerivedFromClaim = (0, utils_1.ticketDataToBigInts)(pcd.claim.ticket);
    if (!lodash_1.default.isEqual(messageDerivedFromClaim, pcd.proof.eddsaPCD.claim.message)) {
        return false;
    }
    return eddsa_pcd_1.EdDSAPCDPackage.verify(pcd.proof.eddsaPCD);
}
exports.verify = verify;
/**
 * Serializes an {@link EdDSATicketPCD}.
 * @param pcd The EdDSA Ticket PCD to be serialized.
 * @returns The serialized version of the EdDSA Ticket PCD.
 */
async function serialize(pcd) {
    const serializedEdDSAPCD = await eddsa_pcd_1.EdDSAPCDPackage.serialize(pcd.proof.eddsaPCD);
    return {
        type: EdDSATicketPCD_1.EdDSATicketPCDTypeName,
        pcd: (0, json_bigint_1.default)().stringify({
            id: pcd.id,
            eddsaPCD: serializedEdDSAPCD,
            ticket: pcd.claim.ticket
        })
    };
}
exports.serialize = serialize;
/**
 * Deserializes a serialized {@link EdDSATicketPCD}.
 * @param serialized The serialized PCD to deserialize.
 * @returns The deserialized version of the EdDSA Ticket PCD.
 */
async function deserialize(serialized) {
    const deserializedWrapper = (0, json_bigint_1.default)().parse(serialized);
    const deserializedEdDSAPCD = await eddsa_pcd_1.EdDSAPCDPackage.deserialize(deserializedWrapper.eddsaPCD.pcd);
    return new EdDSATicketPCD_1.EdDSATicketPCD(deserializedWrapper.id, { ticket: deserializedWrapper.ticket }, { eddsaPCD: deserializedEdDSAPCD });
}
exports.deserialize = deserialize;
function ticketDisplayName(eventName, ticketName) {
    let displayName = "";
    if (eventName && eventName?.length > 0) {
        displayName += eventName;
    }
    if (ticketName && ticketName?.length > 0) {
        if (displayName.length === 0) {
            displayName = ticketName;
        }
        else {
            displayName += ` (${ticketName})`;
        }
    }
    return displayName.length === 0 ? "untitled" : displayName;
}
exports.ticketDisplayName = ticketDisplayName;
/**
 * Provides the information about the {@link EdDSATicketPCD} that will be displayed
 * to users on Zupass.
 * @param pcd The EdDSA Ticket PCD instance.
 * @returns The information to be displayed, specifically `header` and `displayName`.
 */
function getDisplayOptions(pcd) {
    const ticketData = (0, utils_1.getEdDSATicketData)(pcd);
    if (!ticketData) {
        return {
            header: "Ticket",
            displayName: "ticket-" + pcd.id.substring(0, 4)
        };
    }
    const displayName = ticketDisplayName(ticketData.eventName, ticketData.ticketName);
    let header = displayName;
    if (ticketData.isRevoked) {
        header = `[CANCELED] ${displayName}`;
    }
    else if (ticketData.isConsumed) {
        header = `[SCANNED] ${displayName}`;
    }
    return {
        header,
        displayName
    };
}
exports.getDisplayOptions = getDisplayOptions;
/**
 * The PCD package of the EdDSA Ticket PCD. It exports an object containing
 * the code necessary to operate on this PCD data.
 */
exports.EdDSATicketPCDPackage = {
    name: EdDSATicketPCD_1.EdDSATicketPCDTypeName,
    getDisplayOptions,
    prove,
    verify,
    serialize,
    deserialize
};
