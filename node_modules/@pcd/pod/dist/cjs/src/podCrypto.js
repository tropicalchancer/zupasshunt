"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyPODRootSignature = exports.signPODRoot = exports.deriveSignerPublicKey = exports.decodeSignature = exports.encodeSignature = exports.decodePublicKey = exports.encodePublicKey = exports.decodePrivateKey = exports.encodePrivateKey = exports.podMerkleTreeHash = exports.podValueHash = exports.podNameHash = exports.podEdDSAPublicKeyHash = exports.podIntHash = exports.podBytesHash = void 0;
const eddsa_poseidon_1 = require("@zk-kit/eddsa-poseidon");
const utils_1 = require("@zk-kit/utils");
const js_sha256_1 = require("js-sha256");
const poseidon1_1 = require("poseidon-lite/poseidon1");
const poseidon2_1 = require("poseidon-lite/poseidon2");
const podChecks_1 = require("./podChecks");
const podTypes_1 = require("./podTypes");
const podUtil_1 = require("./podUtil");
/**
 * Calculates the appropriate hash for a POD value represented as a string or
 * bytes, which could be one of multiple value types (see {@link podValueHash}).
 */
function podBytesHash(input) {
    return BigInt("0x" + (0, js_sha256_1.sha256)(input)) >> 8n;
}
exports.podBytesHash = podBytesHash;
/**
 * Calculates the appropriate hash for a POD value represented as an integer,
 * which could be one of multiple value types (see {@link podValueHash}).
 */
function podIntHash(input) {
    return (0, poseidon1_1.poseidon1)([input]);
}
exports.podIntHash = podIntHash;
/**
 * Calculates the appropriate hash for a POD value represented as a string-encoded EdDSA public key.
 */
function podEdDSAPublicKeyHash(input) {
    return (0, poseidon2_1.poseidon2)(decodePublicKey(input));
}
exports.podEdDSAPublicKeyHash = podEdDSAPublicKeyHash;
/**
 * Calculates the appropriate hash for a POD entry name.
 */
function podNameHash(podName) {
    return podBytesHash(podName);
}
exports.podNameHash = podNameHash;
/**
 * Calculates the appropriate hash for a POD value of any type.
 */
function podValueHash(podValue) {
    switch (podValue.type) {
        case "string":
        case "bytes":
            return podBytesHash(podValue.value);
        case "int":
        case "cryptographic":
            return podIntHash(podValue.value);
        case "boolean":
            return podIntHash(podValue.value ? 1n : 0n);
        case podTypes_1.EDDSA_PUBKEY_TYPE_STRING:
            return podEdDSAPublicKeyHash(podValue.value);
        case "date":
            return podIntHash(BigInt(podValue.value.getTime()));
        case "null":
            return podTypes_1.POD_NULL_HASH;
        default:
            throw new TypeError(`Unexpected type in PODValue ${podValue}.`);
    }
}
exports.podValueHash = podValueHash;
/**
 * The hash function used to generate interior nodes in the Merkle tree
 * representing a POD.  The inputs may be value hashes, or other inner
 * nodes.
 */
function podMerkleTreeHash(left, right) {
    return (0, poseidon2_1.poseidon2)([left, right]);
}
exports.podMerkleTreeHash = podMerkleTreeHash;
/**
 * Encodes a private key to a string.  The input must be 32 bytes.  The output
 * is represented as unpadded Base64 by default.
 *
 * @param rawPrivateKey the private key bytes
 * @param encoding one of the supported encodings to use, as per
 *   {@link encodeBytes}.
 * @throws TypeError if the size of the buffer is incorrect.
 */
function encodePrivateKey(rawPrivateKey, encoding = "base64") {
    if (!(rawPrivateKey instanceof Uint8Array)) {
        throw TypeError("Private key must be Buffer or Uint8Array.");
    }
    if (rawPrivateKey.length !== 32) {
        throw TypeError("Private key must be a 32 bytes.");
    }
    return (0, podUtil_1.encodeBytes)(rawPrivateKey, encoding);
}
exports.encodePrivateKey = encodePrivateKey;
/**
 * Decodes a private key's bytes from a string.  The input must be 32 bytes,
 * represented as hex or Base64.  Base64 padding is optional.
 *
 * @param privateKey the private key string to decode
 * @throws TypeError if the private key format is incorrect.
 */
function decodePrivateKey(privateKey) {
    return (0, podUtil_1.decodeBytesAuto)(privateKey, podChecks_1.POD_PRIVATE_KEY_REGEX, podChecks_1.PUBLIC_KEY_ENCODING_GROUPS, "Private key should be 32 bytes, encoded as hex or Base64.");
}
exports.decodePrivateKey = decodePrivateKey;
/**
 * Encodes an EdDSA public key into a compact string represenation.  The output
 * is 32 bytes, represented as unpadded Base64 by default.
 *
 * @param rawPublicKey the EdDSA public key to encode
 * @param encoding one of the supported encodings to use
 */
function encodePublicKey(rawPublicKey, encoding = "base64") {
    return (0, podUtil_1.encodeBytes)((0, utils_1.leBigIntToBuffer)((0, eddsa_poseidon_1.packPublicKey)(rawPublicKey), 32), encoding);
}
exports.encodePublicKey = encodePublicKey;
/**
 * Decodes a public key packed by {@encodePublicKey}.  The input must be
 * 32 bytes, represented as hex or Base64.  Base64 padding is optional.
 *
 * @param publicKey the public key string to decode
 * @throws TypeError if the public key format is incorrect.
 */
function decodePublicKey(publicKey) {
    const rawPublicKey = (0, eddsa_poseidon_1.unpackPublicKey)((0, utils_1.leBufferToBigInt)((0, podUtil_1.decodeBytesAuto)(publicKey, podChecks_1.POD_PUBLIC_KEY_REGEX, podChecks_1.PUBLIC_KEY_ENCODING_GROUPS, "Public key should be 32 bytes, encoded as hex or Base64.")));
    if (rawPublicKey === null) {
        throw new TypeError(`Invalid packed public key point ${publicKey}.`);
    }
    return rawPublicKey;
}
exports.decodePublicKey = decodePublicKey;
/**
 * Encodes an EdDSA signature into a compact string representation.
 * The output is represented in unpadded Base64 by default.
 *
 * @param rawSignature the EdDSA signature to encode
 * @param encoding one of the supported encodings to use
 */
function encodeSignature(rawSignature, encoding = "base64") {
    return (0, podUtil_1.encodeBytes)((0, eddsa_poseidon_1.packSignature)(rawSignature), encoding);
}
exports.encodeSignature = encodeSignature;
/**
 * Decodes a signature produced by {@link encodeSignature}.  The input must be
 * 64 bytes, represented as hex or Base64.  Base64 padding is optional.
 *
 * @param encodedSignature the signature string to decode
 * @throws TypeError if the signature format is incorrect
 */
function decodeSignature(encodedSignature) {
    return (0, eddsa_poseidon_1.unpackSignature)((0, podUtil_1.decodeBytesAuto)(encodedSignature, podChecks_1.POD_SIGNATURE_REGEX, podChecks_1.SIGNATURE_ENCODING_GROUPS, "Signature should be 64 bytes, encoded as hex or Base64."));
}
exports.decodeSignature = decodeSignature;
/**
 * Calculates the corresponding public key for the given private key.  This is
 * equivalent to the calculation performed in {@link signPODRoot}, and can be
 * used to pre-publish the expected public key to clients before signing.
 *
 * @param privateKey the signer's private key, which is 32 bytes encoded as
 *   per {@link encodePrivateKey}.
 * @returns The signer's public key, which is 32 bytes encoded as per
 *   {@link encodePublicKey}.
 * @throws TypeError if any of the individual arguments is incorrectly formatted
 */
function deriveSignerPublicKey(privateKey) {
    const privateKeyBytes = decodePrivateKey(privateKey);
    const unpackedPublicKey = (0, eddsa_poseidon_1.derivePublicKey)(privateKeyBytes);
    return encodePublicKey(unpackedPublicKey);
}
exports.deriveSignerPublicKey = deriveSignerPublicKey;
/**
 * Signs a POD's root hash.
 *
 * @param root the root hash (content ID) of the POD.
 * @param privateKey the signer's private key, which is 32 bytes encoded as
 *   per {@link encodePrivateKey}.
 * @returns The signature as well as the signer's public key for inclusion
 *   in the POD.  The signature is 64 bytes represented in unpadded Base64.
 * @throws TypeError if any of the individual arguments is incorrectly formatted
 */
function signPODRoot(root, privateKey) {
    if (typeof root !== "bigint") {
        throw new TypeError("POD root must be a bigint not `${typeof root}`.");
    }
    const privateKeyBytes = decodePrivateKey(privateKey);
    const unpackedSignature = (0, eddsa_poseidon_1.signMessage)(privateKeyBytes, root);
    const signature = encodeSignature(unpackedSignature);
    const unpackedPublicKey = (0, eddsa_poseidon_1.derivePublicKey)(privateKeyBytes);
    const publicKey = encodePublicKey(unpackedPublicKey);
    return { signature, publicKey };
}
exports.signPODRoot = signPODRoot;
/**
 * Verifies the signature of a POD root hash.
 *
 * @param root the root hash (content ID) of the POD.
 * @param signature the signature in packed form, which is 64 bytes represented
 *   in hex or Base64.  Base64 padding is optional.
 * @param publicKey the signer's public key in packed form, which is 32 bytes
 *   represented in hex or Base64.  Base64 padding is optional.
 * @returns `true` if the signature is valid
 * @throws TypeError if any of the individual arguments incorrectly formatted
 */
function verifyPODRootSignature(root, signature, publicKey) {
    const unpackedPublicKey = decodePublicKey(publicKey);
    const unpackedSignature = decodeSignature(signature);
    return (0, eddsa_poseidon_1.verifySignature)(root, unpackedSignature, unpackedPublicKey);
}
exports.verifyPODRootSignature = verifyPODRootSignature;
