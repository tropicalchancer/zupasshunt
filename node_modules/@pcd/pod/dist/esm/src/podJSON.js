import { checkBase64Encoding, checkPODName, checkPODValue, requireType } from "./podChecks.js";
import { decodeBytesRaw, encodeBytes } from "./podUtil.js";
/**
 * Parses {@link PODEntries} from the JSON-compatible format potentially
 * coming directly from `JSON.parse`.
 *
 * @param jsonEntries the JSON-encoded POD entries to parse
 * @returns a standard TypeScript POD entries representation
 * @throws TypeError if the input entries are not validly formed
 * @throws RangeError if a value is outside of the bounds
 * @throws SyntaxError if a value is unparseable
 */
export function podEntriesFromJSON(jsonEntries) {
    requireType("jsonEntries", jsonEntries, "object");
    return Object.fromEntries(Object.entries(jsonEntries).map(([name, jsonValue]) => [
        checkPODName(name),
        podValueFromJSON(jsonValue, name)
    ]));
}
/**
 * Parses a {@link PODValue} from the JSON-compatible format potentially
 * coming directly from `JSON.parse`.
 *
 * @param jsonValue the JSON-encoded POD value to parse
 * @param nameForErrorMessages an optional name for this value to be used
 *   in error messages
 * @returns a standard TypeScript POD value
 * @throws TypeError if the input value is not validly formed
 * @throws RangeError if a value is outside of the bounds
 * @throws SyntaxError if a value is unparseable
 */
export function podValueFromJSON(jsonValue, nameForErrorMessages) {
    nameForErrorMessages = nameForErrorMessages || "(unnamed)";
    switch (typeof jsonValue) {
        case "string":
            return podValueFromTypedJSON("string", jsonValue, nameForErrorMessages);
        case "number":
            return podValueFromTypedJSON("int", jsonValue, nameForErrorMessages);
        case "boolean":
            return podValueFromTypedJSON("boolean", jsonValue, nameForErrorMessages);
        case "object":
            if (Array.isArray(jsonValue)) {
                throw new TypeError(`Value ${nameForErrorMessages} isn't a well-formed JSON POD Value.` +
                    "  It should be an object not an array.");
            }
            if (jsonValue === null) {
                return podValueFromTypedJSON("null", null, nameForErrorMessages);
            }
            if (Object.keys(jsonValue).length !== 1) {
                throw new TypeError(`Value ${nameForErrorMessages} isn't a well-formed JSON POD Value.` +
                    "  It should be an object with a single key.");
            }
            const [n, v] = Object.entries(jsonValue)[0];
            return podValueFromTypedJSON(n, v, nameForErrorMessages);
        default:
            throw new TypeError(`Value ${nameForErrorMessages} has invalid type '${typeof jsonValue}'.`);
    }
}
/**
 * Parses a {@link PODValue} from JSON-compatible inputs which have already
 * been parsed into separate `type` and `value`.  Most use cases should use
 * {@link podValueFromJSON} instead.  This function is intended as a helper
 * for other parsers with their own source of type information.
 *
 * @param podValueType the type of {@link PODValue} expected
 * @param jsonRawValue the JSON-compatible encoding of the bare value with
 *   no type information
 * @param nameForErrorMessages an optional name for this value to be used
 *   in error messages
 * @returns a standard TypeScript POD value
 * @throws TypeError if the input type or value are not validly formed
 * @throws RangeError if a value is outside of the bounds
 * @throws SyntaxError if a value is unparseable
 */
export function podValueFromTypedJSON(podValueType, jsonRawValue, nameForErrorMessages) {
    nameForErrorMessages = nameForErrorMessages || "(unnamed)";
    switch (podValueType) {
        case "string":
            return checkPODValue(nameForErrorMessages, {
                type: "string",
                value: jsonRawValue // checkPODValue checks this
            });
        case "bytes":
            requireType(nameForErrorMessages, jsonRawValue, "string");
            return checkPODValue(nameForErrorMessages, {
                type: "bytes",
                value: decodeBytesRaw(checkBase64Encoding(jsonRawValue, `Value ${nameForErrorMessages} must be encoded in base64.`), "base64")
            });
        case "cryptographic":
            return checkPODValue(nameForErrorMessages, {
                type: "cryptographic",
                value: bigintFromJSON(jsonRawValue, // bigintFromJSON checks this
                nameForErrorMessages)
            });
        case "int":
            return checkPODValue(nameForErrorMessages, {
                type: "int",
                value: bigintFromJSON(jsonRawValue, // bigintFromJSON checks this
                nameForErrorMessages)
            });
        case "boolean":
            return checkPODValue(nameForErrorMessages, {
                type: "boolean",
                value: jsonRawValue // checkPODValue checks this
            });
        case "eddsa_pubkey":
            return checkPODValue(nameForErrorMessages, {
                type: "eddsa_pubkey",
                value: jsonRawValue // checkPODValue checks this
            });
        case "date":
            requireType(nameForErrorMessages, jsonRawValue, "string");
            if (!jsonRawValue.endsWith("Z")) {
                throw new TypeError(`Value ${nameForErrorMessages} must be encoded in UTC.`);
            }
            return checkPODValue(nameForErrorMessages, {
                type: "date",
                value: new Date(jsonRawValue)
            });
        case "null":
            return checkPODValue(nameForErrorMessages, {
                type: "null",
                value: jsonRawValue // checkPODValue checks this
            });
        default:
            throw new TypeError(`Value ${nameForErrorMessages} specifies unknown type '${podValueType}'.`);
    }
}
/**
 * Parses an integer value into a `bigint` from JSON-compatible value encoding
 * separate from type inforation.  Most use cases should use
 * {@link podValueFromJSON} instead.  This function is intended as a helper
 * for other parsers with their own source of type information.
 *
 * @param numericValue the encoded numeric value, which could be a number, or
 *   a stringified number
 * @param nameForErrorMessages an optional name for this value to be used
 *   in error messages
 * @returns a bigint representing the number
 * @throws TypeError if the input type or value are not validly formed
 * @throws RangeError if a value is outside of the bounds
 * @throws SyntaxError if a value is unparseable
 */
export function bigintFromJSON(numericValue, nameForErrorMessages) {
    nameForErrorMessages = nameForErrorMessages || "(unnamed)";
    switch (typeof numericValue) {
        case "number":
            if (numericValue > Number.MAX_SAFE_INTEGER ||
                numericValue < Number.MIN_SAFE_INTEGER) {
                // This is to catch a mistake in JSON generation as early as possible.
                // JSON.parse will parse overly large values but lose accuracy.
                // Throwing here is more informative than waiting for a signature
                // validation to fail.
                throw new RangeError(`Numeric value ${nameForErrorMessages} is too large to be safely` +
                    " represented in JSON and must be stringified instead.");
            }
            return BigInt(numericValue);
        case "string":
            return BigInt(numericValue);
        default:
            throw new TypeError(`Value ${nameForErrorMessages} is an unexpected type ` +
                `'${typeof numericValue}'.  Numeric values must be encoded as a ` +
                "number or string.");
    }
}
/**
 * Converts {@link PODEntries} from the TypeScript format used internally, into
 * a JSON-compatible format safe to serialize with `JSON.stringify`.  This
 * function will produce the simplest of the available encodings which can
 * represent the input with no loss value or type information.
 *
 * @param podEntries the POD entries to convert
 * @returns a JSON-compatible representation
 * @throws TypeError if the input entries are not validly formed
 */
export function podEntriesToJSON(podEntries) {
    requireType("podEntries", podEntries, "object");
    return Object.fromEntries(Object.entries(podEntries).map(([name, podValue]) => [
        checkPODName(name),
        podValueToJSON(podValue, name)
    ]));
}
/**
 * Converts a {@link PODValue} from the TypeScript format used internally, into
 * a JSON-compatible format safe to serialize with `JSON.stringify`.  This
 * function will produce the simplest of the available encodings which can
 * represent the input with no loss value or type information.
 *
 * @param podValue the POD entries to convert
 * @param nameForErrorMessages an optional name for this value to be used
 *   in error messages
 * @returns a JSON-compatible representation
 * @throws TypeError if the input entries are not validly formed
 */
export function podValueToJSON(podValue, nameForErrorMessages) {
    nameForErrorMessages = nameForErrorMessages || "(unnamed)";
    podValue = checkPODValue(nameForErrorMessages, podValue);
    switch (podValue.type) {
        case "string":
            return podValue.value;
        case "bytes":
            return { bytes: encodeBytes(podValue.value, "base64") };
        case "cryptographic":
            return { cryptographic: bigintToSimplestJSON(podValue.value) };
        case "int":
            const numValue = bigintToSimplestJSON(podValue.value);
            if (typeof numValue === "number") {
                return numValue;
            }
            return { int: numValue };
        case "boolean":
            return podValue.value;
        case "eddsa_pubkey":
            return { eddsa_pubkey: podValue.value };
        case "date":
            return { date: podValue.value.toJSON() };
        case "null":
            return null;
        default:
            throw TypeError(`Value ${nameForErrorMessages} has unhandled POD value ` +
                // @ts-expect-error podValue is of type `never` if we've covered all types
                `type '${podValue.type}'.`);
    }
}
/**
 * Converts a bigint to the simplest value-preserving JSON value available.
 * There is no type information included.  The output is always a number
 * (with no fractional part) or a string which can be parsed by `BigInt(s)`.
 *
 * Numbers are used preferentially for values in the range between
 * `Number.MIN_SAFE_INTEGER` and `Number.MAX_SAFE_INTEGER` where no accuracy
 * is lost.  Stringified values may be hex or decimal encoded for minimal size.
 *
 * Note that this function doesn't enforce any bounds on the input.  Any
 * bigint will be encoded, even if it's not a valid POD value.
 *
 * @param n the input integer
 * @returns a number or string representing this integer.
 */
export function bigintToSimplestJSON(n) {
    // For values which are in range for a JSON number (2^53), use that.
    if (n <= Number.MAX_SAFE_INTEGER && n >= Number.MIN_SAFE_INTEGER) {
        return Number(n);
    }
    // Large positive values are shorter as hex than decimal.
    // MAX_SAFE_INTEGER is large enough to be equal size even with the addition of
    // "0x", and the benefits become greater for larger values.
    if (n > 0) {
        return "0x" + n.toString(16);
    }
    // BigInt/Number parsing doesn't support hex for negative values, so
    // use decimal rather than having to write special numeric parsing.
    return n.toString();
}
