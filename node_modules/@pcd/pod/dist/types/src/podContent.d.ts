import { LeanIMTMerkleProof } from "@zk-kit/lean-imt";
import { JSONPODEntries } from "./podJSON";
import { PODEntries, PODValue } from "./podTypes";
/**
 * Merkle proof of an entry's membership in a POD.  The entry proofs returned
 * by this class are always proofs for the entry's name, while the entry's
 * value can be found as the first sibling.
 *
 * POD proofs use the Lean-IMT datastructure from @zk-kit/imt, which allows
 * shorter proofs for partially-filled subtrees.
 */
export type PODEntryProof = LeanIMTMerkleProof<bigint>;
/**
 * Info about a POD entry for inclusion in a ZK circuit.  The proof
 * is always a proof for the entry's name, while the entry's
 * value can be found as the first sibling.  Every entry has a name hash
 * and value hash as included in the Merkle tree.  The plaintext value
 * is only included for numeric values which can be directly represented
 * in a single circuit signal.
 */
export type PODEntryCircuitSignals = {
    proof: PODEntryProof;
    nameHash: bigint;
    valueHash: bigint;
    value: bigint | undefined;
};
/**
 * Class encapsulating an unsigned POD with functions for common use cases.
 * PODContent instances are immutable (within the limits of TypeScript), but
 * derived data (such as the Merkle tree of entries) is calculated lazily as it
 * is needed.
 *
 * A POD is made up of `PODEntries`, built into a Merkle tree (in sorted order)
 * to produce a root hash called the Content ID, which is then signed.  To
 * create a POD, use one of the static factory methods of this class.
 *
 * `PODContent` instances are usually contained in a signed `POD` instance.
 */
export declare class PODContent {
    private _map;
    private _merkleTree?;
    private constructor();
    /**
     * Factory for creating a new POD from entries.  The entries do not need
     * to be in sorted order, but will be sorted in the resulting `PODContent`.
     *
     * @param entries the POD entries to include
     * @returns a new PODContent
     * @throws if any of the entries aren't legal for inclusion in a POD
     */
    static fromEntries(entries: PODEntries): PODContent;
    private get merkleTree();
    /**
     * The content ID (root hash) of this POD.
     */
    get contentID(): bigint;
    /**
     * The depth of the Merkle tree representation of this POD.  The proofs
     * generated by this POD will be no longer than this, but may be shorter
     * due to the optimizations of the Lean-IMT datastructure (see @zk-kit/imt).
     */
    get merkleTreeDepth(): number;
    /**
     * The number of entries in this POD.
     */
    get size(): number;
    /**
     * @returns the contents of this POD as a PODEntries object.  Mutating
     *   this object will not change this `PODContent` instance.
     */
    asEntries(): PODEntries;
    /**
     * @returns the names of all entries in this POD, in sorted order.  Mutating
     *   this result will not change this `PODContent` instance.
     */
    listNames(): string[];
    /**
     * @returns the entries of this POD, in sorted order.  Mutating
     *   this result will not change this `PODContent` instance.
     */
    listEntries(): {
        name: string;
        value: PODValue;
    }[];
    /**
     * Gets an entry value by name.  Mutating the returned will not change this
     * `PODContent` instance.
     *
     * @param name the entry name to look up
     * @returns the value, or undefined if there is no value by that name
     */
    getValue(name: string): PODValue | undefined;
    /**
     * Gets an entry value by name, without its type tag.  Mutating the returned
     * value will not change this `PODContent` instance.
     *
     * @param name the entry name to look up
     * @returns the value, or undefined if there is no value by that name
     */
    getRawValue(name: string): PODValue["value"] | undefined;
    /**
     * Converts the entries to a JSON-compatible format which can be safely
     * serialized using `JSON.stringify` without any loss of information.  To
     * reconstitute a PODContent object from JSON, see {@link fromJSON}.
     *
     * @returns a JSON-compatible representation of this POD.
     */
    toJSON(): JSONPODEntries;
    /**
     * Rebuilds a PODContent object from entries in the JSON-compatible format
     * produced by {@link toJSON}.  The input can be taken directly from
     * `JSON.parse` and will be fully validated by this function.
     *
     * @param jsonEntries the JSON-encoded entries.
     * @returns a new POD object
     * @throws if the input is malformed
     */
    static fromJSON(jsonEntries: JSONPODEntries): PODContent;
    /**
     * Creates a new proof of membership for an entry by the given name.
     *
     * @param entryName the entry name to look up
     * @returns a membership proof for the given entry
     * @throws if the entry name is not found
     */
    generateEntryProof(entryName: string): PODEntryProof;
    /**
     * Checks the validity of a POD membership proof by recomputing hashes.
     *
     * Validity depends only on the name hash and value hash included in the
     * membership proof.  This method doesn't check (and has no access to) the
     * hash pre-image name or value.
     *
     * @param entryProof the membership proof of a POD entry
     * @returns `true` if the proof is valid.
     */
    static verifyEntryProof(entryProof: PODEntryProof): boolean;
    /**
     * Generates all necessary info about a single POD entry needed to populate
     * a proof circuit.  This includes a membership proof, as well name hash,
     * value hash, and optionally the value itself.  Note that name strings
     * never appear in circuits directly.  Values only appear in circuits
     * if they are numeric values which fit in a single circuit signal.
     *
     * @param entryName the entry name to look up
     * @returns an object containing info for circuit inputs
     * @throws if the entry name is not found
     */
    generateEntryCircuitSignals(entryName: string): PODEntryCircuitSignals;
    private _getRequiredEntry;
}
/**
 * Calculates the minimum Merkle tree depth of a POD containing the given number
 * of entries.  Since names and values are separate leaves of the tree, the
 * formula is ceil(log2(2 * nEntries)).
 *
 * @param nEntries entry count
 * @returns the required Merkle tree depth
 */
export declare function calcMinMerkleDepthForEntries(nEntries: number): number;
/**
 * Calculates the maximum number of entries which can be supported by a POD
 * with a given Merkle tree depth.  Since names and values are separate leaves
 * of the tree, the formula is 2**(merkleDepth-1)
 *
 * @param merkleDepth the depth of a POD Merkle tree
 * @returns the maximum number of entries of any POD with the given depth
 */
export declare function calcMaxEntriesForMerkleDepth(merkleDepth: number): number;
//# sourceMappingURL=podContent.d.ts.map