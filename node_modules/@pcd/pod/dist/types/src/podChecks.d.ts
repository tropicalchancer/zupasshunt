import { PODBooleanValue, PODCryptographicValue, PODDateValue, PODEntries, PODIntValue, PODName, PODValue } from "./podTypes";
import { CryptoBytesEncodingGroups } from "./podUtil";
/**
 * Private keys are 32 bytes (any arbitrary bytes), represented as Base64 or
 * hexadecimal
 *
 * This regex matches any supported format, with match groups usable to
 * determine the format, in the order above.
 */
export declare const POD_PRIVATE_KEY_REGEX: RegExp;
/**
 * Description of the match groups in {@link POD_PRIVATE_KEY_REGEX} and how they
 * map to encoding formats, as needed by {@link decodeBytesAuto}.
 */
export declare const PRIVATE_KEY_ENCODING_GROUPS: CryptoBytesEncodingGroups;
/**
 * Public keys are 32 bytes (a packed elliptic curve point), represented as
 * Base64 or hexadecimal.  Base64 padding is optional.
 *
 * This regex matches any supported format, with match groups usable to
 * determine the format, in the order above.
 */
export declare const POD_PUBLIC_KEY_REGEX: RegExp;
/**
 * Description of the match groups in {@link POD_PUBLIC_KEY_REGEX} and how they
 * map to encoding formats, as needed by {@link decodeBytesAuto}.
 */
export declare const PUBLIC_KEY_ENCODING_GROUPS: CryptoBytesEncodingGroups;
/**
 * Signatures are 64 bytes (one packed elliptic curve point, one scalar),
 * represented as Base64 or hexadecimal.  Base64 padding is optional.
 *
 * This regex matches any supported format, with match groups usable to
 * determine the format, in the order above.
 */
export declare const POD_SIGNATURE_REGEX: RegExp;
/**
 * Description of the match groups in {@link POD_SIGNATURE_REGEX} and how they
 * map to encoding formats, as needed by {@link decodeBytesAuto}.
 */
export declare const SIGNATURE_ENCODING_GROUPS: CryptoBytesEncodingGroups;
/**
 * Checks that the input matches the proper format for a private key, as given
 * by {@link POD_PRIVATE_KEY_REGEX}.
 *
 * @param privateKey the string to check
 * @returns the unmodified input, for easy chaining
 * @throws TypeError if the format doesn't match
 */
export declare function checkPrivateKeyFormat(privateKey: string): string;
/**
 * Checks that the input matches the proper format for a public key, as given
 * by {@link POD_PUBLIC_KEY_REGEX}.
 *
 * @param nameForErrorMessages the name of this value, which is used only for
 *   error messages (not checked for legality).
 * @param publicKey the string to check
 * @returns the unmodified input, for easy chaining
 * @throws TypeError if the format doesn't match
 */
export declare function checkPublicKeyFormat(publicKey: string, nameForErrorMessages?: string): string;
/**
 * Checks that the input matches the proper format for a signature, as given
 * by {@link POD_SIGNATURE_REGEX}.
 *
 * @param signature the string to check
 * @returns the unmodified input, for easy chaining
 * @throws TypeError if the format doesn't match
 */
export declare function checkSignatureFormat(signature: string): string;
/**
 * Regular expression matching valid Base64 encoding of any length, allowing
 * padding to be omitted.
 */
export declare const POD_BASE64_REGEX: RegExp;
/**
 * Checks that the given string is encoded in valid Base64, allowing padding
 * to be omitted.
 *
 * @param encoded the string-encoded bytes
 * @param errorMessage human-readable message for error thrown if decoding
 *  fails.
 * @returns
 */
export declare function checkBase64Encoding(encoded: string, errorMessage?: string): string;
/**
 * Regular expression matching valid hex encoding.
 */
export declare const POD_HEX_REGEX: RegExp;
/**
 * Checks that the given string is encoded in valid Base64.
 *
 * @param encoded the string-encoded bytes
 * @param errorMessage human-readable message for error thrown if decoding
 *  fails.
 * @returns
 */
export declare function checkHexEncoding(encoded: string, errorMessage?: string): string;
/**
 * Checks that the input matches the proper format for an entry name, as given
 * by {@link POD_NAME_REGEX}.
 *
 * @param name the string to check
 * @returns the unmodified input, for easy chaining
 * @throws TypeError if the format doesn't match
 */
export declare function checkPODName(name?: string): PODName;
/**
 * Checks that the input matches the proper format for {@link PODEntries}, by
 * checking each name and value in turn.
 *
 * @param podEntries the entries to check
 * @throws TypeError if the input type, or any of the names or values are
 *   invalid
 * @throws RangeError if a value is outside of the bounds
 */
export declare function checkPODEntries(podEntries: PODEntries): void;
/**
 * Checks that `value` has the run-time type given by `typeName`.
 *
 * Works for any runtime JavaScript type, but three values have special meaning.
 * "object" is used specifically to require a non-null non-array object, while
 * "array" is used to mean a non-null array object, and "null" is used for the
 * null object.
 *
 * @param nameForErrorMessages the name for this value, used only for error
 *   messages.
 * @param value the value to check
 * @param typeName the expected type
 * @throws TypeError if the value does not have the expected type
 */
export declare function requireType(nameForErrorMessages: string, value: unknown, typeName: string): void;
/**
 * Checks that `value` has the run-time type given by `typeName`, and returns
 * the value for easy chaining.
 *
 * Works identically to {@link requireType} except that the compile-time type of
 * input/output is limited to expected POD value types to help catch errors
 * at compile time.
 *
 * @param nameForErrorMessages the name for this value, used only for error
 *   messages.
 * @param value the value to check
 * @param typeName the expected type
 * @returns the value unmodified, for easy chaining
 * @throws TypeError if the value does not have the expected type
 */
export declare function requireValueType(nameForErrorMessages: string, value: PODValue["value"], typeName: string): PODValue["value"];
/**
 * Checks that the given value is between the given bounds.  The bounds are
 * both inclusive, so that they can also be legal values in the same bounds.
 *
 * @param nameForErrorMessages the name of this value, used only for error
 *   messages
 * @param value the value to check
 * @param minValue the minimum legal value (inclusive lower bound)
 * @param maxValue the maximum legal value (inclusive upper bound)
 * @returns the value unmodified, for easy chaining
 * @throws RangeError if the value is outside of the bounds
 */
export declare function checkBigintBounds(nameForErrorMessages: string, value: bigint, minValue: bigint, maxValue: bigint): bigint;
/**
 * Check that `PODValue` object has a value which matches the specified type.
 *
 * @param nameForErrorMessages the name of this value, which is used only for
 *   error messages (not checked for legality).
 * @param podValue the value to check
 * @returns the unmodified value, for easy chaining
 * @throws TypeError if the value is invalid
 * @throws RangeError if the value is outside of the bounds
 */
export declare function checkPODValue(nameForErrorMessages: string, podValue?: PODValue): PODValue;
/**
 * Checks whether a given value is a fixed-size numeric value, which can be
 * represented in a circuit as a single signal.
 *
 * @param podValue the value to check
 * @returns `true` if the given value is numeric
 */
export declare function isPODNumericValue(podValue: PODValue): podValue is PODCryptographicValue | PODIntValue | PODBooleanValue | PODDateValue;
/**
 * Checks whether a given value is a bounded numeric value of a type which
 * can be subject to ordered comparison or arithmetic in a circuit.  The
 * determination is based on the value's type, not its specific value.  This
 * returns true for all numeric types with a range fitting inside of the
 * PODIntValue type.
 *
 * @param podValue the value to check
 * @returns `true` if the given value is arithmetic
 */
export declare function isPODArithmeticValue(podValue: PODValue): podValue is PODIntValue | PODBooleanValue | PODDateValue;
//# sourceMappingURL=podChecks.d.ts.map