/// <reference types="node" />
import { PODEntries, PODValue, PODValueTuple } from "./podTypes";
/**
 * Gets the numeric representation of the given value for inclusion in a
 * circuit, if any.
 *
 * @param podValue the value to convert
 * @returns the numeric value, or undefined if this value cannot be represented
 *   in a circuit
 */
export declare function getPODValueForCircuit(podValue: PODValue): bigint | undefined;
/**
 * As {@link getPODValueForCircuit} but throws a TypeError if the value is not
 * of a numeric type.
 *
 * @param podValue the value to convert
 * @param nameForErrorMessages the name of this value, which is used only for
 *   error messages (not checked for legality).
 * @returns the numeric value, or undefined if this value cannot be represented
 *   in a circuit
 */
export declare function getRequiredPODValueForCircuit(podValue: PODValue, nameForErrorMesages?: string): bigint;
/**
 * Makes a safe copy of a PODValue, so that modfications to the new value
 * will not affect the original.
 */
export declare function clonePODValue(podValue: PODValue): PODValue;
/**
 * Makes a safe copy of a PODValue (or undefined), so that modfications to the
 * new value will not affect the original.
 */
export declare function cloneOptionalPODValue(podValue: PODValue | undefined): PODValue | undefined;
/**
 * Makes a safe copy of the given `PODEntries`, so that modfications to the
 * new entries will not affect the original.
 */
export declare function clonePODEntries(entries: PODEntries): PODEntries;
/**
 * Converts a POD value to a human-readable string for logging our user display
 * purposes.  The output is based on the {@link JSONPODValue} format, but also
 * allows the entire value to be undefined
 *
 * @param podValue the POD value (or undefined) to print
 * @returns a human-readable string
 * @throws if the POD value is malformed
 */
export declare function printPODValue(podValue: PODValue | undefined): string;
/**
 * Converts a POD value or tuple to a human-readable string for logging our user
 * display purposes.  The output is based on the {@link JSONPODValue} format,
 * but also handles the case where the whole value is undefined (but not
 * undefined values inside of a tuple).
 *
 * @param podValue the POD value (or undefined) to print
 * @returns a human-readable string
 * @throws if the POD value is malformed
 */
export declare function printPODValueOrTuple(value: PODValue | PODValueTuple | undefined): string;
/**
 * Computation streamliner involving unions of the form A | A[] and functions of the form f: A -> B. It applies f to inputs of type A and maps f over A[] otherwise.
 *
 * @param f function to apply to input
 * @param input input argument
 * @returns result of appropriate application of function to input
 */
export declare function applyOrMap<A, B>(f: (a: A) => B, input: A | A[]): B | B[];
/**
 * Supported encodings for cryptographic bytes (keys, signatures) used in
 * this library.
 */
export type CryptoBytesEncoding = "hex" | "base64";
/**
 * Description of the match groups in a regex used by {@link decodeBytesAuto}.
 * If the regex matches, the decoding function will check for a non-empty
 * match in each listed group number in order, and decode using the specified
 * encoding.
 */
export type CryptoBytesEncodingGroups = {
    index: number;
    encoding: CryptoBytesEncoding;
}[];
/**
 * Encode cryptographic bytes (keys, signatures) in the given encoding.
 *
 * @param bytes raw bytes to encoded
 * @param encoding one of the supported encoding specifiers.  Default is
 *   `base64`, and padding is always stripped from base64 encoded output.
 * @returns a string encoding of the bytes
 */
export declare function encodeBytes(bytes: Uint8Array, encoding?: CryptoBytesEncoding): string;
/**
 * Decodes cryptographic bytes (keys, signatures) using the given encoding.
 * Note that this function doesn't check that the input is actually valid, but
 * will truncate the output to only the valid prefix of input.
 *
 * @param encoded the encoded string
 * @param encoding one of the supported encoding specifiers.  Default is
 *   `base64`, and padding is always stripped from base64 encoded output.
 * @returns decoded bytes, truncated if the input does not properly match the
 *   encoding format
 */
export declare function decodeBytesRaw(encoded: string, encoding?: CryptoBytesEncoding): Buffer;
/**
 * Decodes cryptographic bytes from a string, auto-determining the encoding
 * based on the input length and character set.
 *
 * @param encoded the string-encoded bytes
 * @param encodingPattern a regex which matches valid encodings of bytes with
 *   an expected fixed size.  This pattern is expected to have groups
 *   separately matching each of the supported encodings.  See
 *   {@link PRIVATE_KEY_REGEX} for an example.
 * @param encodingGroups a description of the match groups in the regex,
 *   in the order they should be checked.
 * @param errorMessage human-readable message for error thrown if decoding
 *  fails.
 * @throws TypeError if the pattern doesn't match
 */
export declare function decodeBytesAuto(encoded: string, encodingPattern: RegExp, encodingGroups: CryptoBytesEncodingGroups, errorMessage?: string): Buffer;
//# sourceMappingURL=podUtil.d.ts.map