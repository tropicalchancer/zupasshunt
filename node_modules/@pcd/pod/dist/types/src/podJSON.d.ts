import { PODEntries, PODName, PODValue } from "./podTypes";
/**
 * Defines the JSON encoding of a POD.  Unlike the {@link POD} class, objects
 * which fit this type contain only JSON-compatible types (no bigints).
 * They can thus be freely combined with other JSON and serialized using
 * JSON.stringify.  See {@link JSONPODValue} for details of the encodings used.
 */
export type JSONPOD = {
    entries: JSONPODEntries;
    signature: string;
    signerPublicKey: string;
};
/**
 * Defines the JSON encoding of a bigint value, which may be represented as
 * a Number if it's small enough, or otherwise stringified using any format
 * accepted by the BigInt constructor.
 *
 * JSON-encoded bigints are not unambiguously distinguished form strings, and
 * thus must generally be embedded inside of another type (such as a PODValue)
 * which gives type hints or context.
 */
export type JSONBigInt = number | string;
/**
 * Defines the JSON encoding of a POD value.  Unlike the {@link PODValue} type,
 * values which fit this type contain only JSON-compatible types (no bigints).
 * They can thus be freely combined with other JSON and serialized using
 * JSON.stringify.
 *
 * For each PODValue type, there can be up to 3 possible encoding formats,
 * which are intended to allow terse and human-readable.
 * - A bare JSON type, such as `number` for int, and `string` for string
 * - A terse JSON object with the PODValue type as its only key, like
 *   `{ "int": 123 }`
 * - An explicit JSON object with 2 keys, like `{ "type": "int", "value": 123 }`
 *
 * Use {@link podValueToJSON} and {@link podValueFromJSON} to convert between
 * JSON and non-JSON formats.  When parsing, any of the encodings above will
 * be produced.  When producing JSON, the smallest encoding will be used.
 *
 * See the individual subtypes for more information on specific encoding
 * requirements and assumptions.
 */
export type JSONPODValue = JSONPODStringValue | JSONPODBytesValue | JSONPODCryptographicValue | JSONPODIntValue | JSONPODBooleanValue | JSONPODEdDSAPublicKeyValue | JSONPODDateValue | JSONPODNullValue;
/**
 * Defines the JSON encoding of a tuple of POD values.  This is simply an
 * array of {@link JSONPODValue} objects described elsewhere.
 */
export type JSONPODValueTuple = JSONPODValue[];
/**
 * {@link JSONPODValue} type for string entries.  These can be most simply
 * encoded as a JSON string, which is reserved for this type.  They can
 * optionally be expressed with an explicit type.
 */
export type JSONPODStringValue = string | {
    string: string;
};
/**
 * {@link JSONPODValue} type for bytes entries.  These are encoded as
 * strings using Base64.
 */
export type JSONPODBytesValue = {
    bytes: string;
};
/**
 * {@link JSONPODValue} type for cryptographic entries.  These must always use
 * an explicit typed object since a bare `number` is reserved for int values.
 * The value within the typed object can be a `number` if it is in the safe
 * range between `Number.MIN_SAFE_INTEGER` and `Number.MAX_SAFE_INTEGER` where
 * no accuracy is lost.  Otherwise any string encoding accepted by `BigInt(s)`
 * is acceptable.
 */
export type JSONPODCryptographicValue = {
    cryptographic: number | string;
};
/**
 * {@link JSONPODValue} type for int entries.  These can be most simply
 * encoded as a JSON number, but only if they are in the range between
 * `Number.MIN_SAFE_INTEGER` and `Number.MAX_SAFE_INTEGER` where no accuracy
 * is lost.  Larger positive/negative values must be stringified and use one of
 * the other encodings to specify value type.  Any string encoding accepted by
 * `BigInt(s)` is acceptable.
 */
export type JSONPODIntValue = number | {
    int: number | string;
};
/**
 * {@link JSONPODValue} type for boolean entries.  These can be most simply
 * encoded as a JSON boolean, which is reserved for this type.  They can
 * optionally be expressed with an explicit type.
 */
export type JSONPODBooleanValue = boolean | {
    boolean: boolean;
};
/**
 * {@link JSONPODValue} type for EdDSA public key entries.  These must always
 * use an explicit typed object since a bare `string` is reserved for string
 * values.  The value within the typed object should be a string in a format
 * accepted by {@link decodePublicKey}.
 */
export type JSONPODEdDSAPublicKeyValue = {
    eddsa_pubkey: string;
};
/**
 * {@link JSONPODValue} type for date entries.  These must always
 * use an explicit typed object containing an ISO string encoding of
 * the date, which must use the `Z` suffix for UTC.
 */
export type JSONPODDateValue = {
    date: string;
};
/**
 * {@link JSONPODValue} type for null entries.  These can be most simply
 * encoded as a JSON null, which is reserved for this type.  They can
 * optionally be expressed with an explicit type.
 */
export type JSONPODNullValue = null | {
    null: null;
};
/**
 * Defines the JSON encoding a set of POD entries.  Unlike the
 * {@link PODEntries} type, values which fit this type contain only
 * JSON-compatible types (no bigints).  They can thus be freely combined with
 * other JSON and serialized using JSON.stringify.
 *
 * See {@link JSONPODValue} for the specifics of value encoding and parsing.
 * Use {@link podEntriesToJSON} and {@link podEntriesFromJSON} to convert
 * between JSON and non-JSON formats.  When parsing, any of the encodings above
 * will be produced.
 */
export type JSONPODEntries = Record<PODName, JSONPODValue>;
/**
 * Parses {@link PODEntries} from the JSON-compatible format potentially
 * coming directly from `JSON.parse`.
 *
 * @param jsonEntries the JSON-encoded POD entries to parse
 * @returns a standard TypeScript POD entries representation
 * @throws TypeError if the input entries are not validly formed
 * @throws RangeError if a value is outside of the bounds
 * @throws SyntaxError if a value is unparseable
 */
export declare function podEntriesFromJSON(jsonEntries: JSONPODEntries): PODEntries;
/**
 * Parses a {@link PODValue} from the JSON-compatible format potentially
 * coming directly from `JSON.parse`.
 *
 * @param jsonValue the JSON-encoded POD value to parse
 * @param nameForErrorMessages an optional name for this value to be used
 *   in error messages
 * @returns a standard TypeScript POD value
 * @throws TypeError if the input value is not validly formed
 * @throws RangeError if a value is outside of the bounds
 * @throws SyntaxError if a value is unparseable
 */
export declare function podValueFromJSON(jsonValue: JSONPODValue, nameForErrorMessages?: string): PODValue;
/**
 * Parses a {@link PODValue} from JSON-compatible inputs which have already
 * been parsed into separate `type` and `value`.  Most use cases should use
 * {@link podValueFromJSON} instead.  This function is intended as a helper
 * for other parsers with their own source of type information.
 *
 * @param podValueType the type of {@link PODValue} expected
 * @param jsonRawValue the JSON-compatible encoding of the bare value with
 *   no type information
 * @param nameForErrorMessages an optional name for this value to be used
 *   in error messages
 * @returns a standard TypeScript POD value
 * @throws TypeError if the input type or value are not validly formed
 * @throws RangeError if a value is outside of the bounds
 * @throws SyntaxError if a value is unparseable
 */
export declare function podValueFromTypedJSON(podValueType: string, jsonRawValue: number | string | boolean | null, nameForErrorMessages?: string): PODValue;
/**
 * Parses an integer value into a `bigint` from JSON-compatible value encoding
 * separate from type inforation.  Most use cases should use
 * {@link podValueFromJSON} instead.  This function is intended as a helper
 * for other parsers with their own source of type information.
 *
 * @param numericValue the encoded numeric value, which could be a number, or
 *   a stringified number
 * @param nameForErrorMessages an optional name for this value to be used
 *   in error messages
 * @returns a bigint representing the number
 * @throws TypeError if the input type or value are not validly formed
 * @throws RangeError if a value is outside of the bounds
 * @throws SyntaxError if a value is unparseable
 */
export declare function bigintFromJSON(numericValue: JSONBigInt, nameForErrorMessages?: string): bigint;
/**
 * Converts {@link PODEntries} from the TypeScript format used internally, into
 * a JSON-compatible format safe to serialize with `JSON.stringify`.  This
 * function will produce the simplest of the available encodings which can
 * represent the input with no loss value or type information.
 *
 * @param podEntries the POD entries to convert
 * @returns a JSON-compatible representation
 * @throws TypeError if the input entries are not validly formed
 */
export declare function podEntriesToJSON(podEntries: PODEntries): JSONPODEntries;
/**
 * Converts a {@link PODValue} from the TypeScript format used internally, into
 * a JSON-compatible format safe to serialize with `JSON.stringify`.  This
 * function will produce the simplest of the available encodings which can
 * represent the input with no loss value or type information.
 *
 * @param podValue the POD entries to convert
 * @param nameForErrorMessages an optional name for this value to be used
 *   in error messages
 * @returns a JSON-compatible representation
 * @throws TypeError if the input entries are not validly formed
 */
export declare function podValueToJSON(podValue: PODValue, nameForErrorMessages?: string): JSONPODValue;
/**
 * Converts a bigint to the simplest value-preserving JSON value available.
 * There is no type information included.  The output is always a number
 * (with no fractional part) or a string which can be parsed by `BigInt(s)`.
 *
 * Numbers are used preferentially for values in the range between
 * `Number.MIN_SAFE_INTEGER` and `Number.MAX_SAFE_INTEGER` where no accuracy
 * is lost.  Stringified values may be hex or decimal encoded for minimal size.
 *
 * Note that this function doesn't enforce any bounds on the input.  Any
 * bigint will be encoded, even if it's not a valid POD value.
 *
 * @param n the input integer
 * @returns a number or string representing this integer.
 */
export declare function bigintToSimplestJSON(n: bigint): JSONBigInt;
//# sourceMappingURL=podJSON.d.ts.map