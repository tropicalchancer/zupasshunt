/// <reference types="node" />
import { Point } from "@zk-kit/baby-jubjub";
import { Signature } from "@zk-kit/eddsa-poseidon";
import { BigNumber } from "@zk-kit/utils";
import { PODValue } from "./podTypes";
import { CryptoBytesEncoding } from "./podUtil";
/**
 * Calculates the appropriate hash for a POD value represented as a string or
 * bytes, which could be one of multiple value types (see {@link podValueHash}).
 */
export declare function podBytesHash(input: string | Uint8Array): bigint;
/**
 * Calculates the appropriate hash for a POD value represented as an integer,
 * which could be one of multiple value types (see {@link podValueHash}).
 */
export declare function podIntHash(input: bigint): bigint;
/**
 * Calculates the appropriate hash for a POD value represented as a string-encoded EdDSA public key.
 */
export declare function podEdDSAPublicKeyHash(input: string): bigint;
/**
 * Calculates the appropriate hash for a POD entry name.
 */
export declare function podNameHash(podName: string): bigint;
/**
 * Calculates the appropriate hash for a POD value of any type.
 */
export declare function podValueHash(podValue: PODValue): bigint;
/**
 * The hash function used to generate interior nodes in the Merkle tree
 * representing a POD.  The inputs may be value hashes, or other inner
 * nodes.
 */
export declare function podMerkleTreeHash(left: bigint, right: bigint): bigint;
/**
 * Encodes a private key to a string.  The input must be 32 bytes.  The output
 * is represented as unpadded Base64 by default.
 *
 * @param rawPrivateKey the private key bytes
 * @param encoding one of the supported encodings to use, as per
 *   {@link encodeBytes}.
 * @throws TypeError if the size of the buffer is incorrect.
 */
export declare function encodePrivateKey(rawPrivateKey: Uint8Array, encoding?: CryptoBytesEncoding): string;
/**
 * Decodes a private key's bytes from a string.  The input must be 32 bytes,
 * represented as hex or Base64.  Base64 padding is optional.
 *
 * @param privateKey the private key string to decode
 * @throws TypeError if the private key format is incorrect.
 */
export declare function decodePrivateKey(privateKey: string): Buffer;
/**
 * Encodes an EdDSA public key into a compact string represenation.  The output
 * is 32 bytes, represented as unpadded Base64 by default.
 *
 * @param rawPublicKey the EdDSA public key to encode
 * @param encoding one of the supported encodings to use
 */
export declare function encodePublicKey(rawPublicKey: Point<BigNumber>, encoding?: CryptoBytesEncoding): string;
/**
 * Decodes a public key packed by {@encodePublicKey}.  The input must be
 * 32 bytes, represented as hex or Base64.  Base64 padding is optional.
 *
 * @param publicKey the public key string to decode
 * @throws TypeError if the public key format is incorrect.
 */
export declare function decodePublicKey(publicKey: string): Point<bigint>;
/**
 * Encodes an EdDSA signature into a compact string representation.
 * The output is represented in unpadded Base64 by default.
 *
 * @param rawSignature the EdDSA signature to encode
 * @param encoding one of the supported encodings to use
 */
export declare function encodeSignature(rawSignature: Signature, encoding?: CryptoBytesEncoding): string;
/**
 * Decodes a signature produced by {@link encodeSignature}.  The input must be
 * 64 bytes, represented as hex or Base64.  Base64 padding is optional.
 *
 * @param encodedSignature the signature string to decode
 * @throws TypeError if the signature format is incorrect
 */
export declare function decodeSignature(encodedSignature: string): Signature<bigint>;
/**
 * Calculates the corresponding public key for the given private key.  This is
 * equivalent to the calculation performed in {@link signPODRoot}, and can be
 * used to pre-publish the expected public key to clients before signing.
 *
 * @param privateKey the signer's private key, which is 32 bytes encoded as
 *   per {@link encodePrivateKey}.
 * @returns The signer's public key, which is 32 bytes encoded as per
 *   {@link encodePublicKey}.
 * @throws TypeError if any of the individual arguments is incorrectly formatted
 */
export declare function deriveSignerPublicKey(privateKey: string): string;
/**
 * Signs a POD's root hash.
 *
 * @param root the root hash (content ID) of the POD.
 * @param privateKey the signer's private key, which is 32 bytes encoded as
 *   per {@link encodePrivateKey}.
 * @returns The signature as well as the signer's public key for inclusion
 *   in the POD.  The signature is 64 bytes represented in unpadded Base64.
 * @throws TypeError if any of the individual arguments is incorrectly formatted
 */
export declare function signPODRoot(root: bigint, privateKey: string): {
    signature: string;
    publicKey: string;
};
/**
 * Verifies the signature of a POD root hash.
 *
 * @param root the root hash (content ID) of the POD.
 * @param signature the signature in packed form, which is 64 bytes represented
 *   in hex or Base64.  Base64 padding is optional.
 * @param publicKey the signer's public key in packed form, which is 32 bytes
 *   represented in hex or Base64.  Base64 padding is optional.
 * @returns `true` if the signature is valid
 * @throws TypeError if any of the individual arguments incorrectly formatted
 */
export declare function verifyPODRootSignature(root: bigint, signature: string, publicKey: string): boolean;
//# sourceMappingURL=podCrypto.d.ts.map