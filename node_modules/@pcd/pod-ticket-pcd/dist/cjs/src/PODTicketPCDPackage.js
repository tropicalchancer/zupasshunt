"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PODTicketPCDPackage = exports.getDisplayOptions = exports.ticketDisplayName = exports.deserialize = exports.serialize = exports.verify = exports.prove = exports.ticketToPOD = void 0;
const pod_1 = require("@pcd/pod");
const util_1 = require("@pcd/util");
const uuid_1 = require("uuid");
const PODTicketPCD_1 = require("./PODTicketPCD");
const schema_1 = require("./schema");
const utils_1 = require("./utils");
/**
 * Converts a {@link PODTicketPCD} to a {@link POD}.
 * @param pcd The POD Ticket PCD to convert.
 * @returns The POD.
 */
function ticketToPOD(pcd) {
    return pod_1.POD.load((0, utils_1.dataToPodEntries)(pcd.claim.ticket, schema_1.TicketDataSchema, schema_1.TicketDataSchema.shape), pcd.proof.signature, pcd.claim.signerPublicKey);
}
exports.ticketToPOD = ticketToPOD;
/**
 * Creates a new {@link PODTicketPCD} by generating an {@link PODTicketPCDProof}
 * and deriving an {@link PODTicketPCDClaim} from the given {@link PODTicketPCDArgs}.
 */
async function prove(args) {
    if (!args.privateKey.value) {
        throw new Error("missing private key");
    }
    if (!args.ticket.value) {
        throw new Error("missing ticket value");
    }
    const pod = pod_1.POD.sign((0, utils_1.dataToPodEntries)(args.ticket.value, schema_1.TicketDataSchema, schema_1.TicketDataSchema.shape), args.privateKey.value);
    const id = args.id.value ?? (0, uuid_1.v4)();
    return new PODTicketPCD_1.PODTicketPCD(id, { ticket: args.ticket.value, signerPublicKey: pod.signerPublicKey }, { signature: pod.signature });
}
exports.prove = prove;
/**
 * Verifies a POD Ticket PCD by checking that its {@link PODTicketPCDClaim} corresponds to
 * its {@link PODTicketPCDProof}. If they match, the function returns true, otherwise false.
 * In most cases, verifying the validity of the PCD with this function is not enough.
 * It may also be necessary to ensure that the parameters of the ticket, such as the
 * productId and eventId, match the expected values, and that the public key of the
 * entity that signed the ticket is indeed the authority for that event.
 */
async function verify(pcd) {
    try {
        const loadedPOD = pod_1.POD.load((0, utils_1.dataToPodEntries)(pcd.claim.ticket, schema_1.TicketDataSchema, schema_1.TicketDataSchema.shape), pcd.proof.signature, pcd.claim.signerPublicKey);
        return (loadedPOD.signature === pcd.proof.signature && loadedPOD.verifySignature());
    }
    catch (e) {
        console.error("Verifying invalid POD data:", e);
        return false;
    }
}
exports.verify = verify;
/**
 * Serializes a {@link PODTicketPCD}.
 * @param pcd The POD Ticket PCD to be serialized.
 * @returns The serialized version of the POD Ticket PCD.
 */
async function serialize(pcd) {
    return {
        type: PODTicketPCD_1.PODTicketPCDTypeName,
        pcd: JSON.stringify({
            id: pcd.id,
            claim: pcd.claim,
            proof: pcd.proof
        })
    };
}
exports.serialize = serialize;
/**
 * Deserializes a serialized {@link PODTicketPCD}.
 * @param serialized The serialized PCD to deserialize.
 * @returns The deserialized version of the POD Ticket PCD.
 */
async function deserialize(serialized) {
    const deserialized = JSON.parse(serialized);
    (0, util_1.requireDefinedParameter)(deserialized.id, "id");
    (0, util_1.requireDefinedParameter)(deserialized.claim, "claim");
    (0, util_1.requireDefinedParameter)(deserialized.claim.ticket, "ticket");
    (0, util_1.requireDefinedParameter)(deserialized.claim.signerPublicKey, "signerPublicKey");
    (0, util_1.requireDefinedParameter)(deserialized.proof, "proof");
    (0, util_1.requireDefinedParameter)(deserialized.proof.signature, "signature");
    schema_1.TicketDataSchema.parse(deserialized.claim.ticket);
    return new PODTicketPCD_1.PODTicketPCD(deserialized.id, deserialized.claim, deserialized.proof);
}
exports.deserialize = deserialize;
function ticketDisplayName(eventName, ticketName) {
    let displayName = "";
    if (eventName && eventName?.length > 0) {
        displayName += eventName;
    }
    if (ticketName && ticketName?.length > 0) {
        if (displayName.length === 0) {
            displayName = ticketName;
        }
        else {
            displayName += ` (${ticketName})`;
        }
    }
    return displayName.length === 0 ? "untitled" : displayName;
}
exports.ticketDisplayName = ticketDisplayName;
/**
 * Provides the information about the {@link PODTicketPCD} that will be displayed
 * to users on Zupass.
 * @param pcd The POD Ticket PCD instance.
 * @returns The information to be displayed, specifically `header` and `displayName`.
 */
function getDisplayOptions(pcd) {
    const ticketData = pcd.claim.ticket;
    if (!ticketData) {
        return {
            header: "Ticket",
            displayName: "ticket-" + pcd.id.substring(0, 4)
        };
    }
    const displayName = ticketDisplayName(ticketData.eventName, ticketData.ticketName);
    let header = displayName;
    if (ticketData.isRevoked) {
        header = `[CANCELED] ${displayName}`;
    }
    else if (ticketData.isConsumed) {
        header = `[SCANNED] ${displayName}`;
    }
    return {
        header,
        displayName
    };
}
exports.getDisplayOptions = getDisplayOptions;
/**
 * The PCD package of the POD Ticket PCD. It exports an object containing
 * the code necessary to operate on this PCD data.
 */
exports.PODTicketPCDPackage = {
    name: PODTicketPCD_1.PODTicketPCDTypeName,
    getDisplayOptions,
    prove,
    verify,
    serialize,
    deserialize
};
