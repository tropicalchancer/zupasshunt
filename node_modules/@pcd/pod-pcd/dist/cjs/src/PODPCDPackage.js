"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PODPCDPackage = exports.getDisplayOptions = exports.deserialize = exports.serialize = exports.verify = exports.prove = void 0;
const pod_1 = require("@pcd/pod");
const util_1 = require("@pcd/util");
const json_bigint_1 = __importDefault(require("json-bigint"));
const uuid_1 = require("uuid");
const PODPCD_1 = require("./PODPCD");
const utils_1 = require("./utils");
/**
 * Creates a new {@link PODPCD} by generating an {@link PODPCDProof}
 * and deriving an {@link PODPCDClaim} from the given {@link PODPCDArgs}.
 *
 * @throws if the arguments are invalid
 */
async function prove(args) {
    if (!args.privateKey.value)
        throw new Error("No private key value provided");
    if (!args.entries.value)
        throw new Error("No POD entries value provided");
    const id = typeof args.id.value === "string" ? args.id.value : (0, uuid_1.v4)();
    const pod = pod_1.POD.sign((0, pod_1.podEntriesFromJSON)(args.entries.value), args.privateKey.value);
    return new PODPCD_1.PODPCD(id, pod);
}
exports.prove = prove;
/**
 * Verifies a POD PCD by checking that its {@link PODPCDClaim} corresponds to
 * its {@link PODPCDProof}.  If the signature is valid and matches the entries,
 * the function returns true, otherwise false.
 */
async function verify(pcd) {
    return pcd.pod.verifySignature();
}
exports.verify = verify;
/**
 * Serializes a {@link PODPCD}.
 * @param pcd The POD PCD to be serialized.
 * @returns The serialized version of the POD PCD.
 */
async function serialize(pcd) {
    return {
        type: PODPCD_1.PODPCDTypeName,
        pcd: JSON.stringify({
            id: pcd.id,
            jsonPOD: pcd.pod.toJSON()
        })
    };
}
exports.serialize = serialize;
/**
 * Deserializes a serialized {@link PODPCD}.
 * @param serialized The serialized PCD to deserialize.
 * @returns The deserialized version of the POD PCD.
 */
async function deserialize(serialized) {
    try {
        const deserialized = JSON.parse(serialized);
        (0, pod_1.requireType)("id", deserialized.id, "string");
        (0, pod_1.requireType)("jsonPOD", deserialized.jsonPOD, "object");
        const pod = pod_1.POD.fromJSON(deserialized.jsonPOD);
        return new PODPCD_1.PODPCD(deserialized.id, pod);
    }
    catch (jsonError) {
        // Try the old legacy JSONBigint format for backward compatibility.
        // Its JSON(ish) structure contained `id`, `claim`, and `proof` so
        // isn't mistakable for the new format with `jsonPOD` used above.
        try {
            return deserializeLegacyJSONBigint(serialized);
        }
        catch (legacyError) {
            // Old format didn't work either, so throw the original exception.
            throw jsonError;
        }
    }
}
exports.deserialize = deserialize;
async function deserializeLegacyJSONBigint(serialized) {
    // Legacy format which predates JSON encoding used json-bigint to directly
    // serialize PODEntries.  This was eliminated due to lack of composability,
    // but there are Zupass users who already had PODs which they may need to
    // load.  They'll get upgraded when they re-serialize, but we can't ever
    // guarantee they're all gone since long-idle users might return.
    const deserialized = (0, json_bigint_1.default)({
        useNativeBigInt: true,
        alwaysParseAsBig: true
    }).parse(serialized);
    (0, util_1.requireDefinedParameter)(deserialized.id, "id");
    (0, util_1.requireDefinedParameter)(deserialized.claim, "claim");
    (0, util_1.requireDefinedParameter)(deserialized.claim.entries, "entries");
    (0, util_1.requireDefinedParameter)(deserialized.claim.signerPublicKey, "signerPublicKey");
    (0, util_1.requireDefinedParameter)(deserialized.proof, "proof");
    (0, util_1.requireDefinedParameter)(deserialized.proof.signature, "signature");
    const loadedPOD = pod_1.POD.load(deserialized.claim.entries, deserialized.proof.signature, deserialized.claim.signerPublicKey);
    return new PODPCD_1.PODPCD(deserialized.id, loadedPOD);
}
/**
 * Provides the information about the {@link PODPCD} that will be displayed
 * to users on Zupass.
 * @param pcd The POD PCD instance.
 * @returns The information to be displayed, specifically `header` and `displayName`.
 */
function getDisplayOptions(
// TODO(ichub): Figure out why this is the only case where using PODPCD directly doesn't work.
// What's the right approach to PCD classes which want extra private or public
// data outside of claim + proof?
pcd) {
    const titleEntry = (0, utils_1.getTitleEntry)(pcd);
    if (titleEntry?.type === "string" && titleEntry.value.length > 0) {
        return {
            header: titleEntry.value,
            displayName: "pod-" + titleEntry.value
        };
    }
    return {
        header: "POD",
        displayName: "pod-" + pcd.id
    };
}
exports.getDisplayOptions = getDisplayOptions;
/**
 * The PCD package of the POD PCD. It exports an object containing
 * the code necessary to operate on this PCD data.
 */
exports.PODPCDPackage = {
    name: PODPCD_1.PODPCDTypeName,
    getDisplayOptions,
    prove,
    verify,
    serialize,
    deserialize
};
