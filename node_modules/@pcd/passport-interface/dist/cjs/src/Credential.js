"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyCredential = exports.VerificationError = exports.createCredentialPayload = void 0;
const email_pcd_1 = require("@pcd/email-pcd");
const semaphore_signature_pcd_1 = require("@pcd/semaphore-signature-pcd");
const util_1 = require("@pcd/util");
// Timestamps last for one hour and 20 minutes
// Compare to CACHE_TTL in CredentialManager.ts, which is one hour, meaning
// that client-side cached credentials will be refreshed before they expire
const TIMESTAMP_MAX_AGE = util_1.ONE_HOUR_MS + 20 * util_1.ONE_MINUTE_MS;
/**
 * Creates a feed credential payload with timestamp.
 */
function createCredentialPayload(pcds = undefined) {
    return {
        pcds: pcds instanceof Array ? pcds : pcds !== undefined ? [pcds] : undefined,
        timestamp: Date.now()
    };
}
exports.createCredentialPayload = createCredentialPayload;
/**
 * Validates a credential timestamp.
 */
function validateCredentialTimestamp(timestamp) {
    const now = Date.now();
    return now - timestamp < TIMESTAMP_MAX_AGE;
}
class VerificationError extends Error {
}
exports.VerificationError = VerificationError;
/*
 * Verifies that a credential has a valid Semaphore signature and a non-expired
 * timestamp.
 *
 * If the credential payload contains a serialized EmailPCD, also verifies it
 * and checks that the Semaphore identity in the EmailPCD's claim matches that
 * of the signature.
 *
 * This function only proves that the credential is formally valid. It does
 * *not* check if the EmailPCD was signed by Zupass. In both IssuanceService
 * and in CredentialSubservice (part of Podbox), this additional check is
 * performed, because those servies have higher context on what might be a
 * valid signing key (e.g. one specified in an environment variable, which
 * application code has access to but library code such as this does not).
 */
async function verifyCredential(credential) {
    if (credential.type !== semaphore_signature_pcd_1.SemaphoreSignaturePCDPackage.name) {
        throw new VerificationError(`Credential is not a Semaphore Signature PCD`);
    }
    // Ensure that the signature part of the credential verifies.
    const pcd = await semaphore_signature_pcd_1.SemaphoreSignaturePCDPackage.deserialize(credential.pcd);
    if (!(await semaphore_signature_pcd_1.SemaphoreSignaturePCDPackage.verify(pcd))) {
        throw new VerificationError(`Could not verify signature PCD`);
    }
    // Parse data from the Semaphore Signature claim. Will throw if the message
    // is not valid JSON.
    const payload = JSON.parse(pcd.claim.signedMessage);
    // The payload should have a timestamp, which should also be a number within
    // certain bounds.
    if (!validateCredentialTimestamp(payload.timestamp)) {
        throw new VerificationError("Credential timestamp out of bounds");
    }
    const emailPCDs = (payload.pcd ? [payload.pcd] : payload.pcds) ?? [];
    // If the payload contains a PCD, verify it
    if (emailPCDs) {
        // Only EmailPCD is supported here
        if (emailPCDs.find((e) => e.type !== email_pcd_1.EmailPCDPackage.name)) {
            throw new VerificationError(`all pcds in the payload must be email PCDs`);
        }
        const signedEmails = await Promise.all(emailPCDs.map(async (e) => {
            // EmailPCD must verify
            const emailPCD = await email_pcd_1.EmailPCDPackage.deserialize(e.pcd);
            if (!(await email_pcd_1.EmailPCDPackage.verify(emailPCD))) {
                throw new VerificationError(`Could not verify email PCD`);
            }
            // EmailPCD contains a Semaphore ID in its claim, which must match that of
            // the signature.
            if (emailPCD.claim.semaphoreId !== pcd.claim.identityCommitment) {
                throw new VerificationError(`Email PCD and Signature PCD do not have matching identities`);
            }
            return {
                email: emailPCD.claim.emailAddress,
                signer: emailPCD.proof.eddsaPCD.claim.publicKey,
                semaphoreId: emailPCD.claim.semaphoreId,
                semaphoreV4Id: emailPCD.claim.semaphoreV4Id
            };
        }));
        // a bit hacky
        const semaphoreV4Id = signedEmails.find((e) => e.semaphoreV4Id)
            ?.semaphoreV4Id;
        // Everything passes, return the verified credential with email claims
        return {
            emails: signedEmails,
            semaphoreId: pcd.claim.identityCommitment,
            semaphoreV4Id
        };
    }
    else {
        // Return a verified credential, without email claims since no EmailPCD
        // was present
        return { semaphoreId: pcd.claim.identityCommitment };
    }
}
exports.verifyCredential = verifyCredential;
