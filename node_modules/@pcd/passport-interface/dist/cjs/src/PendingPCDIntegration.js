"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.usePCDMultiplexer = exports.usePendingPCD = void 0;
const react_1 = require("react");
const PendingPCDUtils_1 = require("./PendingPCDUtils");
const requestServerProofStatus_1 = require("./api/requestServerProofStatus");
/**
 * React hook that pings server on status of a PendingPCD. Returns a serialized
 * PCD when a completed PCD is returned, or the current status.
 */
function usePendingPCD(pendingPCDStr, zupassServerUrl) {
    const [pendingPCDStatus, setPendingPCDStatus] = (0, react_1.useState)(PendingPCDUtils_1.PendingPCDStatus.NONE);
    const [pendingPCDError, setPendingPCDError] = (0, react_1.useState)("");
    const [pcdStr, setPCDStr] = (0, react_1.useState)("");
    (0, react_1.useEffect)(() => {
        let interval = undefined;
        const getProofStatus = async () => {
            if (pendingPCDStr !== undefined && pendingPCDStr !== "") {
                const pendingPCD = JSON.parse(pendingPCDStr);
                const proofStatusResult = await (0, requestServerProofStatus_1.requestServerProofStatus)(zupassServerUrl, {
                    hash: pendingPCD.hash
                });
                if (!proofStatusResult.success) {
                    setPendingPCDStatus(PendingPCDUtils_1.PendingPCDStatus.ERROR);
                    setPendingPCDError(proofStatusResult.error);
                    clearInterval(interval);
                    return;
                }
                setPendingPCDStatus(proofStatusResult.value.status);
                if (proofStatusResult.value.status === PendingPCDUtils_1.PendingPCDStatus.COMPLETE &&
                    proofStatusResult.value.serializedPCD !== undefined) {
                    setPCDStr(proofStatusResult.value.serializedPCD);
                    setPendingPCDError("");
                    clearInterval(interval);
                }
                else if (proofStatusResult.value.status === PendingPCDUtils_1.PendingPCDStatus.ERROR &&
                    proofStatusResult.value.error !== undefined) {
                    setPendingPCDError(proofStatusResult.value.error);
                    clearInterval(interval);
                }
            }
        };
        interval = setInterval(getProofStatus, 1000);
        return () => clearInterval(interval);
    }, [pendingPCDStr, zupassServerUrl]);
    return [pendingPCDStatus, pendingPCDError, pcdStr];
}
exports.usePendingPCD = usePendingPCD;
/**
 * Multiplexer hook to choose between client-side and server-side PCDs.
 */
function usePCDMultiplexer(zupassPCDStr, serverPCDStr) {
    const [pcdStr, setPCDStr] = (0, react_1.useState)("");
    (0, react_1.useEffect)(() => {
        console.log(zupassPCDStr);
        if (zupassPCDStr) {
            setPCDStr(zupassPCDStr);
        }
        else if (serverPCDStr) {
            setPCDStr(serverPCDStr);
        }
    }, [zupassPCDStr, serverPCDStr]);
    return pcdStr;
}
exports.usePCDMultiplexer = usePCDMultiplexer;
