"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FrogCryptoFolderName = exports.FrogCryptoFrogDataSchema = exports.FrogCryptoDbFeedDataSchema = exports.IFrogCryptoClientFeedSchema = exports.IFrogCryptoFeedSchema = exports.FrogCryptoFeedBiomeConfigsSchema = exports.FrogCryptoFeedBiomeConfigSchema = exports.FROG_SCORE_CAP = exports.FROG_FREEROLLS = void 0;
const eddsa_frog_pcd_1 = require("@pcd/eddsa-frog-pcd");
const lodash_1 = __importDefault(require("lodash"));
const zod_1 = require("zod");
/**
 * Number of free rolls that a user globally
 *
 * User's lastFetchedAt is set to 0 if their score is less than this value
 */
exports.FROG_FREEROLLS = 2;
/**
 * The maximum score that a user can have
 *
 * Once a user reaches this score, they will no longer be able to earn more PCDs from this feed
 */
exports.FROG_SCORE_CAP = 10000;
/**
 * Map of configs for Biome(s) where PCDs can be issued from this feed
 */
exports.FrogCryptoFeedBiomeConfigSchema = zod_1.z.object({
    /**
     * A scaling factor that is multiplied to the weight of the frog to affect
     * the probability of the frog being issued
     *
     * For example, if a feed has 3 frogs:
     *
     * * JungleFrog1's drop weight is 1
     * * JungleFrog2's drop weight is 2
     * * DesertFrog3's drop weight is 3
     *
     *  If the Jungle's dropWeightScaler is 2 and the Desert's
     *   dropWeightScaler is 1, then
     *
     * * JungleFrog1's probability of being issued is 2/9
     * * JungleFrog2's probability of being issued is 4/9
     * * DesertFrog3's probability of being issued is 3/9
     */
    dropWeightScaler: zod_1.z.number().nonnegative()
});
exports.FrogCryptoFeedBiomeConfigsSchema = zod_1.z.object(lodash_1.default.mapValues(eddsa_frog_pcd_1.Biome, () => exports.FrogCryptoFeedBiomeConfigSchema.optional()));
/**
 * Schema for FrogCrypto specific feed interface
 */
exports.IFrogCryptoFeedSchema = zod_1.z.object({
    /**
     * Whether this feed is discoverable in GET /feeds
     *
     * A feed can still be queried as GET /feeds/:feedId or polled as POST /feeds even if it is not discoverable
     * as long as the user knows the feed ID.
     * @default false
     */
    private: zod_1.z.boolean(),
    /**
     * Unix timestamp in seconds of when this feed will become inactive
     *
     * PCD can only be issued from this feed if it is active
     * @default 0 means the feed is inactive
     */
    activeUntil: zod_1.z.number().nonnegative().int(),
    /**
     * How long to wait between each PCD issuance in seconds
     */
    cooldown: zod_1.z.number().nonnegative().int(),
    /**
     * Map of configs for Biome(s) where PCDs can be issued from this feed
     */
    biomes: exports.FrogCryptoFeedBiomeConfigsSchema,
    /**
     * A list of secret codes that can be used to look up this feed
     */
    codes: zod_1.z.array(zod_1.z.string()).optional()
});
/**
 * A subset of `IFrogCryptoFeed` that is exposed to the client
 */
exports.IFrogCryptoClientFeedSchema = zod_1.z.object({
    private: exports.IFrogCryptoFeedSchema.shape.private,
    activeUntil: exports.IFrogCryptoFeedSchema.shape.activeUntil,
    cooldown: exports.IFrogCryptoFeedSchema.shape.cooldown
});
/**
 * DB schema for feed data
 */
exports.FrogCryptoDbFeedDataSchema = zod_1.z.object({
    uuid: zod_1.z.string().uuid(),
    feed: zod_1.z.object({
        name: zod_1.z.string().min(1),
        description: zod_1.z.string().min(1),
        private: zod_1.z.boolean(),
        activeUntil: zod_1.z.number().nonnegative().int(),
        cooldown: zod_1.z.number().nonnegative().int(),
        biomes: exports.FrogCryptoFeedBiomeConfigsSchema,
        codes: zod_1.z.array(zod_1.z.string()).optional()
    })
});
/**
 * The prototype specification for frog creation
 *
 * This represents the raw specification of a frog, which is then used to generate the {@link IFrogData} in the {@link EdDSAFrogPCD}. Some attributes are optional and will be randomly selected if not specified.
 * This mirrors the specification from the design spreadsheet and is wrapped as {@link FrogCryptoDbFrogData} to store in the database.
 * See {@link FrogCryptoFeed} for the feed configuration and how Frog prototypes are selected.
 *
 * Undefined numeric attribute means that the value will be randomly selected from [0, 10].
 */
exports.FrogCryptoFrogDataSchema = zod_1.z.object({
    id: zod_1.z.number().nonnegative().int(),
    uuid: zod_1.z.string().uuid(),
    name: zod_1.z.string().min(1),
    description: zod_1.z.string().min(1),
    biome: zod_1.z.string().min(1),
    rarity: zod_1.z.string().min(1),
    /**
     * undefined means the temperament will be randomly selected
     */
    temperament: zod_1.z.string().optional(),
    drop_weight: zod_1.z.number().nonnegative(),
    jump_min: zod_1.z.number().gte(0).lte(15).optional(),
    jump_max: zod_1.z.number().gte(0).lte(15).optional(),
    speed_min: zod_1.z.number().gte(0).lte(15).optional(),
    speed_max: zod_1.z.number().gte(0).lte(15).optional(),
    intelligence_min: zod_1.z.number().gte(0).lte(15).optional(),
    intelligence_max: zod_1.z.number().gte(0).lte(15).optional(),
    beauty_min: zod_1.z.number().gte(0).lte(15).optional(),
    beauty_max: zod_1.z.number().gte(0).lte(15).optional()
});
/**
 * All FrogCrypto PCDs are stored in a folder named "FrogCrypto".
 */
exports.FrogCryptoFolderName = "FrogCrypto";
