"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyAddV4CommitmentRequestPCD = exports.makeUpgradeUserWithV4CommitmentRequest = exports.requestUpgradeUserWithV4Commitment = void 0;
const pcd_types_1 = require("@pcd/pcd-types");
const pod_1 = require("@pcd/pod");
const pod_pcd_1 = require("@pcd/pod-pcd");
const semaphore_identity_pcd_1 = require("@pcd/semaphore-identity-pcd");
const semaphore_signature_pcd_1 = require("@pcd/semaphore-signature-pcd");
const util_1 = require("@pcd/util");
const url_join_1 = __importDefault(require("url-join"));
const makeRequest_1 = require("./makeRequest");
/**
 * Asks the Zupass server to add a semaphore v4 commitment to the user's account, given
 * they already have an account with just a v3 identity.
 *
 * Idempotent.
 *
 * @see {@link makeUpgradeUserWithV4CommitmentRequest} for details regarding what this request contains.
 *
 * Never rejects. All information encoded in the resolved response.
 */
async function requestUpgradeUserWithV4Commitment(zupassServerUrl, req) {
    return (0, makeRequest_1.httpPostSimple)((0, url_join_1.default)(zupassServerUrl, "/account/upgrade-with-v4-commitment"), async () => ({
        value: undefined,
        success: true
    }), req);
}
exports.requestUpgradeUserWithV4Commitment = requestUpgradeUserWithV4Commitment;
/**
 * @returns a v3 signature of a v4 signature of the identity commitment of the identity that
 * was used to create the outermost v3 signature. Expects that both a v3 and v4 identity PCD
 * exist in the collection. This proves that the creator of this request 'owns' both identities.
 */
async function makeUpgradeUserWithV4CommitmentRequest(pcdCollection) {
    const identity = pcdCollection.getPCDsByType(semaphore_identity_pcd_1.SemaphoreIdentityPCDPackage.name)[0];
    if (!identity) {
        throw new Error("Expected a semaphore identity to be present in the PCD collection");
    }
    const v4SigOfV3Claim = await pod_pcd_1.PODPCDPackage.prove({
        entries: {
            argumentType: pcd_types_1.ArgumentTypeName.Object,
            value: (0, pod_1.podEntriesToJSON)({
                mySemaphoreV3Commitment: {
                    type: "cryptographic",
                    value: identity.claim.identityV3.commitment
                },
                pod_type: {
                    type: "string",
                    value: "zupass.semaphore_v4_migration"
                }
            })
        },
        privateKey: {
            argumentType: pcd_types_1.ArgumentTypeName.String,
            value: (0, semaphore_identity_pcd_1.v4PrivateKey)(identity.claim.identityV4)
        },
        id: {
            argumentType: pcd_types_1.ArgumentTypeName.String,
            value: (0, util_1.randomUUID)()
        }
    });
    const v3SigOfV4Sig = await semaphore_signature_pcd_1.SemaphoreSignaturePCDPackage.prove({
        identity: {
            argumentType: pcd_types_1.ArgumentTypeName.PCD,
            value: await semaphore_identity_pcd_1.SemaphoreIdentityPCDPackage.serialize(identity)
        },
        signedMessage: {
            argumentType: pcd_types_1.ArgumentTypeName.String,
            value: JSON.stringify(await pod_pcd_1.PODPCDPackage.serialize(v4SigOfV3Claim))
        }
    });
    return {
        pcd: await semaphore_signature_pcd_1.SemaphoreSignaturePCDPackage.serialize(v3SigOfV4Sig)
    };
}
exports.makeUpgradeUserWithV4CommitmentRequest = makeUpgradeUserWithV4CommitmentRequest;
/**
 * @param sig created by {@link makeUpgradeUserWithV4CommitmentRequest}. This function verifies that it
 * is a valid v3 signature of a valid v4 signature of the identity that was used to create
 * the outermost v3 signature.
 */
async function verifyAddV4CommitmentRequestPCD(sig) {
    try {
        const v3SigVerifies = await semaphore_signature_pcd_1.SemaphoreSignaturePCDPackage.verify(sig);
        const expectedV3Id = BigInt(sig.claim.identityCommitment);
        const v4SigOfV3Id = await pod_pcd_1.PODPCDPackage.deserialize(JSON.parse(sig.claim.signedMessage).pcd);
        const v4SigVerifies = await pod_pcd_1.PODPCDPackage.verify(v4SigOfV3Id);
        const v4Message = v4SigOfV3Id.claim.entries["mySemaphoreV3Commitment"];
        const v4SigIsOfV3Id = v4Message.type === "cryptographic" && v4Message.value === expectedV3Id;
        const isRightPodType = v4SigOfV3Id.claim.entries["pod_type"]?.type === "string" &&
            v4SigOfV3Id.claim.entries["pod_type"].value ===
                "zupass.semaphore_v4_migration";
        if (v3SigVerifies && v4SigVerifies && v4SigIsOfV3Id && isRightPodType) {
            return {
                v3Commitment: expectedV3Id.toString(),
                v4PublicKey: v4SigOfV3Id.claim.signerPublicKey,
                v4Commitment: (0, semaphore_identity_pcd_1.v4PublicKeyToCommitment)(v4SigOfV3Id.claim.signerPublicKey)
            };
        }
        return undefined;
    }
    catch (e) {
        return undefined;
    }
}
exports.verifyAddV4CommitmentRequestPCD = verifyAddV4CommitmentRequestPCD;
