"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapStringError = exports.httpDeleteSimple = exports.httpPutSimple = exports.httpPostSimple = exports.httpGetSimple = exports.httpDelete = exports.httpPut = exports.httpPost = exports.httpGet = void 0;
const util_1 = require("@pcd/util");
const url_join_1 = __importDefault(require("url-join"));
const constants_1 = require("./constants");
/**
 * Wrapper of {@link httpRequest} that sends a GET request.
 */
async function httpGet(url, opts, query, includeCredentials = false) {
    return httpRequest((0, url_join_1.default)(url, "?" + new URLSearchParams(query ?? {})), opts, includeCredentials);
}
exports.httpGet = httpGet;
/**
 * Wrapper of {@link httpRequest} that sends a POST request.
 */
async function httpPost(url, opts, postBody, includeCredentials = false) {
    return httpRequest(url, opts, includeCredentials, "POST", postBody);
}
exports.httpPost = httpPost;
/**
 * Wrapper of {@link httpRequest} that sends a PUT request.
 */
async function httpPut(url, opts, putBody, includeCredentials = false) {
    return httpRequest(url, opts, includeCredentials, "PUT", putBody);
}
exports.httpPut = httpPut;
/**
 * Wrapper of {@link httpRequest} that sends a DE:ETE request.
 */
async function httpDelete(url, opts, includeCredentials = false) {
    return httpRequest((0, url_join_1.default)(url), opts, includeCredentials, "DELETE");
}
exports.httpDelete = httpDelete;
/**
 * Shorthand for a {@link httpGet} whose error type is a string.
 */
async function httpGetSimple(url, onValue, query, includeCredentials = false) {
    return httpGet(url, {
        onValue,
        onError: async (resText, code) => ({
            error: resText,
            success: false,
            code
        })
    }, query, includeCredentials);
}
exports.httpGetSimple = httpGetSimple;
/**
 * Shorthand for a {@link httpPost} whose error type is a string.
 */
async function httpPostSimple(url, onValue, postBody, includeCredentials = false) {
    return httpPost(url, {
        onValue,
        onError: async (resText, code) => ({
            error: resText,
            success: false,
            code
        })
    }, postBody, includeCredentials);
}
exports.httpPostSimple = httpPostSimple;
/**
 * Shorthand for a {@link httpPut} whose error type is a string.
 */
async function httpPutSimple(url, onValue, putBody, includeCredentials = false) {
    return httpPut(url, {
        onValue,
        onError: async (resText, code) => ({
            error: resText,
            success: false,
            code
        })
    }, putBody, includeCredentials);
}
exports.httpPutSimple = httpPutSimple;
/**
 * Shorthand for a {@link httpDelete} whose error type is a string.
 */
async function httpDeleteSimple(url, onValue, includeCredentials = false) {
    return httpDelete(url, {
        onValue,
        onError: async (resText, code) => ({
            error: resText,
            success: false,
            code
        })
    }, includeCredentials);
}
exports.httpDeleteSimple = httpDeleteSimple;
/**
 * DEVELOPMENT ONLY!
 *
 * Set this to a value like 5000 to delay all http requests by 5 seconds.
 * Useful for testing intermediate loading states in the Zupass application.
 */
const throttleMs = 0;
/**
 * Sends a non-blocking HTTP request to the given URL, either a POST
 * or a GET, with the given body, and converts it into a {@link APIResult}.
 *
 * Never rejects.
 */
async function httpRequest(url, opts, includeCredentials, method, requestBody) {
    await (0, util_1.sleep)(throttleMs);
    let requestOptions = {
        method: "GET"
    };
    if (includeCredentials) {
        requestOptions = {
            ...requestOptions,
            credentials: "include"
        };
    }
    if (requestBody) {
        requestOptions = {
            ...requestOptions,
            ...constants_1.POST,
            body: JSON.stringify(requestBody)
        };
    }
    if (method) {
        requestOptions = { ...requestOptions, method };
    }
    try {
        const res = await fetch(url, requestOptions);
        const resText = await res.text();
        if (!res.ok) {
            return await opts.onError(resText, res.status);
        }
        return await opts.onValue(resText);
    }
    catch (e) {
        // eslint-disable-next-line no-useless-catch
        try {
            return await opts.onError((0, util_1.getErrorMessage)(e), undefined);
        }
        catch (e) {
            throw e;
        }
    }
}
async function mapStringError(resText) {
    return { error: resText, success: false };
}
exports.mapStringError = mapStringError;
