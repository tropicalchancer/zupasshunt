"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getStorageHash = exports.serializeStorage = exports.deserializeStorage = exports.isSyncedEncryptedStorageV5 = exports.isSyncedEncryptedStorageV4 = exports.isSyncedEncryptedStorageV3 = exports.isSyncedEncryptedStorageV2 = exports.isSyncedEncryptedStorageV1 = void 0;
const passport_crypto_1 = require("@pcd/passport-crypto");
const pcd_collection_1 = require("@pcd/pcd-collection");
const fast_json_stable_stringify_1 = __importDefault(require("fast-json-stable-stringify"));
const FeedAPI_1 = require("./FeedAPI");
const SubscriptionManager_1 = require("./SubscriptionManager");
function isSyncedEncryptedStorageV1(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
storage) {
    return storage._storage_version === undefined;
}
exports.isSyncedEncryptedStorageV1 = isSyncedEncryptedStorageV1;
function isSyncedEncryptedStorageV2(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
storage) {
    return storage._storage_version === "v2";
}
exports.isSyncedEncryptedStorageV2 = isSyncedEncryptedStorageV2;
function isSyncedEncryptedStorageV3(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
storage) {
    return storage._storage_version === "v3";
}
exports.isSyncedEncryptedStorageV3 = isSyncedEncryptedStorageV3;
function isSyncedEncryptedStorageV4(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
storage) {
    return storage._storage_version === "v4";
}
exports.isSyncedEncryptedStorageV4 = isSyncedEncryptedStorageV4;
function isSyncedEncryptedStorageV5(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
storage) {
    return storage._storage_version === "v5";
}
exports.isSyncedEncryptedStorageV5 = isSyncedEncryptedStorageV5;
/**
 * Deserialize a decrypted storage object and set up the PCDCollection and
 * FeedSubscriptionManager to manage its data.  If the storage comes from
 * an older format which doesn't include subscriptions, then the
 * FeedSubscriptionManager will be empty.
 */
async function deserializeStorage(storage, pcdPackages, fallbackDeserializeFunction) {
    let pcds;
    let subscriptions;
    if (isSyncedEncryptedStorageV5(storage)) {
        pcds = await pcd_collection_1.PCDCollection.deserialize(pcdPackages, storage.pcds, {
            fallbackDeserializeFunction
        });
        subscriptions = SubscriptionManager_1.FeedSubscriptionManager.deserialize(new FeedAPI_1.NetworkFeedApi(), storage.subscriptions);
    }
    else if (isSyncedEncryptedStorageV4(storage)) {
        pcds = await pcd_collection_1.PCDCollection.deserialize(pcdPackages, storage.pcds, {
            fallbackDeserializeFunction
        });
        subscriptions = SubscriptionManager_1.FeedSubscriptionManager.deserialize(new FeedAPI_1.NetworkFeedApi(), storage.subscriptions);
    }
    else if (isSyncedEncryptedStorageV3(storage)) {
        pcds = await pcd_collection_1.PCDCollection.deserialize(pcdPackages, storage.pcds, {
            fallbackDeserializeFunction
        });
        subscriptions = SubscriptionManager_1.FeedSubscriptionManager.deserialize(new FeedAPI_1.NetworkFeedApi(), storage.subscriptions);
    }
    else if (isSyncedEncryptedStorageV2(storage)) {
        pcds = await pcd_collection_1.PCDCollection.deserialize(pcdPackages, storage.pcds, {
            fallbackDeserializeFunction
        });
        subscriptions = new SubscriptionManager_1.FeedSubscriptionManager(new FeedAPI_1.NetworkFeedApi());
    }
    else if (isSyncedEncryptedStorageV1(storage)) {
        pcds = new pcd_collection_1.PCDCollection(pcdPackages);
        await pcds.deserializeAllAndAdd(storage.pcds, {
            fallbackDeserializeFunction
        });
        subscriptions = new SubscriptionManager_1.FeedSubscriptionManager(new FeedAPI_1.NetworkFeedApi());
    }
    else {
        throw new Error(`Unknown SyncedEncryptedStorage version 
      ${storage["_storage_version"]}`);
    }
    return {
        pcds,
        subscriptions,
        storageHash: await getStorageHash(storage)
    };
}
exports.deserializeStorage = deserializeStorage;
/**
 * Serializes a user's PCDs and relates state for storage.  The result is
 * unencrypted, and always uses the latest format.  The hash uniquely identifies
 * the content, as described in getStorageHash.
 */
async function serializeStorage(user, pcds, subscriptions) {
    const serializedStorage = {
        pcds: await pcds.serializeCollection(),
        self: user,
        subscriptions: subscriptions.serialize(),
        _storage_version: "v4"
    };
    return {
        serializedStorage: serializedStorage,
        storageHash: await getStorageHash(serializedStorage)
    };
}
exports.serializeStorage = serializeStorage;
/**
 * Calculates a hash to uniquely identify the given seralized storage.
 */
async function getStorageHash(storage) {
    return await (0, passport_crypto_1.getHash)((0, fast_json_stable_stringify_1.default)(storage));
}
exports.getStorageHash = getStorageHash;
