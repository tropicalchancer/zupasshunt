"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PipelineDefinitionSchema = exports.isCSVTicketPipelineDefinition = exports.isPODPipelineDefinition = exports.PODPipelineDefinitionSchema = exports.validatePODPipelineOptions = exports.PODPipelineOutputMatchSchema = exports.PODPipelinePCDTypes = exports.PODPipelineInputFieldType = exports.PODPipelineInputType = exports.isCSVPipelineDefinition = exports.CSVPipelineOutputType = exports.isPretixPipelineDefinition = exports.UserPermissionsOptionsSchema = exports.AutoIssuanceOptionsSchema = exports.isLemonadePipelineDefinition = exports.ContactsConfigSchema = exports.BadgesConfigSchema = exports.BadgeConfigSchema = exports.ActionScreenConfigSchema = exports.MemberCriteriaSchema = exports.IncidentPolicy = exports.PipelineType = void 0;
const util_1 = require("@pcd/util");
const zod_1 = require("zod");
/**
 * Each new {@link Pipeline} type needs a corresponding entry in thie enum.
 */
var PipelineType;
(function (PipelineType) {
    PipelineType["Lemonade"] = "Lemonade";
    PipelineType["Pretix"] = "Pretix";
    PipelineType["CSV"] = "CSV";
    PipelineType["POD"] = "POD";
    PipelineType["CSVTicket"] = "CSVTicket";
})(PipelineType || (exports.PipelineType = PipelineType = {}));
var IncidentPolicy;
(function (IncidentPolicy) {
    IncidentPolicy["Everyone"] = "Everyone";
    IncidentPolicy["JustIvan"] = "JustIvan";
    IncidentPolicy["JustRichard"] = "JustRichard";
})(IncidentPolicy || (exports.IncidentPolicy = IncidentPolicy = {}));
const BasePipelineDefinitionSchema = zod_1.z.object({
    id: zod_1.z.string().uuid(),
    ownerUserId: zod_1.z.string().uuid(),
    editorUserIds: zod_1.z.array(zod_1.z.string().uuid()),
    timeCreated: zod_1.z.string(),
    timeUpdated: zod_1.z.string()
});
const AlertsOptionsSchema = zod_1.z.object({
    pagerduty: zod_1.z.boolean().optional(),
    loadIncidentPagePolicy: zod_1.z.nativeEnum(IncidentPolicy).optional(),
    discordTags: zod_1.z.array(zod_1.z.string()).optional(),
    discordAlerts: zod_1.z.boolean().optional(),
    alertOnLogErrors: zod_1.z.boolean().optional(),
    errorLogIgnoreRegexes: zod_1.z.array(zod_1.z.string()).optional(),
    alertOnLogWarnings: zod_1.z.boolean().optional(),
    warningLogIgnoreRegexes: zod_1.z.array(zod_1.z.string()).optional(),
    alertOnAtomMismatch: zod_1.z.boolean().optional()
});
const BasePipelineOptionsSchema = zod_1.z.object({
    /**
     * Paused pipelines don't load data, but their APIs are still
     * accessible and enabled.
     */
    paused: zod_1.z.boolean().optional(),
    name: zod_1.z.string().optional(),
    notes: zod_1.z.string().optional(),
    alerts: AlertsOptionsSchema.optional(),
    /**
     * Protected pipelines can't be deleted.
     */
    protected: zod_1.z.boolean().optional(),
    important: zod_1.z.boolean().optional(),
    disableCache: zod_1.z.boolean().optional()
});
/**
 * Pipeline definitions can also include manually-added tickets. Pipelines that
 * support this will create tickets according to these specifications, in
 * addition to those loaded from their primary data source.
 */
const ManualTicketSchema = zod_1.z.object({
    /**
     * The ID of the ticket.
     */
    id: zod_1.z.string().uuid(),
    /**
     * The generic issuance UUID of the event that the ticket is for.
     */
    eventId: zod_1.z.string().uuid(),
    /**
     * The generic issuance UUID for the product/ticket type.
     */
    productId: zod_1.z.string().uuid(),
    /**
     * The email to assign the ticket to.
     */
    attendeeEmail: zod_1.z.string().email(),
    /**
     * The full name of the attendee.
     */
    attendeeName: zod_1.z.string().min(1),
    timeCreated: zod_1.z.string().optional()
});
const ManualTicketListSchema = zod_1.z
    .array(ManualTicketSchema)
    .optional()
    .refine((manualTickets) => 
// If manualTickets is undefined then that's OK
manualTickets === undefined ||
    // Otherwise make sure each one has a unique ID
    manualTickets.length ===
        new Set(manualTickets.map((manualTicket) => manualTicket.id)).size, { message: "Ticket IDs must be unique" });
const LemonadePipelineTicketTypeConfigSchema = zod_1.z.object({
    /**
     * The ID of this ticket type on the Lemonade end.
     */
    externalId: zod_1.z.string(),
    /**
     * The UUID of this ticket type used in {@link EdDSATicketPCD}.
     */
    genericIssuanceProductId: zod_1.z.string().uuid(),
    /**
     * Whether this ticket type is allowed to check other tickets in or not.
     */
    isSuperUser: zod_1.z.boolean(),
    /**
     * Display name
     */
    name: zod_1.z.string()
});
exports.MemberCriteriaSchema = zod_1.z.object({
    /**
     * generic issuance event id
     */
    eventId: zod_1.z.string().uuid(),
    /**
     * generic issuance product id
     */
    productId: zod_1.z.string().uuid().optional()
});
const SemaphoreGroupConfigSchema = zod_1.z.object({
    /**
     * Defines the set of event ID/product ID pairs that qualify a ticket-holder
     * for membership in this group. If no product ID is specified, then all
     * tickets for the event will qualify for group membership.
     *
     * The groupId is a UUID which the administrator should generate.
     */
    groupId: zod_1.z.string().uuid(),
    name: zod_1.z.string().min(1),
    memberCriteria: zod_1.z.array(exports.MemberCriteriaSchema)
});
const SemaphoreGroupListSchema = zod_1.z
    .array(SemaphoreGroupConfigSchema)
    .optional()
    .refine((groups) => 
// Groups being undefined is valid
groups === undefined ||
    // If groups are defined, the number of unique IDs must equal the
    // number of groups
    groups.length === new Set(groups.map((group) => group.groupId)).size, { message: "Semaphore group IDs must be unique" })
    .refine((groups) => 
// Groups being undefined is valid
groups === undefined ||
    // If groups are defined, the number of unique names must equal the
    // number of groups
    groups.length === new Set(groups.map((group) => group.name)).size, { message: "Semaphore group names must be unique" });
const LemonadePipelineEventConfigSchema = zod_1.z.object({
    /**
     * The ID of this event on the Lemonade end.
     */
    externalId: zod_1.z.string(),
    /**
     * Display name.
     */
    name: zod_1.z.string(),
    /**
     * The UUID of this event used for {@link EdDSATicketPCD}.
     */
    genericIssuanceEventId: zod_1.z.string().uuid(),
    /**
     * Roughly translates to Products in {@link EdDSATicketPCD}.
     */
    ticketTypes: zod_1.z.array(LemonadePipelineTicketTypeConfigSchema)
});
exports.ActionScreenConfigSchema = zod_1.z.object({
    eventBannerUrl: zod_1.z.string().optional(),
    eventNameConfig: zod_1.z.string().optional()
});
exports.BadgeConfigSchema = zod_1.z.object({
    id: zod_1.z.string(),
    eventName: zod_1.z.string(),
    productName: zod_1.z.string().optional(),
    imageUrl: zod_1.z.string(),
    givers: zod_1.z.array(zod_1.z.string()).optional(),
    grantOnCheckin: zod_1.z.boolean().optional(),
    maxPerDay: zod_1.z.number().optional()
});
exports.BadgesConfigSchema = zod_1.z.object({
    enabled: zod_1.z.boolean().optional(),
    choices: zod_1.z.array(exports.BadgeConfigSchema).optional()
});
exports.ContactsConfigSchema = zod_1.z.object({
    enabled: zod_1.z.boolean().optional()
});
/**
 * Configuration of actions Podbox enables subscribers of the same Pipeline
 * to perform on each other:
 * - checking in
 * - issuing 'badges'
 * - pushing a contact card to scanee's zupass
 * - potentially other actions, like throwing snowballs.
 */
const TicketActionsOptionsSchema = zod_1.z.object({
    badges: exports.BadgesConfigSchema.optional(),
    contacts: exports.ContactsConfigSchema.optional(),
    screenConfig: exports.ActionScreenConfigSchema.optional()
});
const FeedIssuanceOptionsSchema = zod_1.z.object({
    feedId: zod_1.z.string(),
    feedDisplayName: zod_1.z.string(),
    feedDescription: zod_1.z.string(),
    feedFolder: zod_1.z.string()
});
const ImageOptionsSchema = zod_1.z.object({
    imageUrl: zod_1.z.string(),
    requireCheckedIn: zod_1.z.boolean(),
    qrCodeOverrideImageUrl: zod_1.z.string().optional(),
    eventStartDate: zod_1.z.string().optional(),
    eventLocation: zod_1.z.string().optional()
});
const LemonadePipelineOptionsSchema = BasePipelineOptionsSchema.extend({
    /**
     * Configured by the user when setting up Lemonade as a data source.
     */
    oauthAudience: zod_1.z.string(),
    oauthClientId: zod_1.z.string(),
    oauthClientSecret: zod_1.z.string(),
    oauthServerUrl: zod_1.z.string(),
    backendUrl: zod_1.z.string(),
    events: zod_1.z.array(LemonadePipelineEventConfigSchema),
    superuserEmails: zod_1.z.array(zod_1.z.string()).optional(),
    feedOptions: FeedIssuanceOptionsSchema,
    manualTickets: ManualTicketListSchema,
    ticketActions: TicketActionsOptionsSchema.optional(),
    semaphoreGroups: SemaphoreGroupListSchema,
    enablePODTickets: zod_1.z.boolean().optional()
}).refine((val) => {
    // Validate that the manual tickets have event and product IDs that match the
    // event configuration.
    const events = new Map(val.events.map((ev) => [ev.genericIssuanceEventId, ev]));
    for (const manualTicket of val.manualTickets ?? []) {
        // Check that the event exists
        const manualTicketEvent = events.get(manualTicket.eventId);
        if (!manualTicketEvent) {
            return false;
        }
        // Check that the event has a product with the product ID on the ticket
        if (!manualTicketEvent.ticketTypes.find((ticketType) => ticketType.genericIssuanceProductId === manualTicket.productId)) {
            return false;
        }
    }
    return true;
});
const LemonadePipelineDefinitionSchema = BasePipelineDefinitionSchema.extend({
    type: zod_1.z.literal(PipelineType.Lemonade),
    options: LemonadePipelineOptionsSchema
});
function isLemonadePipelineDefinition(d) {
    return d.type === PipelineType.Lemonade;
}
exports.isLemonadePipelineDefinition = isLemonadePipelineDefinition;
const PretixProductConfigSchema = zod_1.z.object({
    /**
     * Pretix's item ID
     */
    externalId: zod_1.z.string(),
    /**
     * Our UUID
     */
    genericIssuanceId: zod_1.z.string().uuid(),
    /**
     * Display name
     */
    name: zod_1.z.string(),
    /**
     * Is a user with this product a "superuser"?
     * Superusers are able to check tickets in to events.
     */
    isSuperUser: zod_1.z.boolean(),
    /**
     * If the attendee's name is collected by a question
     * other than the default attendee name question, this
     * field lets you configure Podbox to prefer to read
     * names from answers to the question with this `question_identifier`
     *
     * see pretix docs here: https://docs.pretix.eu/en/latest/api/resources/orders.html#order-position-resource
     */
    nameQuestionPretixQuestionIdentitifier: zod_1.z.string().optional(),
    /**
     * Whether the item is considereed an "add-on item" for the purposes of swag
     */
    isAddOnItem: zod_1.z.boolean().optional()
});
const PretixEventConfigSchema = zod_1.z.object({
    /**
     * Pretix's event ID
     */
    externalId: zod_1.z.string(),
    /**
     * Our UUID
     */
    genericIssuanceId: zod_1.z.string().uuid(),
    /**
     * Display name for the event
     */
    name: zod_1.z.string(),
    /**
     * Options to configure displaying an image instead of the QR code
     */
    imageOptions: ImageOptionsSchema.optional(),
    products: zod_1.z.array(PretixProductConfigSchema),
    /**
     * Skip validation of event settings - use with caution!
     */
    skipSettingsValidation: zod_1.z.boolean().optional()
});
exports.AutoIssuanceOptionsSchema = zod_1.z.object({
    memberCriteria: zod_1.z.array(exports.MemberCriteriaSchema),
    eventId: zod_1.z.string(),
    productId: zod_1.z.string(),
    quantity: zod_1.z.number(),
    schedule: zod_1.z.object({
        startDate: zod_1.z.string(),
        endDate: zod_1.z.string().optional(),
        intervalMs: zod_1.z.number()
    })
});
exports.UserPermissionsOptionsSchema = zod_1.z.object({
    members: zod_1.z.array(exports.MemberCriteriaSchema),
    canCheckIn: zod_1.z.object({
        eventId: zod_1.z.string(),
        productId: zod_1.z.string().optional()
    })
});
const PretixPipelineOptionsSchema = BasePipelineOptionsSchema.extend({
    /**
     * This object represents a configuration from which the server can instantiate
     * a functioning {@link PretixPipeline}. Partially specified by the user.
     */
    pretixAPIKey: zod_1.z.string(),
    pretixOrgUrl: zod_1.z.string(),
    events: zod_1.z.array(PretixEventConfigSchema),
    feedOptions: FeedIssuanceOptionsSchema,
    manualTickets: ManualTicketListSchema,
    semaphoreGroups: SemaphoreGroupListSchema,
    enablePODTickets: zod_1.z.boolean().optional(),
    autoIssuance: zod_1.z.array(exports.AutoIssuanceOptionsSchema).optional(),
    userPermissions: zod_1.z.array(exports.UserPermissionsOptionsSchema).optional()
}).refine((val) => {
    // Validate that the manual tickets have event and product IDs that match the
    // event configuration.
    const events = new Map(val.events.map((ev) => [ev.genericIssuanceId, ev]));
    for (const manualTicket of val.manualTickets ?? []) {
        // Check that the event exists
        const manualTicketEvent = events.get(manualTicket.eventId);
        if (!manualTicketEvent) {
            return false;
        }
        // Check that the event has a product with the product ID on the ticket
        if (!manualTicketEvent.products.find((product) => product.genericIssuanceId === manualTicket.productId)) {
            return false;
        }
    }
    return true;
});
const PretixPipelineDefinitionSchema = BasePipelineDefinitionSchema.extend({
    type: zod_1.z.literal(PipelineType.Pretix),
    options: PretixPipelineOptionsSchema
});
function isPretixPipelineDefinition(d) {
    return d.type === PipelineType.Pretix;
}
exports.isPretixPipelineDefinition = isPretixPipelineDefinition;
var CSVPipelineOutputType;
(function (CSVPipelineOutputType) {
    /**
     * {@link EdDSAMessagePCD}
     */
    CSVPipelineOutputType["Message"] = "EdDSAMessage";
    CSVPipelineOutputType["Ticket"] = "EdDSATicket";
    CSVPipelineOutputType["PODTicket"] = "PODTicketPCD";
})(CSVPipelineOutputType || (exports.CSVPipelineOutputType = CSVPipelineOutputType = {}));
const CSVPipelineOptionsSchema = BasePipelineOptionsSchema.extend({
    csv: zod_1.z.string(),
    outputType: zod_1.z.nativeEnum(CSVPipelineOutputType).optional(),
    feedOptions: FeedIssuanceOptionsSchema,
    issueToUnmatchedEmail: zod_1.z.boolean().optional(),
    semaphoreGroupName: zod_1.z.string().optional()
});
const CSVPipelineDefinitionSchema = BasePipelineDefinitionSchema.extend({
    type: zod_1.z.literal(PipelineType.CSV),
    options: CSVPipelineOptionsSchema
});
function isCSVPipelineDefinition(d) {
    return d.type === PipelineType.CSV;
}
exports.isCSVPipelineDefinition = isCSVPipelineDefinition;
/**
 * POD Pipeline.
 */
var PODPipelineInputType;
(function (PODPipelineInputType) {
    PODPipelineInputType["CSV"] = "CSV";
})(PODPipelineInputType || (exports.PODPipelineInputType = PODPipelineInputType = {}));
var PODPipelineInputFieldType;
(function (PODPipelineInputFieldType) {
    PODPipelineInputFieldType["String"] = "string";
    PODPipelineInputFieldType["Int"] = "int";
    PODPipelineInputFieldType["Date"] = "date";
    PODPipelineInputFieldType["Boolean"] = "boolean";
    PODPipelineInputFieldType["UUID"] = "uuid";
    PODPipelineInputFieldType["Cryptographic"] = "cryptographic";
    PODPipelineInputFieldType["EdDSAPubKey"] = "eddsa_pubkey";
})(PODPipelineInputFieldType || (exports.PODPipelineInputFieldType = PODPipelineInputFieldType = {}));
const PODPipelineInputFieldSchema = zod_1.z.object({
    type: zod_1.z.nativeEnum(PODPipelineInputFieldType)
});
const PODPipelineInputColumnsSchema = zod_1.z.record(zod_1.z.string(), PODPipelineInputFieldSchema);
const PODPipelineBaseInputSchema = zod_1.z.object({
    type: zod_1.z.nativeEnum(PODPipelineInputType),
    columns: PODPipelineInputColumnsSchema
});
const PODPipelineCSVInputSchema = PODPipelineBaseInputSchema.extend({
    type: zod_1.z.literal(PODPipelineInputType.CSV),
    csv: zod_1.z.string()
});
const PODPipelineInputSchema = zod_1.z.discriminatedUnion("type", [
    PODPipelineCSVInputSchema
]);
var PODPipelinePCDTypes;
(function (PODPipelinePCDTypes) {
    PODPipelinePCDTypes["PODPCD"] = "PODPCD";
    PODPipelinePCDTypes["PODTicketPCD"] = "PODTicketPCD";
})(PODPipelinePCDTypes || (exports.PODPipelinePCDTypes = PODPipelinePCDTypes = {}));
const PODPipelineSupportedPODValueTypes = zod_1.z.enum([
    "string",
    "int",
    "cryptographic",
    "eddsa_pubkey"
]);
const PODPipelinePODEntrySchema = zod_1.z.object({
    type: PODPipelineSupportedPODValueTypes,
    source: zod_1.z.discriminatedUnion("type", [
        zod_1.z.object({ type: zod_1.z.literal("input"), name: zod_1.z.string() }),
        zod_1.z.object({ type: zod_1.z.literal("credentialSemaphoreID") }),
        zod_1.z.object({ type: zod_1.z.literal("credentialEmail") }),
        zod_1.z.object({
            type: zod_1.z.literal("configured"),
            value: zod_1.z.string()
        })
    ])
});
const PODPipelinePODEntriesSchema = zod_1.z.record(zod_1.z.string(), PODPipelinePODEntrySchema);
exports.PODPipelineOutputMatchSchema = zod_1.z.discriminatedUnion("type", [
    zod_1.z.object({ type: zod_1.z.literal("semaphoreID"), entry: zod_1.z.string() }),
    zod_1.z.object({ type: zod_1.z.literal("email"), entry: zod_1.z.string() }),
    zod_1.z.object({ type: zod_1.z.literal("none") })
]);
const PODPipelineOutputSchema = zod_1.z.object({
    pcdType: zod_1.z.nativeEnum(PODPipelinePCDTypes),
    /**
     * @todo verify that all input-derived entries have matching columns and
     * possibly that column types match entry types
     */
    entries: PODPipelinePODEntriesSchema,
    match: exports.PODPipelineOutputMatchSchema
});
function validatePODPipelineOptions(options) {
    for (const [outputName, output] of Object.entries(options.outputs)) {
        for (const entry of Object.values(output.entries)) {
            if (entry.source.type === "input") {
                if (!options.input.columns[entry.source.name]) {
                    throw new Error(`Output ${outputName} has an input column ${entry.source.name} that does not exist in the input`);
                }
            }
        }
    }
}
exports.validatePODPipelineOptions = validatePODPipelineOptions;
const PODPipelineFeedOptionsSchema = FeedIssuanceOptionsSchema.extend({
    feedType: zod_1.z.enum(["deleteAndReplace", "replace"])
});
const PODPipelineOptionsSchema = BasePipelineOptionsSchema.extend({
    input: PODPipelineInputSchema,
    outputs: zod_1.z.record(zod_1.z.string(), PODPipelineOutputSchema),
    feedOptions: PODPipelineFeedOptionsSchema
}).superRefine((val, ctx) => {
    try {
        validatePODPipelineOptions(val);
    }
    catch (e) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: (0, util_1.getErrorMessage)(e)
        });
    }
});
exports.PODPipelineDefinitionSchema = BasePipelineDefinitionSchema.extend({
    type: zod_1.z.literal(PipelineType.POD),
    options: PODPipelineOptionsSchema
});
function isPODPipelineDefinition(d) {
    return d.type === PipelineType.POD;
}
exports.isPODPipelineDefinition = isPODPipelineDefinition;
/**
 * CSVTicket Pipeline.
 */
const CSVTicketPipelineOptionsSchema = BasePipelineOptionsSchema.extend({
    eventName: zod_1.z.string(),
    csv: zod_1.z.string(),
    feedOptions: FeedIssuanceOptionsSchema,
    pcdTypes: zod_1.z.array(zod_1.z.enum(["EdDSATicketPCD", "PODTicketPCD"])).min(1),
    issueToUnmatchedEmail: zod_1.z.boolean().optional(),
    semaphoreGroupName: zod_1.z.string().optional()
});
const CSVTicketPipelineDefinitionSchema = BasePipelineDefinitionSchema.extend({
    type: zod_1.z.literal(PipelineType.CSVTicket),
    options: CSVTicketPipelineOptionsSchema
});
function isCSVTicketPipelineDefinition(d) {
    return d.type === PipelineType.CSVTicket;
}
exports.isCSVTicketPipelineDefinition = isCSVTicketPipelineDefinition;
/**
 * This item is exported so that we can use it for validation on generic issuance server.
 */
exports.PipelineDefinitionSchema = zod_1.z.discriminatedUnion("type", [
    LemonadePipelineDefinitionSchema,
    PretixPipelineDefinitionSchema,
    CSVPipelineDefinitionSchema,
    exports.PODPipelineDefinitionSchema,
    CSVTicketPipelineDefinitionSchema
]);
const PipelineHistoryEntrySchema = zod_1.z.object({
    id: zod_1.z.string().uuid(),
    pipeline: exports.PipelineDefinitionSchema,
    timeCreated: zod_1.z.string(),
    editorUserId: zod_1.z.string().optional()
});
