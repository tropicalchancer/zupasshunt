"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CredentialManager = exports.createStorageBackedCredentialCache = exports.createCredentialCache = exports.ZUPASS_CREDENTIAL_REQUEST = exports.PODBOX_CREDENTIAL_REQUEST = void 0;
const email_pcd_1 = require("@pcd/email-pcd");
const pcd_types_1 = require("@pcd/pcd-types");
const semaphore_identity_pcd_1 = require("@pcd/semaphore-identity-pcd");
const semaphore_signature_pcd_1 = require("@pcd/semaphore-signature-pcd");
const util_1 = require("@pcd/util");
const Credential_1 = require("./Credential");
const StorageBackedMap_1 = require("./util/StorageBackedMap");
const CACHE_TTL = util_1.ONE_HOUR_MS;
/**
 * These constants are convenient values for credential requests.
 * PODBOX_CREDENTIAL_REQUEST requires an EmailPCD, since this is commonly
 * required for Podbox requests.
 * ZUPASS_CREDENTIAL_REQUEST does not, as Zupass can identify users by their
 * Semaphore ID alone.
 */
exports.PODBOX_CREDENTIAL_REQUEST = {
    pcdType: "email-pcd",
    signatureType: "sempahore-signature-pcd"
};
exports.ZUPASS_CREDENTIAL_REQUEST = {
    signatureType: "sempahore-signature-pcd"
};
// Creates an in-memory cache with a TTL of one hour.
// Use this where local storage is not available, e.g. in tests
function createCredentialCache() {
    return new Map();
}
exports.createCredentialCache = createCredentialCache;
// Creates an in-memory cache with a TTL of one hour, backed by localStorage
function createStorageBackedCredentialCache() {
    return new StorageBackedMap_1.StorageBackedMap("credential-cache-multi-email-with-v4");
}
exports.createStorageBackedCredentialCache = createStorageBackedCredentialCache;
/**
 * Handles generation of credentials for feeds.
 */
class CredentialManager {
    constructor(identity, pcds, cache) {
        this.identityV3 = identity;
        this.pcds = pcds;
        this.cache = cache;
        this.credentialPromises = new Map();
    }
    // Can we get a credential containing a given PCD type?
    canGenerateCredential(req) {
        if (req.pcdType === "email-pcd") {
            return this.pcds.getPCDsByType(req.pcdType).length !== 0;
        }
        else if (req.pcdType === undefined) {
            return true;
        }
        else {
            // We can't generate credentials containing any other PCD type yet
            return false;
        }
    }
    // Get a credential from the local cache, if it exists
    getCachedCredentials(type, cacheId) {
        const cacheKey = type ?? "none";
        const res = this.cache.get(cacheKey);
        if (res) {
            if (Date.now() - res.timestamp < CACHE_TTL && res.cacheId === cacheId) {
                return res.value;
            }
            else {
                this.cache.delete(cacheKey);
            }
        }
        return undefined;
    }
    getCurrentCacheId() {
        return this.pcds.getPCDsByType(email_pcd_1.EmailPCDTypeName)
            .map((p) => p.claim.emailAddress)
            .join(":");
    }
    // Adds a credential to the cache
    setCachedCredentials(request, value) {
        const cacheKey = request.pcdType ?? "none";
        const cacheId = this.getCurrentCacheId();
        this.cache.set(cacheKey, {
            value,
            timestamp: Date.now(),
            request,
            cacheId
        });
        // This can happen asynchronously, so don't await on the promise
        this.purgeExpiredCredentials();
    }
    // Purges expired items from the cache
    async purgeExpiredCredentials() {
        const keysToRemove = [];
        this.cache.forEach((v, k) => {
            if (Date.now() - v.timestamp >= CACHE_TTL) {
                keysToRemove.push(k);
            }
        });
        keysToRemove.forEach((key) => this.cache.delete(key));
    }
    /**
     * Returns a requested credential, either from the cache or by generating it.
     */
    async requestCredential(req) {
        const cachedCredential = this.getCachedCredentials(req.pcdType, this.getCurrentCacheId());
        if (cachedCredential) {
            return cachedCredential;
        }
        const credentialPromise = this.credentialPromises.get(req.pcdType);
        if (credentialPromise &&
            credentialPromise.cacheId === this.getCurrentCacheId()) {
            if (Date.now() - credentialPromise.timestamp < CACHE_TTL) {
                return credentialPromise.credential;
            }
            else {
                this.credentialPromises.delete(req.pcdType);
            }
        }
        const newPromise = this.generateCredential(req);
        newPromise.then((credential) => {
            this.setCachedCredentials(req, credential);
        });
        this.credentialPromises.set(req.pcdType, {
            credential: newPromise,
            timestamp: Date.now(),
            cacheId: this.getCurrentCacheId()
        });
        return newPromise;
    }
    /**
     * Generates the requested credential, if possible.
     * Takes a {@link CredentialRequest} and produces a serialized PCD which
     * consists of a signature PCD (e.g. a semaphore signature PCD) which wraps
     * a {@link FeedCredentialPayload}. This payload contains a timestamp, and
     * may contain a PCD if a) the feed requests one and b) CredentialManager
     * can find a matching PCD.
     */
    async generateCredential(req) {
        if (req.pcdType === "email-pcd") {
            const pcds = this.pcds.getPCDsByType(req.pcdType);
            if (pcds.length === 0) {
                throw new Error(`Could not find a PCD of type ${req.pcdType} for credential payload`);
            }
            const emailPCDs = await Promise.all(pcds.map((pcd) => this.pcds.serialize(pcd)));
            return this.semaphoreSignPayload((0, Credential_1.createCredentialPayload)(emailPCDs));
        }
        else if (req.pcdType === undefined) {
            return this.semaphoreSignPayload((0, Credential_1.createCredentialPayload)());
        }
        else {
            throw new Error(`Cannot issue credential containing a PCD of type ${req.pcdType}`);
        }
    }
    // Takes a payload and wraps it in a signature PCD.
    async semaphoreSignPayload(payload) {
        // In future we might support other types of signature here
        const signaturePCD = await semaphore_signature_pcd_1.SemaphoreSignaturePCDPackage.prove({
            identity: {
                argumentType: pcd_types_1.ArgumentTypeName.PCD,
                value: await semaphore_identity_pcd_1.SemaphoreIdentityPCDPackage.serialize(await semaphore_identity_pcd_1.SemaphoreIdentityPCDPackage.prove({
                    identityV3: this.identityV3
                }))
            },
            signedMessage: {
                argumentType: pcd_types_1.ArgumentTypeName.String,
                value: JSON.stringify(payload)
            }
        });
        return await semaphore_signature_pcd_1.SemaphoreSignaturePCDPackage.serialize(signaturePCD);
    }
}
exports.CredentialManager = CredentialManager;
