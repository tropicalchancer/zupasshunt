import { ArgsOf, PCDPackage, SerializedPCD } from "@pcd/pcd-types";
import { PendingPCD } from "./PendingPCDUtils";
export declare enum PCDRequestType {
    Get = "Get",
    GetWithoutProving = "GetWithoutProving",
    Add = "Add",
    ProveAndAdd = "ProveAndAdd"
}
export interface PCDRequest {
    returnUrl: string;
    postMessage: boolean;
    type: PCDRequestType;
}
export interface ProveOptions {
    genericProveScreen?: boolean;
    title?: string;
    description?: string;
    requesterUrl?: string;
    debug?: boolean;
    proveOnServer?: boolean;
    signIn?: boolean;
    multi?: boolean;
}
/**
 * When a website uses the Zupass for signing in, Zupass
 * signs this payload using a `SemaphoreSignaturePCD`.
 */
export interface SignInMessagePayload {
    uuid: string;
    referrer: string;
}
export interface PCDGetRequest<T extends PCDPackage = PCDPackage> extends PCDRequest {
    type: PCDRequestType.Get;
    pcdType: T["name"];
    args: ArgsOf<T>;
    options?: ProveOptions;
}
export interface PCDGetWithoutProvingRequest extends PCDRequest {
    pcdType: string;
}
export interface PCDAddRequest extends PCDRequest {
    type: PCDRequestType.Add;
    pcd: SerializedPCD;
    mintUrl?: string;
    folder?: string;
    redirectToFolder?: boolean;
}
export interface PCDProveAndAddRequest<T extends PCDPackage = PCDPackage> extends PCDRequest {
    type: PCDRequestType.ProveAndAdd;
    pcdType: string;
    args: ArgsOf<T>;
    options?: ProveOptions;
    returnPCD?: boolean;
    folder?: string;
}
export declare function getWithoutProvingUrl(zupassClientUrl: string, returnUrl: string, pcdType: string, postMessage?: boolean): string;
export declare function constructZupassPcdGetRequestUrl<T extends PCDPackage>(zupassClientUrl: string, returnUrl: string, pcdType: T["name"], args: ArgsOf<T>, options?: ProveOptions, postMessage?: boolean): string;
export declare function constructZupassPcdAddRequestUrl(zupassClientUrl: string, returnUrl: string, pcd: SerializedPCD, folder?: string, postMessage?: boolean, redirectToFolder?: boolean): string;
export declare function constructZupassPcdMintRequestUrl(zupassClientUrl: string, mintUrl: string, returnUrl: string, pcd: SerializedPCD, folder?: string, postMessage?: boolean, redirectToFolder?: boolean): string;
export declare function constructZupassPcdProveAndAddRequestUrl<T extends PCDPackage = PCDPackage>(zupassClientUrl: string, returnUrl: string, pcdType: string, args: ArgsOf<T>, options?: ProveOptions, returnPCD?: boolean, folder?: string, postMessage?: boolean): string;
export declare function postSerializedPCDMessage(window: Window, serialized: SerializedPCD): void;
export declare function postSerializedMultiPCDMessage(window: Window, pcds: SerializedPCD[]): void;
export declare function postPendingPCDMessage(window: Window, pending: PendingPCD): void;
export declare enum PayloadType {
    RedirectTopicData = "topic-data",
    NullifierHash = "nullifier-hash",
    AnonTopicDataPayload = "anon-topic-data-payload",
    ReactData = "react-data"
}
export type RedirectTopicDataPayload = {
    type: PayloadType.RedirectTopicData;
    value: {
        topicId: number;
        chatId: number;
    };
};
export type NullifierHashPayload = {
    type: PayloadType.NullifierHash;
    value: string;
};
export type AnonTopicDataPayload = {
    type: PayloadType.AnonTopicDataPayload;
    value: {
        chatId: number;
        topicName: string;
        topicId: number;
        validEventIds: string[];
    };
};
export type ReactDataPayload = {
    type: PayloadType.ReactData;
    anonMessageId: string;
    react: string;
};
export type AnonWebAppPayload = RedirectTopicDataPayload | NullifierHashPayload | AnonTopicDataPayload | ReactDataPayload;
//# sourceMappingURL=PassportInterface.d.ts.map