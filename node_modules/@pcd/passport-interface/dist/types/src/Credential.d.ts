import { EdDSAPublicKey } from "@pcd/eddsa-pcd";
import { EmailPCD } from "@pcd/email-pcd";
import { SerializedPCD } from "@pcd/pcd-types";
import { SemaphoreSignaturePCD } from "@pcd/semaphore-signature-pcd";
export type Credential = SerializedPCD<SemaphoreSignaturePCD>;
export interface CredentialPayload {
    pcd?: SerializedPCD<EmailPCD>;
    pcds?: SerializedPCD<EmailPCD>[];
    timestamp: number;
}
/**
 * The result of successfully verifying a credential, as determined by
 * verifyCredential() below. To be verified, the credential must be wrapped in
 * a verifiable signature PCD, and must contain a payload that includes a
 * timestamp and an optional additional PCD (currently only EmailPCD is
 * supported for this purpose). The timestamp must be within certain bounds,
 * and the embedded PCD must be tied to the same identity that signed the
 * wrapper PCD.
 *
 * If the credential is verified, then this data is extracted from the claims
 * contained within it, and can be implicitly trusted without need for further
 * verification.
 *
 * We do not need to return whole PCDs here, because the proofs have been
 * verified, and since we expect to cache these in memory, we can avoid wasting
 * memory on caching large PCD objects.
 */
export interface VerifiedCredential {
    emails?: SignedEmail[];
    semaphoreId: string;
    semaphoreV4Id?: string;
    authKey?: string;
}
export interface SignedEmail {
    signer: EdDSAPublicKey;
    email: string;
    semaphoreId: string;
    semaphoreV4Id?: string;
}
/**
 * Creates a feed credential payload with timestamp.
 */
export declare function createCredentialPayload(pcds?: SerializedPCD<EmailPCD> | SerializedPCD<EmailPCD>[] | undefined): CredentialPayload;
export declare class VerificationError extends Error {
}
export declare function verifyCredential(credential: Credential): Promise<VerifiedCredential>;
//# sourceMappingURL=Credential.d.ts.map