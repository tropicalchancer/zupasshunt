import { PCDCollection } from "@pcd/pcd-collection";
import { SemaphoreSignaturePCD } from "@pcd/semaphore-signature-pcd";
import { UpgradeUserWithV4CommitmentRequest, UpgradeUserWithV4CommitmentResponseValue } from "../RequestTypes";
import { APIResult } from "./apiResult";
/**
 * Asks the Zupass server to add a semaphore v4 commitment to the user's account, given
 * they already have an account with just a v3 identity.
 *
 * Idempotent.
 *
 * @see {@link makeUpgradeUserWithV4CommitmentRequest} for details regarding what this request contains.
 *
 * Never rejects. All information encoded in the resolved response.
 */
export declare function requestUpgradeUserWithV4Commitment(zupassServerUrl: string, req: UpgradeUserWithV4CommitmentRequest): Promise<UpgradeUserWithV4CommitmentResult>;
export type UpgradeUserWithV4CommitmentResult = APIResult<UpgradeUserWithV4CommitmentResponseValue>;
/**
 * @returns a v3 signature of a v4 signature of the identity commitment of the identity that
 * was used to create the outermost v3 signature. Expects that both a v3 and v4 identity PCD
 * exist in the collection. This proves that the creator of this request 'owns' both identities.
 */
export declare function makeUpgradeUserWithV4CommitmentRequest(pcdCollection: PCDCollection): Promise<UpgradeUserWithV4CommitmentRequest>;
/**
 * @param sig created by {@link makeUpgradeUserWithV4CommitmentRequest}. This function verifies that it
 * is a valid v3 signature of a valid v4 signature of the identity that was used to create
 * the outermost v3 signature.
 */
export declare function verifyAddV4CommitmentRequestPCD(sig: SemaphoreSignaturePCD): Promise<V4MigrationVerification | undefined>;
export interface V4MigrationVerification {
    v3Commitment: string;
    v4PublicKey: string;
    v4Commitment: string;
}
//# sourceMappingURL=requestUpgradeUserWithV4Commitment.d.ts.map