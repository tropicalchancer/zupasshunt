import { Emitter } from "@pcd/emitter";
import { PCDAction, PCDCollection, PCDPermission } from "@pcd/pcd-collection";
import { ArgsOf, PCDPackage, PCDTypeNameOf } from "@pcd/pcd-types";
import { CredentialManagerAPI } from "./CredentialManager";
import { IFeedApi } from "./FeedAPI";
import { ListFeedsResponseValue } from "./RequestTypes";
export declare const enum ZupassFeedIds {
    Devconnect = "1",
    Frogs = "2",
    Email = "3",
    Zuzalu_23 = "4",
    Zuconnect_23 = "5"
}
/**
 * Applies a set of actions to a PCD collection.
 */
export declare function applyActions(collection: PCDCollection, actions: SubscriptionActions[]): Promise<void>;
/**
 * Class responsible for storing the list of feed providers this application is
 * aware of, as well as the list of feeds that each provider can serve, and which
 * of those we are subscribed to.
 */
export declare class FeedSubscriptionManager {
    updatedEmitter: Emitter;
    private api;
    private providers;
    private activeSubscriptions;
    private errors;
    constructor(api: IFeedApi, providers?: SubscriptionProvider[], activeSubscriptions?: Subscription[], errors?: Map<string, SubscriptionError>);
    /**
     * Creates a new FeedSubscriptionManager with the data from this one.
     *
     * This includes all data (subscriptions, providers, and errors, but doesn't
     * include dynamic state (listeners on the emitter).
     *
     * This is a shallow clone.  The resulting object has new containers but
     * the same underlying objects, which are expected to be immutable.  If you
     * need a deep clone, use serialization.
     */
    clone(): FeedSubscriptionManager;
    /**
     * Merges subscriptions from `other` into `this`, returning an object with
     * a count of the number of new providers and subscriptions added.
     *
     * Only subscriptions and providers are included in the merge.  Other
     * non-persistent state (listeners, errors) is ignored.
     *
     * The merge only ever adds new providers and/or subscriptions which do not
     * already exist.  Existing entries are never mutated.  Subscriptions will be
     * added only if their subscription ID is globally unique, and their feed ID
     * is unique within the scope of their provider URL.  Providers are added
     * only if there is a new subscription to add and no existing provider
     * for its URL.
     */
    merge(other: FeedSubscriptionManager): {
        newProviders: number;
        newSubscriptions: number;
    };
    /**
     * Fetches a list of all feeds from the given provider URL.
     */
    listFeeds(providerUrl: string): Promise<ListFeedsResponseValue>;
    pollEmailSubscription(zupassFeedUrl: string, credentialManager: CredentialManagerAPI, onFinish?: (actions: SubscriptionActions) => Promise<void>): Promise<SubscriptionActions[]>;
    /**
     * This "refreshes" a feed. Existing feed errors are cleared, and new
     * ones may be detected.
     *
     * Returns the successful responses. Failures will be recorded in
     * `this.errors` for display to the user.
     */
    pollSubscriptions(credentialManager: CredentialManagerAPI, onFinish?: (actions: SubscriptionActions) => Promise<void>, idsToPoll?: Array<string | undefined>): Promise<SubscriptionActions[]>;
    /**
     * Poll a single subscription. Intended for use when resolving errors
     * with a feed that failed to load due to network/connection issues.
     */
    pollSingleSubscription(subscription: Subscription, credentialManager: CredentialManagerAPI, onFinish?: (actions: SubscriptionActions) => Promise<void>): Promise<SubscriptionActions[]>;
    /**
     * Performs the network fetch of a subscription, and inspects the results
     * for validity. The error log for the subscription will be reset and
     * repopulated, so callers should check this in order to determine success.
     */
    private fetchSingleSubscription;
    /**
     * Validates that the actions received in a feed are permitted by the user.
     */
    private validateActions;
    getSubscriptionsByProvider(): Map<string, Subscription[]>;
    unsubscribe(subscriptionId: string): void;
    removeProvider(providerUrl: string): void;
    getSubscriptionsForProvider(providerUrl: string): Subscription[];
    findSubscription(providerUrl: string, feedId: string): Subscription | undefined;
    subscribe(providerUrl: string, info: Feed, replace?: boolean): Promise<Subscription>;
    updateFeedPermissionsForSubscription(subscriptionId: string, permissions: PCDPermission[]): void;
    flagSubscriptionAsEnded(subscriptionId: string, message: string): void;
    getSubscription(subscriptionId: string): Subscription | undefined;
    getSubscriptionsByProviderAndFeedId(providerUrl: string, feedId: string): Subscription[];
    hasProvider(providerUrl: string): boolean;
    getProvider(providerUrl: string): SubscriptionProvider | undefined;
    getOrAddProvider(providerUrl: string, providerName: string, timestampAdded?: number): SubscriptionProvider;
    addProvider(providerUrl: string, providerName: string, timestampAdded?: number): SubscriptionProvider;
    getProviders(): SubscriptionProvider[];
    getActiveSubscriptions(): Subscription[];
    serialize(): string;
    /**
     * Create a FeedSubscriptionManager from serialized data.
     * Upgrades from serialized data based on version number.
     */
    static deserialize(api: IFeedApi, serialized: string): FeedSubscriptionManager;
    setError(subscriptionId: string, error: SubscriptionError): void;
    resetError(subscriptionId: string): void;
    getError(subscriptionId: string): SubscriptionError | null;
    getAllErrors(): Map<string, SubscriptionError>;
    getHash(): Promise<string>;
}
export declare const enum SubscriptionErrorType {
    PermissionError = "permission-error",
    FetchError = "fetch-error"
}
export interface SubscriptionPermissionError {
    type: SubscriptionErrorType.PermissionError;
    actions: PCDAction[];
}
export interface SubscriptionFetchError {
    type: SubscriptionErrorType.FetchError;
    e: Error | undefined;
}
export type SubscriptionError = SubscriptionPermissionError | SubscriptionFetchError;
export interface SubscriptionActions {
    actions: PCDAction[];
    subscription: Subscription;
}
interface SerializedSubscriptionManagerV1 {
    providers: SubscriptionProvider[];
    subscribedFeeds: Subscription[];
    _storage_version: "v1";
}
export type SerializedSubscriptionManager = SerializedSubscriptionManagerV1;
export interface SubscriptionProvider {
    providerUrl: string;
    providerName: string;
    timestampAdded: number;
}
export interface CredentialRequest {
    signatureType: "sempahore-signature-pcd";
    pcdType?: "email-pcd";
}
export interface Feed<T extends PCDPackage = PCDPackage> {
    id: string;
    name: string;
    description: string;
    inputPCDType?: PCDTypeNameOf<T>;
    partialArgs?: ArgsOf<T>;
    permissions: PCDPermission[];
    credentialRequest: CredentialRequest;
    /**
     * If false, the feed will not automatically poll for updates.
     *
     * @default true
     */
    autoPoll?: boolean;
}
export interface Subscription {
    id: string;
    providerUrl: string;
    feed: Feed;
    subscribedTimestamp: number;
    ended: boolean;
    ended_message?: string;
}
export {};
//# sourceMappingURL=SubscriptionManager.d.ts.map