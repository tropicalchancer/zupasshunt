/**
 * @module @zk-kit/groth16
 * @version 0.3.0
 * @file A snippet of SnarkJS code for verifying and generating Groth16 proofs only.
 * @copyright Ethereum Foundation 2023
 * @license GPL-3.0
 * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/groth16}
*/
'use strict';

var ffjavascript$1 = require('ffjavascript');
var fs$1 = require('fs');
var constants$1 = require('constants');
var circom_runtime = require('circom_runtime');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var ffjavascript__namespace = /*#__PURE__*/_interopNamespaceDefault(ffjavascript$1);
var fs__namespace = /*#__PURE__*/_interopNamespaceDefault(fs$1);
var constants__namespace = /*#__PURE__*/_interopNamespaceDefault(constants$1);

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
				var args = [null];
				args.push.apply(args, arguments);
				var Ctor = Function.bind.apply(f, args);
				return new Ctor();
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var main$1 = {};

var require$$0$1 = /*@__PURE__*/getAugmentedNamespace(ffjavascript__namespace);

var main = {};

var require$$0 = /*@__PURE__*/getAugmentedNamespace(fs__namespace);

var require$$1 = /*@__PURE__*/getAugmentedNamespace(constants__namespace);

Object.defineProperty(main, '__esModule', { value: true });

function _interopDefault$1 (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var fs = _interopDefault$1(require$$0);
var constants = require$$1;

async function open(fileName, openFlags, cacheSize, pageSize) {
    cacheSize = cacheSize || 4096*64;
    if (typeof openFlags !== "number" && ["w+", "wx+", "r", "ax+", "a+"].indexOf(openFlags) <0)
        throw new Error("Invalid open option");
    const fd =await fs.promises.open(fileName, openFlags);

    const stats = await fd.stat();

    return  new FastFile(fd, stats, cacheSize, pageSize, fileName);
}


class FastFile {

    constructor(fd, stats, cacheSize, pageSize, fileName) {
        this.fileName = fileName;
        this.fd = fd;
        this.pos = 0;
        this.pageSize = pageSize || (1 << 8);
        while (this.pageSize < stats.blksize) {
            this.pageSize *= 2;
        }
        this.totalSize = stats.size;
        this.totalPages = Math.floor((stats.size -1) / this.pageSize)+1;
        this.maxPagesLoaded = Math.floor( cacheSize / this.pageSize)+1;
        this.pages = {};
        this.pendingLoads = [];
        this.writing = false;
        this.reading = false;
        this.avBuffs = [];
        this.history = {};
    }

    _loadPage(p) {
        const self = this;
        const P = new Promise((resolve, reject)=> {
            self.pendingLoads.push({
                page: p,
                resolve: resolve,
                reject: reject
            });
        });
        self.__statusPage("After Load request: ", p);
        return P;
    }

    __statusPage(s, p) {
        const logEntry = [];
        const self=this;
        if (!self.logHistory) return;
        logEntry.push("==" + s+ " " +p);
        let S = "";
        for (let i=0; i<self.pendingLoads.length; i++) {
            if (self.pendingLoads[i].page == p) S = S + " " + i;
        }
        if (S) logEntry.push("Pending loads:"+S);
        if (typeof self.pages[p] != "undefined") {
            const page = self.pages[p];
            logEntry.push("Loaded");
            logEntry.push("pendingOps: "+page.pendingOps);
            if (page.loading) logEntry.push("loading: "+page.loading);
            if (page.writing) logEntry.push("writing");
            if (page.dirty) logEntry.push("dirty");
        }
        logEntry.push("==");

        if (!self.history[p]) self.history[p] = [];
        self.history[p].push(logEntry);
    }

    __printHistory(p) {
        const self = this;
        if (!self.history[p]) console.log("Empty History ", p);
        console.log("History "+p);
        for (let i=0; i<self.history[p].length; i++) {
            for (let j=0; j<self.history[p][i].length; j++) {
                console.log("-> " + self.history[p][i][j]);
            }
        }
    }



    _triggerLoad() {
        const self = this;

        if (self.reading) return;
        if (self.pendingLoads.length==0) return;

        const pageIdxs = Object.keys(self.pages);

        const deletablePages = [];
        for (let i=0; i<pageIdxs.length; i++) {
            const page = self.pages[parseInt(pageIdxs[i])];
            if ((page.dirty == false)&&(page.pendingOps==0)&&(!page.writing)&&(!page.loading)) deletablePages.push(parseInt(pageIdxs[i]));
        }

        let freePages = self.maxPagesLoaded - pageIdxs.length;

        const ops = [];

        // while pending loads and
        //     the page is loaded or I can recover one.
        while (
            (self.pendingLoads.length>0) &&
            (   (typeof self.pages[self.pendingLoads[0].page] != "undefined" )
              ||(  (freePages>0)
                 ||(deletablePages.length>0)))) {
            const load = self.pendingLoads.shift();
            if (typeof self.pages[load.page] != "undefined") {
                self.pages[load.page].pendingOps ++;
                const idx = deletablePages.indexOf(load.page);
                if (idx>=0) deletablePages.splice(idx, 1);
                if (self.pages[load.page].loading) {
                    self.pages[load.page].loading.push(load);
                } else {
                    load.resolve();
                }
                self.__statusPage("After Load (cached): ", load.page);

            } else {
                if (freePages) {
                    freePages--;
                } else {
                    const fp = deletablePages.shift();
                    self.__statusPage("Before Unload: ", fp);
                    self.avBuffs.unshift(self.pages[fp]);
                    delete self.pages[fp];
                    self.__statusPage("After Unload: ", fp);
                }

                if (load.page>=self.totalPages) {
                    self.pages[load.page] = getNewPage();
                    load.resolve();
                    self.__statusPage("After Load (new): ", load.page);
                } else {
                    self.reading = true;
                    self.pages[load.page] = getNewPage();
                    self.pages[load.page].loading = [load];
                    ops.push(self.fd.read(self.pages[load.page].buff, 0, self.pageSize, load.page*self.pageSize).then((res)=> {
                        self.pages[load.page].size = res.bytesRead;
                        const loading = self.pages[load.page].loading;
                        delete self.pages[load.page].loading;
                        for (let i=0; i<loading.length; i++) {
                            loading[i].resolve();
                        }
                        self.__statusPage("After Load (loaded): ", load.page);
                        return res;
                    }, (err) => {
                        load.reject(err);
                    }));
                    self.__statusPage("After Load (loading): ", load.page);
                }
            }
        }
        // if (ops.length>1) console.log(ops.length);

        Promise.all(ops).then( () => {
            self.reading = false;
            if (self.pendingLoads.length>0) setImmediate(self._triggerLoad.bind(self));
            self._tryClose();
        });

        function getNewPage() {
            if (self.avBuffs.length>0) {
                const p = self.avBuffs.shift();
                p.dirty = false;
                p.pendingOps = 1;
                p.size =0;
                return p;
            } else {
                return {
                    dirty: false,
                    buff: new Uint8Array(self.pageSize),
                    pendingOps: 1,
                    size: 0
                };
            }
        }

    }


    _triggerWrite() {
        const self = this;
        if (self.writing) return;

        const pageIdxs = Object.keys(self.pages);

        const ops = [];

        for (let i=0; i<pageIdxs.length; i++) {
            const page = self.pages[parseInt(pageIdxs[i])];
            if (page.dirty) {
                page.dirty = false;
                page.writing = true;
                self.writing = true;
                ops.push( self.fd.write(page.buff, 0, page.size, parseInt(pageIdxs[i])*self.pageSize).then(() => {
                    page.writing = false;
                    return;
                }, (err) => {
                    console.log("ERROR Writing: "+err);
                    self.error = err;
                    self._tryClose();
                }));
            }
        }

        if (self.writing) {
            Promise.all(ops).then( () => {
                self.writing = false;
                setImmediate(self._triggerWrite.bind(self));
                self._tryClose();
                if (self.pendingLoads.length>0) setImmediate(self._triggerLoad.bind(self));
            });
        }
    }

    _getDirtyPage() {
        for (let p in this.pages) {
            if (this.pages[p].dirty) return p;
        }
        return -1;
    }

    async write(buff, pos) {
        if (buff.byteLength == 0) return;
        const self = this;
/*
        if (buff.byteLength > self.pageSize*self.maxPagesLoaded*0.8) {
            const cacheSize = Math.floor(buff.byteLength * 1.1);
            this.maxPagesLoaded = Math.floor( cacheSize / self.pageSize)+1;
        }
*/
        if (typeof pos == "undefined") pos = self.pos;
        self.pos = pos+buff.byteLength;
        if (self.totalSize < pos + buff.byteLength) self.totalSize = pos + buff.byteLength;
        if (self.pendingClose)
            throw new Error("Writing a closing file");
        const firstPage = Math.floor(pos / self.pageSize);
        const lastPage = Math.floor((pos + buff.byteLength -1) / self.pageSize);

        const pagePromises = [];
        for (let i=firstPage; i<=lastPage; i++) pagePromises.push(self._loadPage(i));
        self._triggerLoad();

        let p = firstPage;
        let o = pos % self.pageSize;
        let r = buff.byteLength;
        while (r>0) {
            await pagePromises[p-firstPage];
            const l = (o+r > self.pageSize) ? (self.pageSize -o) : r;
            const srcView = buff.slice( buff.byteLength - r, buff.byteLength - r + l);
            const dstView = new Uint8Array(self.pages[p].buff.buffer, o, l);
            dstView.set(srcView);
            self.pages[p].dirty = true;
            self.pages[p].pendingOps --;
            self.pages[p].size = Math.max(o+l, self.pages[p].size);
            if (p>=self.totalPages) {
                self.totalPages = p+1;
            }
            r = r-l;
            p ++;
            o = 0;
            if (!self.writing) setImmediate(self._triggerWrite.bind(self));
        }
    }

    async read(len, pos) {
        const self = this;
        let buff = new Uint8Array(len);
        await self.readToBuffer(buff, 0, len, pos);

        return buff;
    }

    async readToBuffer(buffDst, offset, len, pos) {
        if (len == 0) {
            return;
        }
        const self = this;
        if (len > self.pageSize*self.maxPagesLoaded*0.8) {
            const cacheSize = Math.floor(len * 1.1);
            this.maxPagesLoaded = Math.floor( cacheSize / self.pageSize)+1;
        }
        if (typeof pos == "undefined") pos = self.pos;
        self.pos = pos+len;
        if (self.pendingClose)
            throw new Error("Reading a closing file");
        const firstPage = Math.floor(pos / self.pageSize);
        const lastPage = Math.floor((pos + len -1) / self.pageSize);

        const pagePromises = [];
        for (let i=firstPage; i<=lastPage; i++) pagePromises.push(self._loadPage(i));

        self._triggerLoad();

        let p = firstPage;
        let o = pos % self.pageSize;
        // Remaining bytes to read
        let r = pos + len > self.totalSize ? len - (pos + len - self.totalSize): len;
        while (r>0) {
            await pagePromises[p - firstPage];
            self.__statusPage("After Await (read): ", p);

            // bytes to copy from this page
            const l = (o+r > self.pageSize) ? (self.pageSize -o) : r;
            const srcView = new Uint8Array(self.pages[p].buff.buffer, self.pages[p].buff.byteOffset + o, l);
            buffDst.set(srcView, offset+len-r);
            self.pages[p].pendingOps --;

            self.__statusPage("After Op done: ", p);

            r = r-l;
            p ++;
            o = 0;
            if (self.pendingLoads.length>0) setImmediate(self._triggerLoad.bind(self));
        }

        this.pos = pos + len;

    }


    _tryClose() {
        const self = this;
        if (!self.pendingClose) return;
        if (self.error) {
            self.pendingCloseReject(self.error);
        }
        const p = self._getDirtyPage();
        if ((p>=0) || (self.writing) || (self.reading) || (self.pendingLoads.length>0)) return;
        self.pendingClose();
    }

    close() {
        const self = this;
        if (self.pendingClose)
            throw new Error("Closing the file twice");
        return new Promise((resolve, reject) => {
            self.pendingClose = resolve;
            self.pendingCloseReject = reject;
            self._tryClose();
        }).then(()=> {
            self.fd.close();
        }, (err) => {
            self.fd.close();
            throw (err);
        });
    }

    async discard() {
        const self = this;
        await self.close();
        await fs.promises.unlink(this.fileName);
    }

    async writeULE32(v, pos) {
        const self = this;
        const tmpBuff32 = new Uint8Array(4);
        const tmpBuff32v = new DataView(tmpBuff32.buffer);

        tmpBuff32v.setUint32(0, v, true);

        await self.write(tmpBuff32, pos);
    }

    async writeUBE32(v, pos) {
        const self = this;

        const tmpBuff32 = new Uint8Array(4);
        const tmpBuff32v = new DataView(tmpBuff32.buffer);

        tmpBuff32v.setUint32(0, v, false);

        await self.write(tmpBuff32, pos);
    }


    async writeULE64(v, pos) {
        const self = this;

        const tmpBuff64 = new Uint8Array(8);
        const tmpBuff64v = new DataView(tmpBuff64.buffer);

        tmpBuff64v.setUint32(0, v & 0xFFFFFFFF, true);
        tmpBuff64v.setUint32(4, Math.floor(v / 0x100000000) , true);

        await self.write(tmpBuff64, pos);
    }

    async readULE32(pos) {
        const self = this;
        const b = await self.read(4, pos);

        const view = new Uint32Array(b.buffer);

        return view[0];
    }

    async readUBE32(pos) {
        const self = this;
        const b = await self.read(4, pos);

        const view = new DataView(b.buffer);

        return view.getUint32(0, false);
    }

    async readULE64(pos) {
        const self = this;
        const b = await self.read(8, pos);

        const view = new Uint32Array(b.buffer);

        return view[1] * 0x100000000 + view[0];
    }

    async readString(pos) {
        const self = this;

        if (self.pendingClose) {
            throw new Error("Reading a closing file");
        }

        let currentPosition = typeof pos == "undefined" ? self.pos : pos;
        let currentPage = Math.floor(currentPosition / self.pageSize);

        let endOfStringFound = false;
        let str = "";

        while (!endOfStringFound) {
            //Read page
            let pagePromise = self._loadPage(currentPage);
            self._triggerLoad();
            await pagePromise;
            self.__statusPage("After Await (read): ", currentPage);

            let offsetOnPage = currentPosition % self.pageSize;

            const dataArray = new Uint8Array(
                self.pages[currentPage].buff.buffer,
                self.pages[currentPage].buff.byteOffset + offsetOnPage,
                self.pageSize - offsetOnPage
            );

            let indexEndOfString = dataArray.findIndex(element => element === 0);
            endOfStringFound = indexEndOfString !== -1;

            if (endOfStringFound) {
                str += new TextDecoder().decode(dataArray.slice(0, indexEndOfString));
                self.pos = currentPage * this.pageSize + offsetOnPage + indexEndOfString + 1;
            } else {
                str += new TextDecoder().decode(dataArray);
                self.pos = currentPage * this.pageSize + offsetOnPage + dataArray.length;
            }

            self.pages[currentPage].pendingOps--;
            self.__statusPage("After Op done: ", currentPage);

            currentPosition = self.pos;
            currentPage++;

            if (self.pendingLoads.length > 0) setImmediate(self._triggerLoad.bind(self));
        }

        return str;
    }
}

function createNew(o) {
    const initialSize = o.initialSize || 1<<20;
    const fd = new MemFile();
    fd.o = o;
    fd.o.data = new Uint8Array(initialSize);
    fd.allocSize = initialSize;
    fd.totalSize = 0;
    fd.readOnly = false;
    fd.pos = 0;
    return fd;
}

function readExisting(o) {
    const fd = new MemFile();
    fd.o = o;
    fd.allocSize = o.data.byteLength;
    fd.totalSize = o.data.byteLength;
    fd.readOnly = true;
    fd.pos = 0;
    return fd;
}

function readWriteExisting(o) {
    const fd = new MemFile();
    fd.o = o;
    fd.allocSize = o.data.byteLength;
    fd.totalSize = o.data.byteLength;
    fd.readOnly = false;
    fd.pos = 0;
    return fd;
}

const tmpBuff32 = new Uint8Array(4);
const tmpBuff32v = new DataView(tmpBuff32.buffer);
const tmpBuff64 = new Uint8Array(8);
const tmpBuff64v = new DataView(tmpBuff64.buffer);

class MemFile {

    constructor() {
        this.pageSize = 1 << 14;  // for compatibility
    }

    _resizeIfNeeded(newLen) {
        if (newLen > this.allocSize) {
            const newAllocSize = Math.max(
                this.allocSize + (1 << 20),
                Math.floor(this.allocSize * 1.1),
                newLen
            );
            const newData = new Uint8Array(newAllocSize);
            newData.set(this.o.data);
            this.o.data = newData;
            this.allocSize = newAllocSize;
        }
    }

    async write(buff, pos) {
        const self =this;
        if (typeof pos == "undefined") pos = self.pos;
        if (this.readOnly) throw new Error("Writing a read only file");

        this._resizeIfNeeded(pos + buff.byteLength);

        this.o.data.set(buff.slice(), pos);

        if (pos + buff.byteLength > this.totalSize) this.totalSize = pos + buff.byteLength;

        this.pos = pos + buff.byteLength;
    }

    async readToBuffer(buffDest, offset, len, pos) {
        const self = this;
        if (typeof pos == "undefined") pos = self.pos;
        if (this.readOnly) {
            if (pos + len > this.totalSize) throw new Error("Reading out of bounds");
        }
        this._resizeIfNeeded(pos + len);

        const buffSrc = new Uint8Array(this.o.data.buffer, this.o.data.byteOffset + pos, len);

        buffDest.set(buffSrc, offset);

        this.pos = pos + len;
    }

    async read(len, pos) {
        const self = this;

        const buff = new Uint8Array(len);
        await self.readToBuffer(buff, 0, len, pos);

        return buff;
    }

    close() {
        if (this.o.data.byteLength != this.totalSize) {
            this.o.data = this.o.data.slice(0, this.totalSize);
        }
    }

    async discard() {
    }


    async writeULE32(v, pos) {
        const self = this;

        tmpBuff32v.setUint32(0, v, true);

        await self.write(tmpBuff32, pos);
    }

    async writeUBE32(v, pos) {
        const self = this;

        tmpBuff32v.setUint32(0, v, false);

        await self.write(tmpBuff32, pos);
    }


    async writeULE64(v, pos) {
        const self = this;

        tmpBuff64v.setUint32(0, v & 0xFFFFFFFF, true);
        tmpBuff64v.setUint32(4, Math.floor(v / 0x100000000) , true);

        await self.write(tmpBuff64, pos);
    }


    async readULE32(pos) {
        const self = this;
        const b = await self.read(4, pos);

        const view = new Uint32Array(b.buffer);

        return view[0];
    }

    async readUBE32(pos) {
        const self = this;
        const b = await self.read(4, pos);

        const view = new DataView(b.buffer);

        return view.getUint32(0, false);
    }

    async readULE64(pos) {
        const self = this;
        const b = await self.read(8, pos);

        const view = new Uint32Array(b.buffer);

        return view[1] * 0x100000000 + view[0];
    }

    async readString(pos) {
        const self = this;

        let currentPosition = typeof pos == "undefined" ? self.pos : pos;

        if (currentPosition > this.totalSize) {
            if (this.readOnly) {
                throw new Error("Reading out of bounds");
            }
            this._resizeIfNeeded(pos);
        }
        const dataArray = new Uint8Array(
            self.o.data.buffer,
            currentPosition,
            this.totalSize - currentPosition
        );

        let indexEndOfString = dataArray.findIndex(element => element === 0);
        let endOfStringFound = indexEndOfString !== -1;

        let str = "";
        if (endOfStringFound) {
            str = new TextDecoder().decode(dataArray.slice(0, indexEndOfString));
            self.pos = currentPosition + indexEndOfString + 1;
        } else {
            self.pos = currentPosition;
        }
        return str;
    }
}

const PAGE_SIZE = 1<<22;

function createNew$1(o) {
    const initialSize = o.initialSize || 0;
    const fd = new BigMemFile();
    fd.o = o;
    const nPages = initialSize ? Math.floor((initialSize - 1) / PAGE_SIZE)+1 : 0;
    fd.o.data = [];
    for (let i=0; i<nPages-1; i++) {
        fd.o.data.push( new Uint8Array(PAGE_SIZE));
    }
    if (nPages) fd.o.data.push( new Uint8Array(initialSize - PAGE_SIZE*(nPages-1)));
    fd.totalSize = 0;
    fd.readOnly = false;
    fd.pos = 0;
    return fd;
}

function readExisting$1(o) {
    const fd = new BigMemFile();
    fd.o = o;
    fd.totalSize = (o.data.length-1)* PAGE_SIZE + o.data[o.data.length-1].byteLength;
    fd.readOnly = true;
    fd.pos = 0;
    return fd;
}

function readWriteExisting$1(o) {
    const fd = new BigMemFile();
    fd.o = o;
    fd.totalSize = (o.data.length-1)* PAGE_SIZE + o.data[o.data.length-1].byteLength;
    fd.readOnly = false;
    fd.pos = 0;
    return fd;
}

const tmpBuff32$1 = new Uint8Array(4);
const tmpBuff32v$1 = new DataView(tmpBuff32$1.buffer);
const tmpBuff64$1 = new Uint8Array(8);
const tmpBuff64v$1 = new DataView(tmpBuff64$1.buffer);

class BigMemFile {

    constructor() {
        this.pageSize = 1 << 14;  // for compatibility
    }

    _resizeIfNeeded(newLen) {

        if (newLen <= this.totalSize) return;

        if (this.readOnly) throw new Error("Reading out of file bounds");

        const nPages = Math.floor((newLen - 1) / PAGE_SIZE)+1;
        for (let i= Math.max(this.o.data.length-1, 0); i<nPages; i++) {
            const newSize = i<nPages-1 ? PAGE_SIZE : newLen - (nPages-1)*PAGE_SIZE;
            const p = new Uint8Array(newSize);
            if (i == this.o.data.length-1) p.set(this.o.data[i]);
            this.o.data[i] = p;
        }
        this.totalSize = newLen;
    }

    async write(buff, pos) {
        const self =this;
        if (typeof pos == "undefined") pos = self.pos;
        if (this.readOnly) throw new Error("Writing a read only file");

        this._resizeIfNeeded(pos + buff.byteLength);

        const firstPage = Math.floor(pos / PAGE_SIZE);

        let p = firstPage;
        let o = pos % PAGE_SIZE;
        let r = buff.byteLength;
        while (r>0) {
            const l = (o+r > PAGE_SIZE) ? (PAGE_SIZE -o) : r;
            const srcView = buff.slice(buff.byteLength - r, buff.byteLength - r + l);
            const dstView = new Uint8Array(self.o.data[p].buffer, o, l);
            dstView.set(srcView);
            r = r-l;
            p ++;
            o = 0;
        }

        this.pos = pos + buff.byteLength;
    }

    async readToBuffer(buffDst, offset, len, pos) {
        const self = this;
        if (typeof pos == "undefined") pos = self.pos;
        if (this.readOnly) {
            if (pos + len > this.totalSize) throw new Error("Reading out of bounds");
        }
        this._resizeIfNeeded(pos + len);

        const firstPage = Math.floor(pos / PAGE_SIZE);

        let p = firstPage;
        let o = pos % PAGE_SIZE;
        // Remaining bytes to read
        let r = len;
        while (r>0) {
            // bytes to copy from this page
            const l = (o+r > PAGE_SIZE) ? (PAGE_SIZE -o) : r;
            const srcView = new Uint8Array(self.o.data[p].buffer, o, l);
            buffDst.set(srcView, offset+len-r);
            r = r-l;
            p ++;
            o = 0;
        }

        this.pos = pos + len;
    }

    async read(len, pos) {
        const self = this;
        const buff = new Uint8Array(len);

        await self.readToBuffer(buff, 0, len, pos);

        return buff;
    }

    close() {
    }

    async discard() {
    }


    async writeULE32(v, pos) {
        const self = this;

        tmpBuff32v$1.setUint32(0, v, true);

        await self.write(tmpBuff32$1, pos);
    }

    async writeUBE32(v, pos) {
        const self = this;

        tmpBuff32v$1.setUint32(0, v, false);

        await self.write(tmpBuff32$1, pos);
    }


    async writeULE64(v, pos) {
        const self = this;

        tmpBuff64v$1.setUint32(0, v & 0xFFFFFFFF, true);
        tmpBuff64v$1.setUint32(4, Math.floor(v / 0x100000000) , true);

        await self.write(tmpBuff64$1, pos);
    }


    async readULE32(pos) {
        const self = this;
        const b = await self.read(4, pos);

        const view = new Uint32Array(b.buffer);

        return view[0];
    }

    async readUBE32(pos) {
        const self = this;
        const b = await self.read(4, pos);

        const view = new DataView(b.buffer);

        return view.getUint32(0, false);
    }

    async readULE64(pos) {
        const self = this;
        const b = await self.read(8, pos);

        const view = new Uint32Array(b.buffer);

        return view[1] * 0x100000000 + view[0];
    }

    async readString(pos) {
        const self = this;
        const fixedSize = 2048;

        let currentPosition = typeof pos == "undefined" ? self.pos : pos;

        if (currentPosition > this.totalSize) {
            if (this.readOnly) {
                throw new Error("Reading out of bounds");
            }
            this._resizeIfNeeded(pos);
        }

        let endOfStringFound = false;
        let str = "";

        while (!endOfStringFound) {
            let currentPage = Math.floor(currentPosition / PAGE_SIZE);
            let offsetOnPage = currentPosition % PAGE_SIZE;

            if (self.o.data[currentPage] === undefined) {
                throw new Error("ERROR");
            }

            let readLength = Math.min(fixedSize, self.o.data[currentPage].length - offsetOnPage);
            const dataArray = new Uint8Array(self.o.data[currentPage].buffer, offsetOnPage, readLength);

            let indexEndOfString = dataArray.findIndex(element => element === 0);
            endOfStringFound = indexEndOfString !== -1;

            if (endOfStringFound) {
                str += new TextDecoder().decode(dataArray.slice(0, indexEndOfString));
                self.pos = currentPage * PAGE_SIZE + offsetOnPage + indexEndOfString + 1;
            } else {
                str += new TextDecoder().decode(dataArray);
                self.pos = currentPage * PAGE_SIZE + offsetOnPage + dataArray.length;
            }

            currentPosition = self.pos;
        }
        return str;
    }
}

/* global fetch */

const DEFAULT_CACHE_SIZE = (1 << 16);
const DEFAULT_PAGE_SIZE = (1 << 13);


async function createOverride(o, b, c) {
    if (typeof o === "string") {
        o = {
            type: "file",
            fileName: o,
            cacheSize: b || DEFAULT_CACHE_SIZE,
            pageSize: c || DEFAULT_PAGE_SIZE
        };
    }
    if (o.type == "file") {
        return await open(o.fileName, constants.O_TRUNC | constants.O_CREAT | constants.O_RDWR, o.cacheSize, o.pageSize);
    } else if (o.type == "mem") {
        return createNew(o);
    } else if (o.type == "bigMem") {
        return createNew$1(o);
    } else {
        throw new Error("Invalid FastFile type: "+o.type);
    }
}

function createNoOverride(o, b, c) {
    if (typeof o === "string") {
        o = {
            type: "file",
            fileName: o,
            cacheSize: b || DEFAULT_CACHE_SIZE,
            pageSize: c || DEFAULT_PAGE_SIZE
        };
    }
    if (o.type == "file") {
        return open(o.fileName, constants.O_TRUNC | constants.O_CREAT | constants.O_RDWR | constants.O_EXCL, o.cacheSize, o.pageSize);
    } else if (o.type == "mem") {
        return createNew(o);
    } else if (o.type == "bigMem") {
        return createNew$1(o);
    } else {
        throw new Error("Invalid FastFile type: "+o.type);
    }
}

async function readExisting$2(o, b, c) {
    if (o instanceof Uint8Array) {
        o = {
            type: "mem",
            data: o
        };
    }
    if (process.browser) {
        if (typeof o === "string") {
            const buff = await fetch(o).then( function(res) {
                return res.arrayBuffer();
            }).then(function (ab) {
                return new Uint8Array(ab);
            });
            o = {
                type: "mem",
                data: buff
            };
        }
    } else {
        if (typeof o === "string") {
            o = {
                type: "file",
                fileName: o,
                cacheSize: b || DEFAULT_CACHE_SIZE,
                pageSize: c || DEFAULT_PAGE_SIZE
            };
        }
    }
    if (o.type == "file") {
        return await open(o.fileName, constants.O_RDONLY, o.cacheSize, o.pageSize);
    } else if (o.type == "mem") {
        return await readExisting(o);
    } else if (o.type == "bigMem") {
        return await readExisting$1(o);
    } else {
        throw new Error("Invalid FastFile type: "+o.type);
    }
}

function readWriteExisting$2(o, b, c) {
    if (typeof o === "string") {
        o = {
            type: "file",
            fileName: o,
            cacheSize: b || DEFAULT_CACHE_SIZE,
            pageSize: c || DEFAULT_PAGE_SIZE
        };
    }
    if (o.type == "file") {
        return open(o.fileName, constants.O_CREAT | constants.O_RDWR, o.cacheSize, o.pageSize);
    } else if (o.type == "mem") {
        return readWriteExisting(o);
    } else if (o.type == "bigMem") {
        return readWriteExisting$1(o);
    } else {
        throw new Error("Invalid FastFile type: "+o.type);
    }
}

function readWriteExistingOrCreate(o, b, c) {
    if (typeof o === "string") {
        o = {
            type: "file",
            fileName: o,
            cacheSize: b || DEFAULT_CACHE_SIZE,
            pageSize: c || DEFAULT_PAGE_SIZE
        };
    }
    if (o.type == "file") {
        return open(o.fileName, constants.O_CREAT | constants.O_RDWR | constants.O_EXCL, o.cacheSize);
    } else if (o.type == "mem") {
        return readWriteExisting(o);
    } else if (o.type == "bigMem") {
        return readWriteExisting$1(o);
    } else {
        throw new Error("Invalid FastFile type: "+o.type);
    }
}

main.createNoOverride = createNoOverride;
var createOverride_1 = main.createOverride = createOverride;
var readExisting_1 = main.readExisting = readExisting$2;
main.readWriteExisting = readWriteExisting$2;
main.readWriteExistingOrCreate = readWriteExistingOrCreate;

Object.defineProperty(main$1, '__esModule', { value: true });

var ffjavascript = require$$0$1;
var fastFile = main;

function _interopNamespace$1(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var fastFile__namespace = /*#__PURE__*/_interopNamespace$1(fastFile);

async function readBinFile(fileName, type, maxVersion, cacheSize, pageSize) {

    const fd = await fastFile__namespace.readExisting(fileName, cacheSize, pageSize);

    const b = await fd.read(4);
    let readedType = "";
    for (let i=0; i<4; i++) readedType += String.fromCharCode(b[i]);

    if (readedType != type) throw new Error(fileName + ": Invalid File format");

    let v = await fd.readULE32();

    if (v>maxVersion) throw new Error("Version not supported");

    const nSections = await fd.readULE32();

    // Scan sections
    let sections = [];
    for (let i=0; i<nSections; i++) {
        let ht = await fd.readULE32();
        let hl = await fd.readULE64();
        if (typeof sections[ht] == "undefined") sections[ht] = [];
        sections[ht].push({
            p: fd.pos,
            size: hl
        });
        fd.pos += hl;
    }

    return {fd, sections};
}

async function createBinFile(fileName, type, version, nSections, cacheSize, pageSize) {

    const fd = await fastFile__namespace.createOverride(fileName, cacheSize, pageSize);

    const buff = new Uint8Array(4);
    for (let i=0; i<4; i++) buff[i] = type.charCodeAt(i);
    await fd.write(buff, 0); // Magic "r1cs"

    await fd.writeULE32(version); // Version
    await fd.writeULE32(nSections); // Number of Sections

    return fd;
}

async function startWriteSection(fd, idSection) {
    if (typeof fd.writingSection !== "undefined") throw new Error("Already writing a section");
    await fd.writeULE32(idSection); // Header type
    fd.writingSection = {
        pSectionSize: fd.pos
    };
    await fd.writeULE64(0); // Temporally set to 0 length
}

async function endWriteSection(fd) {
    if (typeof fd.writingSection === "undefined") throw new Error("Not writing a section");

    const sectionSize = fd.pos - fd.writingSection.pSectionSize - 8;
    const oldPos = fd.pos;
    fd.pos = fd.writingSection.pSectionSize;
    await fd.writeULE64(sectionSize);
    fd.pos = oldPos;
    delete fd.writingSection;
}

async function startReadUniqueSection(fd, sections, idSection) {
    if (typeof fd.readingSection !== "undefined") throw new Error("Already reading a section");
    if (!sections[idSection])  throw new Error(fd.fileName + ": Missing section "+ idSection );
    if (sections[idSection].length>1) throw new Error(fd.fileName +": Section Duplicated " +idSection);

    fd.pos = sections[idSection][0].p;

    fd.readingSection = sections[idSection][0];
}

async function endReadSection(fd, noCheck) {
    if (typeof fd.readingSection === "undefined") throw new Error("Not reading a section");
    if (!noCheck) {
        if (fd.pos-fd.readingSection.p !=  fd.readingSection.size) throw new Error("Invalid section size reading");
    }
    delete fd.readingSection;
}

async function writeBigInt(fd, n, n8, pos) {
    const buff = new Uint8Array(n8);
    ffjavascript.Scalar.toRprLE(buff, 0, n, n8);
    await fd.write(buff, pos);
}

async function readBigInt(fd, n8, pos) {
    const buff = await fd.read(n8, pos);
    return ffjavascript.Scalar.fromRprLE(buff, 0, n8);
}

async function copySection(fdFrom, sections, fdTo, sectionId, size) {
    if (typeof size === "undefined") {
        size = sections[sectionId][0].size;
    }
    const chunkSize = fdFrom.pageSize;
    await startReadUniqueSection(fdFrom, sections, sectionId);
    await startWriteSection(fdTo, sectionId);
    for (let p=0; p<size; p+=chunkSize) {
        const l = Math.min(size -p, chunkSize);
        const buff = await fdFrom.read(l);
        await fdTo.write(buff);
    }
    await endWriteSection(fdTo);
    await endReadSection(fdFrom, size != sections[sectionId][0].size);

}

async function readSection(fd, sections, idSection, offset, length) {

    offset = (typeof offset === "undefined") ? 0 : offset;
    length = (typeof length === "undefined") ? sections[idSection][0].size - offset : length;

    if (offset + length > sections[idSection][0].size) {
        throw new Error("Reading out of the range of the section");
    }

    let buff;
    if (length < (1 << 30) ) {
        buff = new Uint8Array(length);
    } else {
        buff = new ffjavascript.BigBuffer(length);
    }

    await fd.readToBuffer(buff, 0, length, sections[idSection][0].p + offset);
    return buff;
}

async function sectionIsEqual(fd1, sections1, fd2, sections2, idSection) {
    const MAX_BUFF_SIZE = fd1.pageSize * 16;
    await startReadUniqueSection(fd1, sections1, idSection);
    await startReadUniqueSection(fd2, sections2, idSection);
    if (sections1[idSection][0].size != sections2[idSection][0].size) return false;
    const totalBytes=sections1[idSection][0].size;
    for (let i=0; i<totalBytes; i+= MAX_BUFF_SIZE) {
        const n = Math.min(totalBytes-i, MAX_BUFF_SIZE);
        const buff1 = await fd1.read(n);
        const buff2 = await fd2.read(n);
        for (let j=0; j<n; j++) if (buff1[j] != buff2[j]) return false;
    }
    await endReadSection(fd1);
    await endReadSection(fd2);
    return true;
}

main$1.copySection = copySection;
var createBinFile_1 = main$1.createBinFile = createBinFile;
var endReadSection_1 = main$1.endReadSection = endReadSection;
var endWriteSection_1 = main$1.endWriteSection = endWriteSection;
var readBigInt_1 = main$1.readBigInt = readBigInt;
var readBinFile_1 = main$1.readBinFile = readBinFile;
var readSection_1 = main$1.readSection = readSection;
main$1.sectionIsEqual = sectionIsEqual;
var startReadUniqueSection_1 = main$1.startReadUniqueSection = startReadUniqueSection;
var startWriteSection_1 = main$1.startWriteSection = startWriteSection;
var writeBigInt_1 = main$1.writeBigInt = writeBigInt;

/* eslint-disable import/prefer-default-export */
/* eslint-disable no-return-assign */
/* istanbul ignore file */
function log2(V) {
    return (((V & 0xffff0000) !== 0 ? ((V &= 0xffff0000), 16) : 0) |
        ((V & 0xff00ff00) !== 0 ? ((V &= 0xff00ff00), 8) : 0) |
        ((V & 0xf0f0f0f0) !== 0 ? ((V &= 0xf0f0f0f0), 4) : 0) |
        ((V & 0xcccccccc) !== 0 ? ((V &= 0xcccccccc), 2) : 0) |
        // @ts-ignore
        ((V & 0xaaaaaaaa) !== 0));
}

/* eslint-disable import/prefer-default-export */
/* istanbul ignore file */
function readG1(fd, curve, toObject) {
    return __awaiter(this, void 0, void 0, function () {
        var buff, res;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, fd.read(curve.G1.F.n8 * 2)];
                case 1:
                    buff = _a.sent();
                    res = curve.G1.fromRprLEM(buff, 0);
                    return [2 /*return*/, toObject ? curve.G1.toObject(res) : res];
            }
        });
    });
}
function readG2(fd, curve, toObject) {
    return __awaiter(this, void 0, void 0, function () {
        var buff, res;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, fd.read(curve.G2.F.n8 * 2)];
                case 1:
                    buff = _a.sent();
                    res = curve.G2.fromRprLEM(buff, 0);
                    return [2 /*return*/, toObject ? curve.G2.toObject(res) : res];
            }
        });
    });
}
function readHeaderGroth16(fd, sections, toObject) {
    var _a;
    return __awaiter(this, void 0, void 0, function () {
        var zkey, n8q, _b, n8r, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        return __generator(this, function (_q) {
            switch (_q.label) {
                case 0:
                    zkey = {};
                    zkey.protocol = "groth16";
                    return [4 /*yield*/, startReadUniqueSection_1(fd, sections, 2)];
                case 1:
                    _q.sent();
                    return [4 /*yield*/, fd.readULE32()];
                case 2:
                    n8q = _q.sent();
                    zkey.n8q = n8q;
                    _b = zkey;
                    return [4 /*yield*/, readBigInt_1(fd, n8q)];
                case 3:
                    _b.q = _q.sent();
                    return [4 /*yield*/, fd.readULE32()];
                case 4:
                    n8r = _q.sent();
                    zkey.n8r = n8r;
                    _c = zkey;
                    return [4 /*yield*/, readBigInt_1(fd, n8r)
                        // @ts-ignore
                    ];
                case 5:
                    _c.r = _q.sent();
                    // @ts-ignore
                    _d = zkey;
                    if (!((_a = globalThis.curve_bn128) !== null && _a !== void 0)) return [3 /*break*/, 6];
                    _e = _a;
                    return [3 /*break*/, 8];
                case 6: return [4 /*yield*/, ffjavascript$1.buildBn128(undefined, undefined)];
                case 7:
                    _e = (_q.sent());
                    _q.label = 8;
                case 8:
                    // @ts-ignore
                    _d.curve = _e;
                    _f = zkey;
                    return [4 /*yield*/, fd.readULE32()];
                case 9:
                    _f.nVars = _q.sent();
                    _g = zkey;
                    return [4 /*yield*/, fd.readULE32()];
                case 10:
                    _g.nPublic = _q.sent();
                    _h = zkey;
                    return [4 /*yield*/, fd.readULE32()];
                case 11:
                    _h.domainSize = _q.sent();
                    zkey.power = log2(zkey.domainSize);
                    _j = zkey;
                    return [4 /*yield*/, readG1(fd, zkey.curve, toObject)];
                case 12:
                    _j.vk_alpha_1 = _q.sent();
                    _k = zkey;
                    return [4 /*yield*/, readG1(fd, zkey.curve, toObject)];
                case 13:
                    _k.vk_beta_1 = _q.sent();
                    _l = zkey;
                    return [4 /*yield*/, readG2(fd, zkey.curve, toObject)];
                case 14:
                    _l.vk_beta_2 = _q.sent();
                    _m = zkey;
                    return [4 /*yield*/, readG2(fd, zkey.curve, toObject)];
                case 15:
                    _m.vk_gamma_2 = _q.sent();
                    _o = zkey;
                    return [4 /*yield*/, readG1(fd, zkey.curve, toObject)];
                case 16:
                    _o.vk_delta_1 = _q.sent();
                    _p = zkey;
                    return [4 /*yield*/, readG2(fd, zkey.curve, toObject)];
                case 17:
                    _p.vk_delta_2 = _q.sent();
                    return [4 /*yield*/, endReadSection_1(fd)];
                case 18:
                    _q.sent();
                    return [2 /*return*/, zkey];
            }
        });
    });
}
function readHeader$1(fd, sections, toObject) {
    return __awaiter(this, void 0, void 0, function () {
        var protocolId;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, startReadUniqueSection_1(fd, sections, 1)];
                case 1:
                    _a.sent();
                    return [4 /*yield*/, fd.readULE32()];
                case 2:
                    protocolId = _a.sent();
                    return [4 /*yield*/, endReadSection_1(fd)];
                case 3:
                    _a.sent();
                    if (protocolId === 1) {
                        return [2 /*return*/, readHeaderGroth16(fd, sections, toObject)];
                    }
                    throw new Error("Protocol not supported: ");
            }
        });
    });
}

/* eslint-disable eqeqeq */
/* istanbul ignore file */
function writeBin(fd, witnessBin, prime) {
    return __awaiter(this, void 0, void 0, function () {
        var n8;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, startWriteSection_1(fd, 1)];
                case 1:
                    _a.sent();
                    n8 = (Math.floor((ffjavascript$1.Scalar.bitLength(prime) - 1) / 64) + 1) * 8;
                    return [4 /*yield*/, fd.writeULE32(n8)];
                case 2:
                    _a.sent();
                    return [4 /*yield*/, writeBigInt_1(fd, prime, n8)];
                case 3:
                    _a.sent();
                    if (witnessBin.byteLength % n8 != 0) {
                        throw new Error("Invalid witness length");
                    }
                    return [4 /*yield*/, fd.writeULE32(witnessBin.byteLength / n8)];
                case 4:
                    _a.sent();
                    return [4 /*yield*/, endWriteSection_1(fd)];
                case 5:
                    _a.sent();
                    return [4 /*yield*/, startWriteSection_1(fd, 2)];
                case 6:
                    _a.sent();
                    return [4 /*yield*/, fd.write(witnessBin)];
                case 7:
                    _a.sent();
                    return [4 /*yield*/, endWriteSection_1(fd)];
                case 8:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
function readHeader(fd, sections) {
    return __awaiter(this, void 0, void 0, function () {
        var n8, q, nWitness;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, startReadUniqueSection_1(fd, sections, 1)];
                case 1:
                    _a.sent();
                    return [4 /*yield*/, fd.readULE32()];
                case 2:
                    n8 = _a.sent();
                    return [4 /*yield*/, readBigInt_1(fd, n8)];
                case 3:
                    q = _a.sent();
                    return [4 /*yield*/, fd.readULE32()];
                case 4:
                    nWitness = _a.sent();
                    return [4 /*yield*/, endReadSection_1(fd)];
                case 5:
                    _a.sent();
                    return [2 /*return*/, { n8: n8, q: q, nWitness: nWitness }];
            }
        });
    });
}

/* eslint-disable eqeqeq */
/* istanbul ignore file */
var unstringifyBigInts$2 = ffjavascript$1.utils.unstringifyBigInts;
function wtnsCalculate(_input, wasmFileName, wtnsFileName) {
    return __awaiter(this, void 0, void 0, function () {
        var input, fdWasm, wasm, wc, w, fdWtns, fdWtns, w;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    input = unstringifyBigInts$2(_input);
                    return [4 /*yield*/, readExisting_1(wasmFileName)];
                case 1:
                    fdWasm = _a.sent();
                    return [4 /*yield*/, fdWasm.read(fdWasm.totalSize)];
                case 2:
                    wasm = _a.sent();
                    return [4 /*yield*/, fdWasm.close()];
                case 3:
                    _a.sent();
                    return [4 /*yield*/, circom_runtime.WitnessCalculatorBuilder(wasm)];
                case 4:
                    wc = _a.sent();
                    if (!(wc.circom_version() == 1)) return [3 /*break*/, 9];
                    return [4 /*yield*/, wc.calculateBinWitness(input)];
                case 5:
                    w = _a.sent();
                    return [4 /*yield*/, createBinFile_1(wtnsFileName, "wtns", 2, 2)];
                case 6:
                    fdWtns = _a.sent();
                    return [4 /*yield*/, writeBin(fdWtns, w, wc.prime)];
                case 7:
                    _a.sent();
                    return [4 /*yield*/, fdWtns.close()];
                case 8:
                    _a.sent();
                    return [3 /*break*/, 14];
                case 9: return [4 /*yield*/, createOverride_1(wtnsFileName)];
                case 10:
                    fdWtns = _a.sent();
                    return [4 /*yield*/, wc.calculateWTNSBin(input)];
                case 11:
                    w = _a.sent();
                    return [4 /*yield*/, fdWtns.write(w)];
                case 12:
                    _a.sent();
                    return [4 /*yield*/, fdWtns.close()];
                case 13:
                    _a.sent();
                    _a.label = 14;
                case 14: return [2 /*return*/];
            }
        });
    });
}

/* eslint-disable no-plusplus */
/* eslint-disable eqeqeq */
/* eslint-disable @typescript-eslint/naming-convention */
/* istanbul ignore file */
var stringifyBigInts = ffjavascript$1.utils.stringifyBigInts, unstringifyBigInts$1 = ffjavascript$1.utils.unstringifyBigInts;
function buildABC1(curve, zkey, witness, coeffs) {
    return __awaiter(this, void 0, void 0, function () {
        var n8, sCoef, nCoef, outBuffA, outBuffB, outBuffC, outBuf, i, buffCoef, buffCoefV, m, c, s, coef, i;
        return __generator(this, function (_a) {
            n8 = curve.Fr.n8;
            sCoef = 4 * 3 + zkey.n8r;
            nCoef = (coeffs.byteLength - 4) / sCoef;
            outBuffA = new ffjavascript$1.BigBuffer(zkey.domainSize * n8);
            outBuffB = new ffjavascript$1.BigBuffer(zkey.domainSize * n8);
            outBuffC = new ffjavascript$1.BigBuffer(zkey.domainSize * n8);
            outBuf = [outBuffA, outBuffB];
            for (i = 0; i < nCoef; i++) {
                buffCoef = coeffs.slice(4 + i * sCoef, 4 + i * sCoef + sCoef);
                buffCoefV = new DataView(buffCoef.buffer);
                m = buffCoefV.getUint32(0, true);
                c = buffCoefV.getUint32(4, true);
                s = buffCoefV.getUint32(8, true);
                coef = buffCoef.slice(12, 12 + n8);
                outBuf[m].set(curve.Fr.add(outBuf[m].slice(c * n8, c * n8 + n8), curve.Fr.mul(coef, witness.slice(s * n8, s * n8 + n8))), c * n8);
            }
            for (i = 0; i < zkey.domainSize; i++) {
                outBuffC.set(curve.Fr.mul(outBuffA.slice(i * n8, i * n8 + n8), outBuffB.slice(i * n8, i * n8 + n8)), i * n8);
            }
            return [2 /*return*/, [outBuffA, outBuffB, outBuffC]];
        });
    });
}
function joinABC(curve, _zkey, a, b, c) {
    return __awaiter(this, void 0, void 0, function () {
        var MAX_CHUNK_SIZE, n8, nElements, promises, i, n, task, aChunk, bChunk, cChunk, result, outBuff, p, i;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    MAX_CHUNK_SIZE = 1 << 22;
                    n8 = curve.Fr.n8;
                    nElements = Math.floor(a.byteLength / curve.Fr.n8);
                    promises = [];
                    for (i = 0; i < nElements; i += MAX_CHUNK_SIZE) {
                        n = Math.min(nElements - i, MAX_CHUNK_SIZE);
                        task = [];
                        aChunk = a.slice(i * n8, (i + n) * n8);
                        bChunk = b.slice(i * n8, (i + n) * n8);
                        cChunk = c.slice(i * n8, (i + n) * n8);
                        task.push({ cmd: "ALLOCSET", var: 0, buff: aChunk });
                        task.push({ cmd: "ALLOCSET", var: 1, buff: bChunk });
                        task.push({ cmd: "ALLOCSET", var: 2, buff: cChunk });
                        task.push({ cmd: "ALLOC", var: 3, len: n * n8 });
                        task.push({
                            cmd: "CALL",
                            fnName: "qap_joinABC",
                            params: [{ var: 0 }, { var: 1 }, { var: 2 }, { val: n }, { var: 3 }]
                        });
                        task.push({ cmd: "CALL", fnName: "frm_batchFromMontgomery", params: [{ var: 3 }, { val: n }, { var: 3 }] });
                        task.push({ cmd: "GET", out: 0, var: 3, len: n * n8 });
                        promises.push(curve.tm.queueAction(task));
                    }
                    return [4 /*yield*/, Promise.all(promises)];
                case 1:
                    result = _a.sent();
                    if (a instanceof ffjavascript$1.BigBuffer) {
                        // @ts-ignore
                        outBuff = new ffjavascript$1.BigBuffer(a.byteLength);
                    }
                    else {
                        outBuff = new Uint8Array(a.byteLength);
                    }
                    p = 0;
                    for (i = 0; i < result.length; i++) {
                        outBuff.set(result[i][0], p);
                        p += result[i][0].byteLength;
                    }
                    return [2 /*return*/, outBuff];
            }
        });
    });
}
/**
 * Creates a Groth16 proof composed of public signals and zero-knowledge parameters.
 * @param input Input signals of the circuit.
 * @param wasmFile WASM file of the circuit.
 * @param zkeyFile ZKey file of the circuit.
 * @returns A proof containing public signals and zero-knowledge parameters.
 */
function prove(input, wasmFile, zkeyFile) {
    return __awaiter(this, void 0, void 0, function () {
        var witnessFileName, _a, fdWtns, sectionsWtns, wtns, _b, fdZKey, sectionsZKey, zkey, curve, Fr, G1, G2, power, buffWitness, buffCoeffs, _c, buffA_T, buffB_T, buffC_T, inc, buffA, buffAodd, buffAodd_T, buffB, buffBodd, buffBodd_T, buffC, buffCodd, buffCodd_T, buffPodd_T, proof, buffBasesA, _d, buffBasesB1, pib1, buffBasesB2, _e, buffBasesC, _f, buffBasesH, resH, r, s, publicSignals, i, b;
        return __generator(this, function (_g) {
            switch (_g.label) {
                case 0:
                    input = unstringifyBigInts$1(input);
                    witnessFileName = {
                        type: "mem"
                    };
                    return [4 /*yield*/, wtnsCalculate(input, wasmFile, witnessFileName)];
                case 1:
                    _g.sent();
                    return [4 /*yield*/, readBinFile_1(witnessFileName, "wtns", 2, 1 << 25, 1 << 23)];
                case 2:
                    _a = _g.sent(), fdWtns = _a.fd, sectionsWtns = _a.sections;
                    return [4 /*yield*/, readHeader(fdWtns, sectionsWtns)];
                case 3:
                    wtns = _g.sent();
                    return [4 /*yield*/, readBinFile_1(zkeyFile, "zkey", 2, 1 << 25, 1 << 23)];
                case 4:
                    _b = _g.sent(), fdZKey = _b.fd, sectionsZKey = _b.sections;
                    return [4 /*yield*/, readHeader$1(fdZKey, sectionsZKey, undefined)];
                case 5:
                    zkey = _g.sent();
                    if (zkey.protocol !== "groth16") {
                        throw new Error("zkey file is not groth16");
                    }
                    if (!ffjavascript$1.Scalar.eq(zkey.r, wtns.q)) {
                        throw new Error("Curve of the witness does not match the curve of the proving key");
                    }
                    if (wtns.nWitness !== zkey.nVars) {
                        throw new Error("Invalid witness length. Circuit: ".concat(zkey.nVars, ", witness: ").concat(wtns.nWitness));
                    }
                    curve = zkey.curve;
                    Fr = curve.Fr;
                    G1 = curve.G1;
                    G2 = curve.G2;
                    power = log2(zkey.domainSize);
                    return [4 /*yield*/, readSection_1(fdWtns, sectionsWtns, 2)];
                case 6:
                    buffWitness = _g.sent();
                    return [4 /*yield*/, readSection_1(fdZKey, sectionsZKey, 4)];
                case 7:
                    buffCoeffs = _g.sent();
                    return [4 /*yield*/, buildABC1(curve, zkey, buffWitness, buffCoeffs)];
                case 8:
                    _c = _g.sent(), buffA_T = _c[0], buffB_T = _c[1], buffC_T = _c[2];
                    inc = power == Fr.s ? curve.Fr.shift : curve.Fr.w[power + 1];
                    return [4 /*yield*/, Fr.ifft(buffA_T, "", "", undefined, "IFFT_A")];
                case 9:
                    buffA = _g.sent();
                    return [4 /*yield*/, Fr.batchApplyKey(buffA, Fr.e(1), inc)];
                case 10:
                    buffAodd = _g.sent();
                    return [4 /*yield*/, Fr.fft(buffAodd, "", "", undefined, "FFT_A")];
                case 11:
                    buffAodd_T = _g.sent();
                    return [4 /*yield*/, Fr.ifft(buffB_T, "", "", undefined, "IFFT_B")];
                case 12:
                    buffB = _g.sent();
                    return [4 /*yield*/, Fr.batchApplyKey(buffB, Fr.e(1), inc)];
                case 13:
                    buffBodd = _g.sent();
                    return [4 /*yield*/, Fr.fft(buffBodd, "", "", undefined, "FFT_B")];
                case 14:
                    buffBodd_T = _g.sent();
                    return [4 /*yield*/, Fr.ifft(buffC_T, "", "", undefined, "IFFT_C")];
                case 15:
                    buffC = _g.sent();
                    return [4 /*yield*/, Fr.batchApplyKey(buffC, Fr.e(1), inc)];
                case 16:
                    buffCodd = _g.sent();
                    return [4 /*yield*/, Fr.fft(buffCodd, "", "", undefined, "FFT_C")];
                case 17:
                    buffCodd_T = _g.sent();
                    return [4 /*yield*/, joinABC(curve, zkey, buffAodd_T, buffBodd_T, buffCodd_T)];
                case 18:
                    buffPodd_T = _g.sent();
                    proof = {};
                    return [4 /*yield*/, readSection_1(fdZKey, sectionsZKey, 5)];
                case 19:
                    buffBasesA = _g.sent();
                    _d = proof;
                    return [4 /*yield*/, curve.G1.multiExpAffine(buffBasesA, buffWitness, undefined, "multiexp A")];
                case 20:
                    _d.pi_a = _g.sent();
                    return [4 /*yield*/, readSection_1(fdZKey, sectionsZKey, 6)];
                case 21:
                    buffBasesB1 = _g.sent();
                    return [4 /*yield*/, curve.G1.multiExpAffine(buffBasesB1, buffWitness, undefined, "multiexp B1")];
                case 22:
                    pib1 = _g.sent();
                    return [4 /*yield*/, readSection_1(fdZKey, sectionsZKey, 7)];
                case 23:
                    buffBasesB2 = _g.sent();
                    _e = proof;
                    return [4 /*yield*/, curve.G2.multiExpAffine(buffBasesB2, buffWitness, undefined, "multiexp B2")];
                case 24:
                    _e.pi_b = _g.sent();
                    return [4 /*yield*/, readSection_1(fdZKey, sectionsZKey, 8)];
                case 25:
                    buffBasesC = _g.sent();
                    _f = proof;
                    return [4 /*yield*/, curve.G1.multiExpAffine(buffBasesC, buffWitness.slice((zkey.nPublic + 1) * curve.Fr.n8), undefined, "multiexp C")];
                case 26:
                    _f.pi_c = _g.sent();
                    return [4 /*yield*/, readSection_1(fdZKey, sectionsZKey, 9)];
                case 27:
                    buffBasesH = _g.sent();
                    return [4 /*yield*/, curve.G1.multiExpAffine(buffBasesH, buffPodd_T, undefined, "multiexp H")];
                case 28:
                    resH = _g.sent();
                    r = curve.Fr.random();
                    s = curve.Fr.random();
                    proof.pi_a = G1.add(proof.pi_a, zkey.vk_alpha_1);
                    proof.pi_a = G1.add(proof.pi_a, G1.timesFr(zkey.vk_delta_1, r));
                    proof.pi_b = G2.add(proof.pi_b, zkey.vk_beta_2);
                    proof.pi_b = G2.add(proof.pi_b, G2.timesFr(zkey.vk_delta_2, s));
                    pib1 = G1.add(pib1, zkey.vk_beta_1);
                    pib1 = G1.add(pib1, G1.timesFr(zkey.vk_delta_1, s));
                    proof.pi_c = G1.add(proof.pi_c, resH);
                    proof.pi_c = G1.add(proof.pi_c, G1.timesFr(proof.pi_a, s));
                    proof.pi_c = G1.add(proof.pi_c, G1.timesFr(pib1, r));
                    proof.pi_c = G1.add(proof.pi_c, G1.timesFr(zkey.vk_delta_1, Fr.neg(Fr.mul(r, s))));
                    publicSignals = [];
                    for (i = 1; i <= zkey.nPublic; i++) {
                        b = buffWitness.slice(i * Fr.n8, i * Fr.n8 + Fr.n8);
                        publicSignals.push(ffjavascript$1.Scalar.fromRprLE(b, undefined, undefined));
                    }
                    proof.pi_a = G1.toObject(G1.toAffine(proof.pi_a));
                    proof.pi_b = G2.toObject(G2.toAffine(proof.pi_b));
                    proof.pi_c = G1.toObject(G1.toAffine(proof.pi_c));
                    proof.protocol = "groth16";
                    proof.curve = curve.name;
                    return [4 /*yield*/, fdZKey.close()];
                case 29:
                    _g.sent();
                    return [4 /*yield*/, fdWtns.close()];
                case 30:
                    _g.sent();
                    proof = stringifyBigInts(proof);
                    publicSignals = stringifyBigInts(publicSignals);
                    return [2 /*return*/, { proof: proof, publicSignals: publicSignals }];
            }
        });
    });
}

/* eslint-disable no-plusplus */
/* eslint-disable @typescript-eslint/naming-convention */
/* istanbul ignore file */
var unstringifyBigInts = ffjavascript$1.utils.unstringifyBigInts;
function isWellConstructed(curve, proof) {
    var G1 = curve.G1;
    var G2 = curve.G2;
    return G1.isValid(proof.pi_a) && G2.isValid(proof.pi_b) && G1.isValid(proof.pi_c);
}
function publicInputsAreValid(curve, publicInputs) {
    for (var i = 0; i < publicInputs.length; i++) {
        if (!ffjavascript$1.Scalar.lt(publicInputs[i], curve.r)) {
            return false;
        }
    }
    return true;
}
/**
 * Verifies if a Groth16 proof is valid or not.
 * @param verificationKey The verification key used to verify the proof.
 * @param proof The proof containing public signals and zero-knowledge parameters.
 * @returns True if the proof is valid, and false otherwise.
 */
function verify(verificationKey, _a) {
    var _b;
    var proof = _a.proof, publicSignals = _a.publicSignals;
    return __awaiter(this, void 0, void 0, function () {
        var curve, _c, IC0, IC, w, i, buffP, cpub, pi_a, pi_b, pi_c, vk_gamma_2, vk_delta_2, vk_alpha_1, vk_beta_2;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    verificationKey = unstringifyBigInts(verificationKey);
                    proof = unstringifyBigInts(proof);
                    publicSignals = unstringifyBigInts(publicSignals);
                    if (!((_b = globalThis.curve_bn128) !== null && _b !== void 0)) return [3 /*break*/, 1];
                    _c = _b;
                    return [3 /*break*/, 3];
                case 1: return [4 /*yield*/, ffjavascript$1.buildBn128(undefined, undefined)];
                case 2:
                    _c = (_d.sent());
                    _d.label = 3;
                case 3:
                    curve = _c;
                    IC0 = curve.G1.fromObject(verificationKey.IC[0]);
                    IC = new Uint8Array(curve.G1.F.n8 * 2 * publicSignals.length);
                    w = new Uint8Array(curve.Fr.n8 * publicSignals.length);
                    if (!publicInputsAreValid(curve, publicSignals)) {
                        return [2 /*return*/, false];
                    }
                    for (i = 0; i < publicSignals.length; i++) {
                        buffP = curve.G1.fromObject(verificationKey.IC[i + 1]);
                        IC.set(buffP, i * curve.G1.F.n8 * 2);
                        ffjavascript$1.Scalar.toRprLE(w, curve.Fr.n8 * i, publicSignals[i], curve.Fr.n8);
                    }
                    return [4 /*yield*/, curve.G1.multiExpAffine(IC, w)];
                case 4:
                    cpub = _d.sent();
                    cpub = curve.G1.add(cpub, IC0);
                    pi_a = curve.G1.fromObject(proof.pi_a);
                    pi_b = curve.G2.fromObject(proof.pi_b);
                    pi_c = curve.G1.fromObject(proof.pi_c);
                    if (!isWellConstructed(curve, { pi_a: pi_a, pi_b: pi_b, pi_c: pi_c })) {
                        return [2 /*return*/, false];
                    }
                    vk_gamma_2 = curve.G2.fromObject(verificationKey.vk_gamma_2);
                    vk_delta_2 = curve.G2.fromObject(verificationKey.vk_delta_2);
                    vk_alpha_1 = curve.G1.fromObject(verificationKey.vk_alpha_1);
                    vk_beta_2 = curve.G2.fromObject(verificationKey.vk_beta_2);
                    return [2 /*return*/, curve.pairingEq(curve.G1.neg(pi_a), pi_b, cpub, vk_gamma_2, pi_c, vk_delta_2, vk_alpha_1, vk_beta_2)];
            }
        });
    });
}

exports.prove = prove;
exports.verify = verify;
