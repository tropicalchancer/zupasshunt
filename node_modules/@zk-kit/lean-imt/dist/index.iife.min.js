/**
 * @module @zk-kit/lean-imt
 * @version 2.2.3
 * @file Lean Incremental Merkle tree implementation in TypeScript.
 * @copyright Ethereum Foundation 2025
 * @license MIT
 * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/lean-imt}
*/
var zkKitLeanImt=function(e){"use strict";
/**
     * @module @zk-kit/utils
     * @version 1.3.0
     * @file Essential zero-knowledge utility library for JavaScript developers.
     * @copyright Ethereum Foundation 2025
     * @license MIT
     * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/utils}
    */
/**
     * @module @zk-kit/utils
     * @version 1.3.0
     * @file Essential zero-knowledge utility library for JavaScript developers.
     * @copyright Ethereum Foundation 2025
     * @license MIT
     * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/utils}
    */
function t(e,t){if(void 0===e)throw new TypeError(`Parameter '${t}' is not defined`)}function s(e,t){if("number"!=typeof e)throw new TypeError(`Parameter '${t}' is not a number, received type: ${typeof e}`)}function n(e,t){if("function"!=typeof e)throw new TypeError(`Parameter '${t}' is not a function, received type: ${typeof e}`)}function i(e,t){if(!function(e){return"object"==typeof e}(s=e)||!Array.isArray(s))throw new TypeError(`Parameter '${t}' is not an Array instance`);var s}class o{constructor(e,s=[]){t(e,"hash"),n(e,"hash"),i(s,"leaves"),this._nodes=[[]],this._hash=e,s.length>0&&this.insertMany(s)}get root(){return this._nodes[this.depth][0]}get depth(){return this._nodes.length-1}get leaves(){return this._nodes[0].slice()}get size(){return this._nodes[0].length}indexOf(e){return t(e,"leaf"),this._nodes[0].indexOf(e)}has(e){return t(e,"leaf"),this._nodes[0].includes(e)}insert(e){t(e,"leaf"),this.depth<Math.ceil(Math.log2(this.size+1))&&this._nodes.push([]);let s=e,n=this.size;for(let e=0;e<this.depth;e+=1){if(this._nodes[e][n]=s,1&n){const t=this._nodes[e][n-1];s=this._hash(t,s)}n>>=1}this._nodes[this.depth]=[s]}insertMany(e){if(t(e,"leaves"),i(e,"leaves"),0===e.length)throw new Error("There are no leaves to add");let s=this.size>>1;this._nodes[0]=this._nodes[0].concat(e);const n=Math.ceil(Math.log2(this.size))-this.depth;for(let e=0;e<n;e+=1)this._nodes.push([]);for(let e=0;e<this.depth;e+=1){const t=Math.ceil(this._nodes[e].length/2);for(let n=s;n<t;n+=1){const t=this._nodes[e][2*n+1],s=this._nodes[e][2*n],i=t?this._hash(s,t):s;this._nodes[e+1][n]=i}s>>=1}}update(e,n){t(e,"index"),t(n,"newLeaf"),s(e,"index");let i=n;for(let t=0;t<this.depth;t+=1){if(this._nodes[t][e]=i,1&e){const s=this._nodes[t][e-1];i=this._hash(s,i)}else{const s=this._nodes[t][e+1];void 0!==s&&(i=this._hash(i,s))}e>>=1}this._nodes[this.depth]=[i]}updateMany(e,n){if(t(n,"leaves"),t(e,"indices"),i(n,"leaves"),i(e,"indices"),n.length!==e.length)throw new Error("There is no correspondence between indices and leaves");let o=new Set;for(let t=0;t<e.length;t+=1){if(s(e[t],`index ${t}`),e[t]<0||e[t]>=this.size)throw new Error(`Index ${t} is out of range`);if(o.has(e[t]))throw new Error(`Leaf ${e[t]} is repeated`);o.add(e[t])}o.clear();for(let t=0;t<e.length;t+=1)this._nodes[0][e[t]]=n[t],o.add(e[t]>>1);for(let e=1;e<=this.depth;e+=1){const t=[];for(const s of o){const n=this._nodes[e-1][2*s],i=this._nodes[e-1][2*s+1];this._nodes[e][s]=i?this._hash(n,i):n,t.push(s>>1)}o=new Set(t)}}generateProof(e){if(t(e,"index"),s(e,"index"),e<0||e>=this.size)throw new Error(`The leaf at index '${e}' does not exist in this tree`);const n=this.leaves[e],i=[],o=[];for(let t=0;t<this.depth;t+=1){const s=1&e,n=s?e-1:e+1,r=this._nodes[t][n];void 0!==r&&(o.push(s),i.push(r)),e>>=1}return{root:this.root,leaf:n,index:Number.parseInt(o.reverse().join(""),2),siblings:i}}verifyProof(e){return o.verifyProof(e,this._hash)}static verifyProof(e,n){t(e,"proof");const{root:o,leaf:r,siblings:h,index:a}=e;t(e.root,"proof.root"),t(e.leaf,"proof.leaf"),t(e.siblings,"proof.siblings"),t(e.index,"proof.index"),i(e.siblings,"proof.siblings"),s(e.index,"proof.index");let d=r;for(let e=0;e<h.length;e+=1)d=a>>e&1?n(h[e],d):n(d,h[e]);return o===d}export(){return JSON.stringify(this._nodes,((e,t)=>"bigint"==typeof t?t.toString():t))}static import(e,s,i){t(e,"hash"),t(s,"nodes"),n(e,"hash"),function(e,t){if("string"!=typeof e)throw new TypeError(`Parameter '${t}' is not a string, received type: ${typeof e}`)}(s,"nodes"),i&&(t(i,"map"),n(i,"map"));const r=new o(e);return r._nodes=JSON.parse(s,((e,t)=>"string"==typeof t?i?i(t):BigInt(t):t)),r}}return e.LeanIMT=o,e}({});
