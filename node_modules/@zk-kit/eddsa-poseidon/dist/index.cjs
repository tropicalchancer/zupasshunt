/**
 * @module @zk-kit/eddsa-poseidon
 * @version 1.0.4
 * @file A JavaScript EdDSA library for secure signing and verification using Poseidon the Baby Jubjub elliptic curve.
 * @copyright Ethereum Foundation 2024
 * @license MIT
 * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/eddsa-poseidon}
*/
'use strict';

var babyJubjub = require('@zk-kit/baby-jubjub');
var utils = require('@zk-kit/utils');
var conversions = require('@zk-kit/utils/conversions');
var errorHandlers = require('@zk-kit/utils/error-handlers');
var F1Field = require('@zk-kit/utils/f1-field');
var scalar = require('@zk-kit/utils/scalar');
var buffer = require('buffer');
var poseidon5 = require('poseidon-lite/poseidon5');
var typeChecks = require('@zk-kit/utils/type-checks');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var scalar__namespace = /*#__PURE__*/_interopNamespaceDefault(scalar);

/**
 * Copyright
 * This code is a TypeScript adaptation of the 'blake-hash' library code (https://www.npmjs.com/package/blake-hash)
 * using the 'buffer' npm package (https://www.npmjs.com/package/buffer).
 * The 'js-crypto' library (https://github.com/iden3/js-crypto/blob/main/src/blake.ts) from Iden3 was used as a reference
 * for this work, specifically for types and adaptation.
 */
/**
 * @module Blake
 * Implements the Blake-512 cryptographic hash function.
 * Blake-512 is part of the BLAKE family of cryptographic hash functions, known
 * for its speed and security. This module offers functionality to compute Blake-512
 * hashes of input data, providing both one-time hashing capabilities and incremental
 * hashing to process large or streaming data.
 *
 * This code is adapted from the "blake-hash" JavaScript library, ensuring compatibility
 * and performance in TypeScript environments. It supports hashing with optional
 * salt for enhanced security in certain contexts.
 */
const zo = buffer.Buffer.from([0x01]);
const oo = buffer.Buffer.from([0x81]);
// Static properties for sigma, u256, u512, and padding are defined here below
const sigma = [
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],
    [14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3],
    [11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4],
    [7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8],
    [9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13],
    [2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9],
    [12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11],
    [13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10],
    [6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5],
    [10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0],
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],
    [14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3],
    [11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4],
    [7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8],
    [9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13],
    [2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9]
];
const u512 = [
    0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344, 0xa4093822, 0x299f31d0, 0x082efa98, 0xec4e6c89, 0x452821e6,
    0x38d01377, 0xbe5466cf, 0x34e90c6c, 0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5, 0xb5470917, 0x9216d5d9, 0x8979fb1b,
    0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7, 0xb8e1afed, 0x6a267e96, 0xba7c9045, 0xf12c7f99, 0x24a19947,
    0xb3916cf7, 0x0801f2e2, 0x858efc16, 0x636920d8, 0x71574e69
];
const padding = buffer.Buffer.from([
    0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
]);
/**
 * Performs a bitwise rotation on the values of two elements in an array.
 * This operation is a key component of the Blake-512 algorithm, enabling
 * the mixing of bits in a non-linear fashion.
 * @param v The array containing values to rotate.
 * @param i The index of the first element to rotate.
 * @param j The index of the second element to rotate.
 * @param n The number of bits to rotate by.
 */
function rot(v, i, j, n) {
    let hi = v[i * 2] ^ v[j * 2];
    let lo = v[i * 2 + 1] ^ v[j * 2 + 1];
    if (n >= 32) {
        lo ^= hi;
        hi ^= lo;
        lo ^= hi;
        n -= 32;
    }
    if (n === 0) {
        v[i * 2] = hi >>> 0;
        v[i * 2 + 1] = lo >>> 0;
    }
    else {
        v[i * 2] = ((hi >>> n) | (lo << (32 - n))) >>> 0;
        v[i * 2 + 1] = ((lo >>> n) | (hi << (32 - n))) >>> 0;
    }
}
/**
 * The G function is one of the core operations in the Blake-512 compression function.
 * It mixes the input values based on the message block and the round constants,
 * contributing to the diffusion and confusion properties of the hash function.
 * @param v The working vector, part of the state being updated.
 * @param m - The message block being processed.
 * @param i The current round index.
 * @param a, b, c, d Indices within the working vector to mix.
 * @param e Index within the message block and round constants.
 */
function g(v, m, i, a, b, c, d, e) {
    let lo;
    // v[a] += (m[sigma[i][e]] ^ u512[sigma[i][e+1]]) + v[b];
    lo = v[a * 2 + 1] + ((m[sigma[i][e] * 2 + 1] ^ u512[sigma[i][e + 1] * 2 + 1]) >>> 0) + v[b * 2 + 1];
    v[a * 2] =
        (v[a * 2] + ((m[sigma[i][e] * 2] ^ u512[sigma[i][e + 1] * 2]) >>> 0) + v[b * 2] + ~~(lo / 0x0100000000)) >>> 0;
    v[a * 2 + 1] = lo >>> 0;
    // v[d] = ROT( v[d] ^ v[a],32);
    rot(v, d, a, 32);
    // v[c] += v[d];
    lo = v[c * 2 + 1] + v[d * 2 + 1];
    v[c * 2] = (v[c * 2] + v[d * 2] + ~~(lo / 0x0100000000)) >>> 0;
    v[c * 2 + 1] = lo >>> 0;
    // v[b] = ROT( v[b] ^ v[c],25);
    rot(v, b, c, 25);
    // v[a] += (m[sigma[i][e+1]] ^ u512[sigma[i][e]])+v[b];
    lo = v[a * 2 + 1] + ((m[sigma[i][e + 1] * 2 + 1] ^ u512[sigma[i][e] * 2 + 1]) >>> 0) + v[b * 2 + 1];
    v[a * 2] =
        (v[a * 2] + ((m[sigma[i][e + 1] * 2] ^ u512[sigma[i][e] * 2]) >>> 0) + v[b * 2] + ~~(lo / 0x0100000000)) >>> 0;
    v[a * 2 + 1] = lo >>> 0;
    // v[d] = ROT( v[d] ^ v[a],16);
    rot(v, d, a, 16);
    // v[c] += v[d];
    lo = v[c * 2 + 1] + v[d * 2 + 1];
    v[c * 2] = (v[c * 2] + v[d * 2] + ~~(lo / 0x0100000000)) >>> 0;
    v[c * 2 + 1] = lo >>> 0;
    // v[b] = ROT( v[b] ^ v[c],11)
    rot(v, b, c, 11);
}
/**
 * Processes the carry for the bit length counter, ensuring it remains
 * within bounds as a 128-bit number.
 * @param arr The array representing the 128-bit counter.
 */
function lengthCarry(arr) {
    for (let j = 0; j < arr.length; j += 1) {
        if (arr[j] < 0x0100000000)
            break;
        arr[j] -= 0x0100000000;
        arr[j + 1] += 1;
    }
}
/**
 * Represents a Blake-512 hash computation instance.
 * This class maintains the internal state, buffers, and counters needed to
 * process input data and produce the final hash output. It supports incremental
 * hashing, allowing data to be added in chunks.
 */
/* eslint-disable import/prefer-default-export */
class Blake512 {
    /**
     * Initializes a new Blake-512 hash instance with the default parameters.
     */
    constructor() {
        this._h = [
            0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1, 0x510e527f,
            0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179
        ];
        this._s = [0, 0, 0, 0, 0, 0, 0, 0];
        this._block = buffer.Buffer.alloc(128);
        this._blockOffset = 0;
        this._length = [0, 0, 0, 0];
        this._nullt = false;
        this._zo = zo;
        this._oo = oo;
    }
    /**
     * The core compression function for Blake-512. It transforms the internal
     * state based on the input block and the current hash parameters.
     */
    _compress() {
        const v = new Array(32);
        const m = new Array(32);
        let i;
        for (i = 0; i < 32; i += 1)
            m[i] = this._block.readUInt32BE(i * 4);
        for (i = 0; i < 16; i += 1)
            v[i] = this._h[i] >>> 0;
        for (i = 16; i < 24; i += 1)
            v[i] = (this._s[i - 16] ^ u512[i - 16]) >>> 0;
        for (i = 24; i < 32; i += 1)
            v[i] = u512[i - 16];
        if (!this._nullt) {
            v[24] = (v[24] ^ this._length[1]) >>> 0;
            v[25] = (v[25] ^ this._length[0]) >>> 0;
            v[26] = (v[26] ^ this._length[1]) >>> 0;
            v[27] = (v[27] ^ this._length[0]) >>> 0;
            v[28] = (v[28] ^ this._length[3]) >>> 0;
            v[29] = (v[29] ^ this._length[2]) >>> 0;
            v[30] = (v[30] ^ this._length[3]) >>> 0;
            v[31] = (v[31] ^ this._length[2]) >>> 0;
        }
        for (i = 0; i < 16; i += 1) {
            /* column step */
            g(v, m, i, 0, 4, 8, 12, 0);
            g(v, m, i, 1, 5, 9, 13, 2);
            g(v, m, i, 2, 6, 10, 14, 4);
            g(v, m, i, 3, 7, 11, 15, 6);
            /* diagonal step */
            g(v, m, i, 0, 5, 10, 15, 8);
            g(v, m, i, 1, 6, 11, 12, 10);
            g(v, m, i, 2, 7, 8, 13, 12);
            g(v, m, i, 3, 4, 9, 14, 14);
        }
        for (i = 0; i < 16; i += 1) {
            this._h[(i % 8) * 2] = (this._h[(i % 8) * 2] ^ v[i * 2]) >>> 0;
            this._h[(i % 8) * 2 + 1] = (this._h[(i % 8) * 2 + 1] ^ v[i * 2 + 1]) >>> 0;
        }
        for (i = 0; i < 8; i += 1) {
            this._h[i * 2] = (this._h[i * 2] ^ this._s[(i % 4) * 2]) >>> 0;
            this._h[i * 2 + 1] = (this._h[i * 2 + 1] ^ this._s[(i % 4) * 2 + 1]) >>> 0;
        }
    }
    /**
     * Adds padding to the message as per the Blake-512 specification, ensuring
     * the message length is a multiple of the block size.
     */
    _padding() {
        const len = this._length.slice();
        len[0] += this._blockOffset * 8;
        lengthCarry(len);
        const msglen = buffer.Buffer.alloc(16);
        for (let i = 0; i < 4; i += 1)
            msglen.writeUInt32BE(len[3 - i], i * 4);
        if (this._blockOffset === 111) {
            this._length[0] -= 8;
            this.update(this._oo);
        }
        else {
            if (this._blockOffset < 111) {
                if (this._blockOffset === 0)
                    this._nullt = true;
                this._length[0] -= (111 - this._blockOffset) * 8;
                this.update(padding.subarray(0, 111 - this._blockOffset));
            }
            else {
                this._length[0] -= (128 - this._blockOffset) * 8;
                this.update(padding.subarray(0, 128 - this._blockOffset));
                this._length[0] -= 111 * 8;
                this.update(padding.subarray(1, 1 + 111));
                this._nullt = true;
            }
            this.update(this._zo);
            this._length[0] -= 8;
        }
        this._length[0] -= 128;
        this.update(msglen);
    }
    /**
     * Completes the hash computation and returns the final hash value.
     * This method applies the necessary padding, performs the final compression,
     * and returns the hash output.
     * @returns The Blake-512 hash of the input data.
     */
    digest() {
        this._padding();
        const buffer$1 = buffer.Buffer.alloc(64);
        for (let i = 0; i < 16; i += 1)
            buffer$1.writeUInt32BE(this._h[i], i * 4);
        return buffer$1;
    }
    /**
     * Updates the hash with new data. This method can be called multiple
     * times to incrementally add data to the hash computation.
     * @param data The data to add to the hash.
     * @returns This instance, to allow method chaining.
     */
    update(data) {
        const block = this._block;
        let offset = 0;
        while (this._blockOffset + data.length - offset >= block.length) {
            for (let i = this._blockOffset; i < block.length;)
                /* eslint-disable no-plusplus */
                block[i++] = data[offset++];
            this._length[0] += block.length * 8;
            lengthCarry(this._length);
            this._compress();
            this._blockOffset = 0;
        }
        while (offset < data.length)
            /* eslint-disable no-plusplus */
            block[this._blockOffset++] = data[offset++];
        return this;
    }
}

/**
 * Prunes a buffer to meet the specific requirements for using it as a private key
 * or part of a signature.
 * @param buff The buffer to be pruned.
 * @returns The pruned buffer.
 */
function pruneBuffer(buff) {
    buff[0] &= 0xf8;
    buff[31] &= 0x7f;
    buff[31] |= 0x40;
    return buff;
}
/**
 * Validates if the given object is a valid point on the Baby Jubjub elliptic curve.
 * @param point The point to validate.
 * @returns True if the object is a valid point, false otherwise.
 */
function isPoint(point) {
    return typeChecks.isArray(point) && point.length === 2 && typeChecks.isBigNumber(point[0]) && typeChecks.isBigNumber(point[1]);
}
/**
 * Checks if the provided object conforms to the expected format of a Signature.
 * @param signature The signature to validate.
 * @returns True if the object is a valid Signature, false otherwise.
 */
function isSignature(signature) {
    return (typeChecks.isObject(signature) &&
        Object.prototype.hasOwnProperty.call(signature, "R8") &&
        Object.prototype.hasOwnProperty.call(signature, "S") &&
        isPoint(signature.R8) &&
        typeChecks.isBigNumber(signature.S));
}
/**
 * Validates and converts a BigNumberish private key to a Buffer.
 * @param privateKey The private key to check and convert.
 * @returns The private key as a Buffer.
 */
function checkPrivateKey(privateKey) {
    errorHandlers.requireTypes(privateKey, "privateKey", ["Buffer", "Uint8Array", "string"]);
    return buffer.Buffer.from(privateKey);
}
/**
 * Validates and converts a BigNumberish message to a bigint.
 * @param message The message to check and convert.
 * @returns The message as a bigint.
 */
function checkMessage(message) {
    errorHandlers.requireTypes(message, "message", ["bignumberish", "string"]);
    if (typeChecks.isBigNumberish(message)) {
        return conversions.bigNumberishToBigInt(message);
    }
    return conversions.bufferToBigInt(buffer.Buffer.from(message));
}
/**
 * Computes the Blake512 hash of the input message.
 * Blake512 is a cryptographic hash function that produces a hash value of 512 bits,
 * commonly used for data integrity checks and other cryptographic applications.
 * @param message The input data to hash, provided as a Buffer.
 * @returns A Buffer containing the 512-bit hash result.
 */
function hash(message) {
    const engine = new Blake512();
    engine.update(buffer.Buffer.from(message));
    return engine.digest();
}

/**
 * Derives a secret scalar from a given EdDSA private key.
 *
 * This process involves hashing the private key with Blake1, pruning the resulting hash to retain the lower 32 bytes,
 * and converting it into a little-endian integer. The use of the secret scalar streamlines the public key generation
 * process by omitting steps 1, 2, and 3 as outlined in RFC 8032 section 5.1.5, enhancing circuit efficiency and simplicity.
 * This method is crucial for fixed-base scalar multiplication operations within the correspondent cryptographic circuit.
 * For detailed steps, see: {@link https://datatracker.ietf.org/doc/html/rfc8032#section-5.1.5}.
 * For example usage in a circuit, see: {@link https://github.com/semaphore-protocol/semaphore/blob/2c144fc9e55b30ad09474aeafa763c4115338409/packages/circuits/semaphore.circom#L21}
 *
 * The private key must be an instance of Buffer, Uint8Array or a string. The input will be used to
 * generate entropy and there is no limit in size.
 * The string is used as a set of raw bytes (in UTF-8) and is typically used to pass passwords or secret messages.
 * If you want to pass a bigint, a number or a hexadecimal, be sure to convert them to one of the supported types first.
 * The 'conversions' module in @zk-kit/utils provides a set of functions that may be useful in case you need to convert types.
 *
 * @param privateKey The EdDSA private key for generating the associated public key.
 * @returns The derived secret scalar to be used to calculate public key and optimized for circuit calculations.
 */
function deriveSecretScalar(privateKey) {
    // Convert the private key to buffer.
    privateKey = checkPrivateKey(privateKey);
    let hash$1 = hash(privateKey);
    hash$1 = hash$1.slice(0, 32);
    hash$1 = pruneBuffer(hash$1);
    return scalar__namespace.shiftRight(conversions.leBufferToBigInt(hash$1), BigInt(3)) % babyJubjub.subOrder;
}
/**
 * Derives a public key from a given private key using the
 * {@link https://eips.ethereum.org/EIPS/eip-2494|Baby Jubjub} elliptic curve.
 * This function utilizes the Baby Jubjub elliptic curve for cryptographic operations.
 * The private key should be securely stored and managed, and it should never be exposed
 * or transmitted in an unsecured manner.
 *
 * The private key must be an instance of Buffer, Uint8Array or a string. The input will be used to
 * generate entropy and there is no limit in size.
 * The string is used as a set of raw bytes (in UTF-8) and is typically used to pass passwords or secret messages.
 * If you want to pass a bigint, a number or a hexadecimal, be sure to convert them to one of the supported types first.
 * The 'conversions' module in @zk-kit/utils provides a set of functions that may be useful in case you need to convert types.
 *
 * @param privateKey The private key used for generating the public key.
 * @returns The derived public key.
 */
function derivePublicKey(privateKey) {
    const s = deriveSecretScalar(privateKey);
    return babyJubjub.mulPointEscalar(babyJubjub.Base8, s);
}
/**
 * Signs a message using the provided private key, employing Poseidon hashing and
 * EdDSA with the Baby Jubjub elliptic curve.
 *
 * The private key must be an instance of Buffer, Uint8Array or a string. The input will be used to
 * generate entropy and there is no limit in size.
 * The string is used as a set of raw bytes (in UTF-8) and is typically used to pass passwords or secret messages.
 * If you want to pass a bigint, a number or a hexadecimal, be sure to convert them to one of the supported types first.
 * The 'conversions' module in @zk-kit/utils provides a set of functions that may be useful in case you need to convert types.
 *
 * @param privateKey The private key used to sign the message.
 * @param message The message to be signed.
 * @returns The signature object, containing properties relevant to EdDSA signatures, such as 'R8' and 'S' values.
 */
function signMessage(privateKey, message) {
    // Convert the private key to buffer.
    privateKey = checkPrivateKey(privateKey);
    // Convert the message to big integer.
    message = checkMessage(message);
    const hash$1 = hash(privateKey);
    const sBuff = pruneBuffer(hash$1.slice(0, 32));
    const s = conversions.leBufferToBigInt(sBuff);
    const A = babyJubjub.mulPointEscalar(babyJubjub.Base8, scalar__namespace.shiftRight(s, BigInt(3)));
    const msgBuff = conversions.leBigIntToBuffer(message, 32);
    const rBuff = hash(buffer.Buffer.concat([hash$1.slice(32, 64), msgBuff]));
    const Fr = new F1Field(babyJubjub.subOrder);
    const r = Fr.e(conversions.leBufferToBigInt(rBuff));
    const R8 = babyJubjub.mulPointEscalar(babyJubjub.Base8, r);
    const hm = poseidon5.poseidon5([R8[0], R8[1], A[0], A[1], message]);
    const S = Fr.add(r, Fr.mul(hm, s));
    return { R8, S };
}
/**
 * Verifies an EdDSA signature using the Baby Jubjub elliptic curve and Poseidon hash function.
 * @param message The original message that was be signed.
 * @param signature The EdDSA signature to be verified.
 * @param publicKey The public key associated with the private key used to sign the message.
 * @returns Returns true if the signature is valid and corresponds to the message and public key, false otherwise.
 */
function verifySignature(message, signature, publicKey) {
    if (!isPoint(publicKey) ||
        !isSignature(signature) ||
        !babyJubjub.inCurve(signature.R8) ||
        !babyJubjub.inCurve(publicKey) ||
        BigInt(signature.S) >= babyJubjub.subOrder) {
        return false;
    }
    // Convert the message to big integer.
    message = checkMessage(message);
    // Convert the signature values to big integers for calculations.
    const _signature = {
        R8: [BigInt(signature.R8[0]), BigInt(signature.R8[1])],
        S: BigInt(signature.S)
    };
    // Convert the public key values to big integers for calculations.
    const _publicKey = [BigInt(publicKey[0]), BigInt(publicKey[1])];
    const hm = poseidon5.poseidon5([signature.R8[0], signature.R8[1], publicKey[0], publicKey[1], message]);
    const pLeft = babyJubjub.mulPointEscalar(babyJubjub.Base8, BigInt(signature.S));
    let pRight = babyJubjub.mulPointEscalar(_publicKey, scalar__namespace.mul(hm, BigInt(8)));
    pRight = babyJubjub.addPoint(_signature.R8, pRight);
    // Return true if the points match.
    return babyJubjub.Fr.eq(pLeft[0], pRight[0]) && babyJubjub.Fr.eq(pLeft[1], pRight[1]);
}
/**
 * Converts a given public key into a packed (compressed) string format for efficient transmission and storage.
 * This method ensures the public key is valid and within the Baby Jubjub curve before packing.
 * @param publicKey The public key to be packed.
 * @returns A string representation of the packed public key.
 */
function packPublicKey(publicKey) {
    if (!isPoint(publicKey) || !babyJubjub.inCurve(publicKey)) {
        throw new Error("Invalid public key");
    }
    // Convert the public key values to big integers for calculations.
    const _publicKey = [BigInt(publicKey[0]), BigInt(publicKey[1])];
    return babyJubjub.packPoint(_publicKey);
}
/**
 * Unpacks a public key from its packed string representation back to its original point form on the Baby Jubjub curve.
 * This function checks for the validity of the input format before attempting to unpack.
 * @param publicKey The packed public key as a bignumberish.
 * @returns The unpacked public key as a point.
 */
function unpackPublicKey(publicKey) {
    errorHandlers.requireBigNumberish(publicKey, "publicKey");
    const unpackedPublicKey = babyJubjub.unpackPoint(conversions.bigNumberishToBigInt(publicKey));
    if (unpackedPublicKey === null) {
        throw new Error("Invalid public key");
    }
    return unpackedPublicKey;
}
/**
 * Packs an EdDSA signature into a buffer of 64 bytes for efficient storage.
 * Use {@link unpackSignature} to reverse the process without needing to know
 * the details of the format.
 *
 * The buffer contains the R8 point packed int 32 bytes (via
 * {@link packSignature}) followed by the S scalar.  All encodings are
 * little-endian.
 *
 * @param signature the signature to pack
 * @returns a 64 byte buffer containing the packed signature
 */
function packSignature(signature) {
    if (!isSignature(signature) || !babyJubjub.inCurve(signature.R8) || BigInt(signature.S) >= babyJubjub.subOrder) {
        throw new Error("Invalid signature");
    }
    const numericSignature = {
        R8: signature.R8.map((c) => BigInt(c)),
        S: BigInt(signature.S)
    };
    const packedR8 = babyJubjub.packPoint(numericSignature.R8);
    const packedBytes = buffer.Buffer.alloc(64);
    packedBytes.set(conversions.leBigIntToBuffer(packedR8, 32), 0);
    packedBytes.set(conversions.leBigIntToBuffer(numericSignature.S, 32), 32);
    return packedBytes;
}
/**
 * Unpacks a signature produced by {@link packSignature}.  See that function
 * for the details of the format.
 *
 * @param packedSignature the 64 byte buffer to unpack
 * @returns a Signature with numbers in string form
 */
function unpackSignature(packedSignature) {
    utils.requireBuffer(packedSignature, "packedSignature");
    if (packedSignature.length !== 64) {
        throw new Error("Packed signature must be 64 bytes");
    }
    const sliceR8 = packedSignature.subarray(0, 32);
    const sliceS = packedSignature.subarray(32, 64);
    const unpackedR8 = babyJubjub.unpackPoint(conversions.leBufferToBigInt(sliceR8));
    if (unpackedR8 === null) {
        throw new Error(`Invalid packed signature point ${sliceS.toString("hex")}.`);
    }
    return {
        R8: unpackedR8,
        S: conversions.leBufferToBigInt(sliceS)
    };
}
/**
 * Represents a cryptographic entity capable of signing messages and verifying signatures
 * using the EdDSA scheme with Poseidon hash and the Baby Jubjub elliptic curve.
 */
class EdDSAPoseidon {
    /**
     * Initializes a new instance, deriving necessary cryptographic parameters from the provided private key.
     * If the private key is not passed as a parameter, a random 32-byte hexadecimal key is generated.
     *
     * The private key must be an instance of Buffer, Uint8Array or a string. The input will be used to
     * generate entropy and there is no limit in size.
     * The string is used as a set of raw bytes (in UTF-8) and is typically used to pass passwords or secret messages.
     * If you want to pass a bigint, a number or a hexadecimal, be sure to convert them to one of the supported types first.
     * The 'conversions' module in @zk-kit/utils provides a set of functions that may be useful in case you need to convert types.
     *
     * @param privateKey The private key used for signing and public key derivation.
     */
    constructor(privateKey = utils.crypto.getRandomValues(32)) {
        this.privateKey = privateKey;
        this.secretScalar = deriveSecretScalar(privateKey);
        this.publicKey = derivePublicKey(privateKey);
        this.packedPublicKey = packPublicKey(this.publicKey);
    }
    /**
     * Signs a given message using the private key and returns the signature.
     * @param message The message to be signed.
     * @returns The signature of the message.
     */
    signMessage(message) {
        return signMessage(this.privateKey, message);
    }
    /**
     * Verifies a signature against a message and the public key stored in this instance.
     * @param message The message whose signature is to be verified.
     * @param signature The signature to be verified.
     * @returns True if the signature is valid for the message and public key, false otherwise.
     */
    verifySignature(message, signature) {
        return verifySignature(message, signature, this.publicKey);
    }
}

exports.EdDSAPoseidon = EdDSAPoseidon;
exports.derivePublicKey = derivePublicKey;
exports.deriveSecretScalar = deriveSecretScalar;
exports.packPublicKey = packPublicKey;
exports.packSignature = packSignature;
exports.signMessage = signMessage;
exports.unpackPublicKey = unpackPublicKey;
exports.unpackSignature = unpackSignature;
exports.verifySignature = verifySignature;
